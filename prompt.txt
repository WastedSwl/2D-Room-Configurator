–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞:
- .eslintrc.js
- package-lock.json
- package.json
- postcss.config.js
+ public
  - index.html
  - manifest.json
- README.md
+ src
  - App.js
  + components
    + Configurator
      - appConstants.js
      + canvas
        - DefaultRectVisual.jsx
        - DoorVisual.jsx
        - Grid.jsx
        - MarqueeSelection.jsx
        - ObjectRendererGroup.jsx
        - ObjectVisual.jsx
        - OutletVisual.jsx
        - SelectionExtras.jsx
        - SnapGuides.jsx
        - SvgCanvas.jsx
        - WindowVisual.jsx
      + common
        - PropertyInput.jsx
      - Configurator.jsx
      - configuratorConstants.js
      - configuratorUtils.js
      - ElementRenderer.jsx
      - HelpPanel.jsx
      + hooks
        - useConfiguratorState.js
        - useKeyboardShortcuts.js
        - useModifierKeys.js
        - useMouseInteractions.js
        - useObjectManagement.js
        - useViewTransform.js
      + modes
        - FramelessMode.jsx
        - FrameMode.jsx
        - ModularMode.jsx
      - ProjectInfo.jsx
      + sidebar
        - PropertiesPanel.jsx
      + statusbar
        - StatusBar.jsx
      + toolbar
        - ConfiguratorToolbar.jsx
  - index.css
  - index.js
  - reportWebVitals.js
- tailwind.config.js

–°–æ–¥–µ—Ä–∂–∏–º–æ–µ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤:

==== .eslintrc.js ====
/* eslint-disable no-unused-vars */
// ========================================================================
// FILE: .eslintrc.js
// ========================================================================
// Assuming a standard ESLint config for Create React App or similar.
// No changes needed based on the prompt unless specific rules were provided.
module.exports = {
  env: {
    browser: true,
    es2021: true,
    jest: true,
  },
  extends: [
    "eslint:recommended",
    "react-app",
    "react-app/jest",
  ],
  parserOptions: {
    ecmaFeatures: {
      jsx: true,
    },
    ecmaVersion: "latest",
    sourceType: "module",
  },
  rules: {
    "react/react-in-jsx-scope": "off",
    "react/prop-types": "warn",
    "jsx-a11y/anchor-is-valid": "warn",
    "no-unused-vars": ["warn", { argsIgnorePattern: "^_" }],
  },
  settings: {
    react: {
      version: "detect",
    },
  },
  overrides: [
    {
      files: ["**/*.test.js", "**/*.test.jsx"],
      env: {
        jest: true,
      },
    },
  ],
};


==== package.json ====
{
  "name": "bird",
  "version": "0.2.0",
  "private": true,
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@heroicons/react": "^2.2.0",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.2.0",
    "@testing-library/user-event": "^13.5.0",
    "aos": "^2.3.4",
    "axios": "^1.8.4",
    "dotenv": "^16.4.7",
    "framer-motion": "^12.5.0",
    "prop-types": "^15.8.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-icons": "^5.5.0",
    "react-router-dom": "^7.4.0",
    "react-scripts": "^5.0.1",
    "react-select": "^5.10.1",
    "react-slick": "^0.30.3",
    "react-toastify": "^11.0.5",
    "slick-carousel": "^1.8.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@tailwindcss/aspect-ratio": "^0.4.2",
    "@tailwindcss/forms": "^0.5.10",
    "@tailwindcss/line-clamp": "^0.4.4",
    "@tailwindcss/postcss": "^4.0.15",
    "@tailwindcss/typography": "^0.5.16",
    "autoprefixer": "^10.4.21",
    "clsx": "^2.1.1",
    "eslint": "^8.57.1",
    "eslint-plugin-jsx-a11y": "^6.8.0",
    "eslint-plugin-react": "^7.34.1",
    "eslint-plugin-react-hooks": "^4.6.2",
    "husky": "^9.1.7",
    "lint-staged": "^15.5.0",
    "nodemon": "^3.1.9",
    "postcss": "^8.5.3",
    "postcss-flexbugs-fixes": "^5.0.2",
    "postcss-preset-env": "^10.1.5",
    "prettier": "^3.5.3",
    "tailwindcss": "^3.4.3"
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "*.{js,jsx,css,md}": "prettier --write",
    "*.{js,jsx}": "eslint --fix"
  }
}

==== postcss.config.js ====
// ========================================================================
// FILE: postcss.config.js
// ========================================================================
// Adjusted for standard Tailwind v3+ installation
module.exports = {
  plugins: {
    tailwindcss: {}, // Standard Tailwind plugin
    autoprefixer: {},
    // Removed '@tailwindcss/postcss7-compat' as using standard Tailwind now
    // Removed '@tailwindcss/postcss' which seems redundant/incorrect here
    // Removed 'postcss-flexbugs-fixes' and 'postcss-preset-env' as Autoprefixer handles prefixes
  },
};


==== public\index.html ====
<!-- FILE: public/index.html -->
<!-- No changes needed based on the prompt -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!-- Consider adding fonts here if needed, e.g., Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <title>Mission Hire | HRM App</title>
    <!-- Updated Title -->
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>


==== public\manifest.json ====
{
  "short_name": "Mission Hire",
  "name": "Mission Hire - Recruitment Platform",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#007BFF",
  "background_color": "#1A1A1A"
}


==== README.md ====
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)


==== src\App.js ====
import React from "react";
import Configurator from "./components/Configurator/Configurator";
import "./index.css"; // Ensure Tailwind CSS is imported

// –î–ª—è ModularMode –∏ –¥—Ä—É–≥–∏—Ö —Ä–µ–∂–∏–º–æ–≤ –º–æ–∂–µ—Ç –ø–æ–Ω–∞–¥–æ–±–∏—Ç—å—Å—è ToastContainer, –µ—Å–ª–∏ –±—É–¥–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å toast
import { ToastContainer } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";

// –ï—Å–ª–∏ —Ä–µ—à–∏—Ç–µ –≤—ã–Ω–µ—Å—Ç–∏ ProjectInfo –∏ HelpPanel –Ω–∞ —É—Ä–æ–≤–µ–Ω—å App
// import ProjectInfo from './components/Configurator/ProjectInfo';
// import HelpPanel from './components/Configurator/HelpPanel';

// –ï—Å–ª–∏ –±—É–¥–µ—Ç–µ —É–ø—Ä–∞–≤–ª—è—Ç—å —Ä–µ–∂–∏–º–∞–º–∏ –∏–∑ App.js
// import { DEFAULT_MODE, MODES } from './components/Configurator/appConstants';
// import FramelessMode from './components/Configurator/modes/FramelessMode';
// import FrameMode from './components/Configurator/modes/FrameMode';
// import ModularMode from './components/Configurator/modes/ModularMode';

function App() {
  // –ü—Ä–∏–º–µ—Ä —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º, –µ—Å–ª–∏ –≤—ã–Ω–µ—Å—Ç–∏ –µ–≥–æ –≤ App.js
  // const [activeMode, setActiveMode] = React.useState(DEFAULT_MODE);
  // const [projectInfoData, setProjectInfoData] = React.useState({ area: 0, cost: 0, elements: [] });

  // const renderModeSpecificUIForApp = (configuratorInterface) => {
  //   switch (activeMode) {
  //     case MODES.FRAMELESS:
  //       return <FramelessMode {...configuratorInterface} />;
  //     case MODES.FRAMED:
  //       return <FrameMode {...configuratorInterface} />;
  //     case MODES.MODULAR:
  //       return <ModularMode {...configuratorInterface} />;
  //     default:
  //       return null;
  //   }
  // };

  return (
    <div className="App h-screen flex flex-col">
      <ToastContainer position="bottom-right" autoClose={3000} newestOnTop />
      <Configurator
      // activeMode={activeMode} // –ü–µ—Ä–µ–¥–∞–µ–º, –µ—Å–ª–∏ —É–ø—Ä–∞–≤–ª—è–µ–º –∏–∑ App
      // setProjectInfoData={setProjectInfoData} // –ü–µ—Ä–µ–¥–∞–µ–º, –µ—Å–ª–∏ —É–ø—Ä–∞–≤–ª—è–µ–º –∏–∑ App
      // renderModeSpecificUI={renderModeSpecificUIForApp} // –ü–µ—Ä–µ–¥–∞–µ–º, –µ—Å–ª–∏ —É–ø—Ä–∞–≤–ª—è–µ–º –∏–∑ App
      />
      {/* <ProjectInfo {...projectInfoData} /> */}
      {/* <HelpPanel /> */}
    </div>
  );
}

export default App;


==== src\components\Configurator\appConstants.js ====
export const MODES = {
  MODULAR: "modular",
  FRAMELESS: "frameless",
  FRAMED: "framed",
};

export const DEFAULT_MODE = MODES.MODULAR;

export const DEFAULT_PANEL_WIDTH_M = 1.15;
export const DOOR_WIDTH_M = 0.9;
export const WINDOW_WIDTH_M = 1.2;
export const WALL_THICKNESS_M = 0.15;


==== src\components\Configurator\canvas\DefaultRectVisual.jsx ====
import React from "react";
import { 
    objectColors, 
    ARCH_WALL_FILL, 
    ARCH_WALL_STROKE, 
    ARCH_FURNITURE_STROKE 
} from "../configuratorConstants";

const DefaultRectVisual = ({ obj, scale, commonProps }) => {
  const widthScaled = Math.max(1, obj.width * scale);
  const heightScaled = Math.max(1, obj.height * scale);
  const isSelected = commonProps.stroke === "blue"; // Simple check based on current selection logic

  let fill = objectColors[obj.type] || objectColors.default;
  let stroke = ARCH_FURNITURE_STROKE; // Default stroke for furniture-like things
  let strokeWidth = isSelected ? 2 : 0.7; // Thinner base stroke

  if (obj.type === "wall") {
    fill = ARCH_WALL_FILL;
    stroke = ARCH_WALL_STROKE;
    strokeWidth = isSelected ? 2 : 1; // Slightly thicker base stroke for walls
  }

  // Override stroke for selection
  stroke = isSelected ? commonProps.stroke : stroke;

  return (
    <rect
      x={0}
      y={0}
      width={widthScaled}
      height={heightScaled}
      fill={fill}
      stroke={stroke}
      strokeWidth={strokeWidth}
      // Removed {...commonProps} to use calculated styles above
      style={commonProps.style} // Keep cursor style
      data-object-id={commonProps['data-object-id']} // Keep data attribute
    />
  );
};

export default React.memo(DefaultRectVisual);

==== src\components\Configurator\canvas\DoorVisual.jsx ====
import React from "react";
import {
  ARCH_DOOR_LEAF_FILL,
  ARCH_DOOR_STROKE,
  DOOR_LEAF_VISUAL_THICKNESS_M,
} from "../configuratorConstants";

const DoorVisual = ({ obj, scale, commonProps, isSelected, isLocked }) => {
  const frameW_s = obj.width * scale;
  const frameT_s = obj.height * scale; 
  const leafT_m = DOOR_LEAF_VISUAL_THICKNESS_M; // Use constant
  const leafT_s = leafT_m * scale;

  const pivotX_s = obj.hingeSide === "left" ? 0 : frameW_s;
  const pivotY_s = frameT_s / 2;

  let finalRotationForSVG = 0;
  if (obj.isOpen && obj.openingAngle !== 0) {
    let angle = obj.openingAngle;
    if (obj.openingDirection === "outward") angle *= -1;
    finalRotationForSVG = obj.hingeSide === "left" ? angle : -angle;
  }

  const arcRadius = frameW_s;
  const arcAngleRad = finalRotationForSVG * (Math.PI / 180);
  const arcStartX = pivotX_s;
  const arcStartY = pivotY_s;
  const arcEndX = pivotX_s + arcRadius * Math.cos(arcAngleRad);
  const arcEndY = pivotY_s + arcRadius * Math.sin(arcAngleRad);
  const arcSweepFlag = finalRotationForSVG >= 0 ? 1 : 0;

  const leafStrokeWidth = isSelected ? 1.5 : 0.7;
  const arcStrokeWidth = isSelected ? 1 : 0.5;

  return (
    <>
      {/* Door Leaf */}
      <g transform={`rotate(${finalRotationForSVG}, ${pivotX_s}, ${pivotY_s})`}>
        <rect
          // Draw leaf centered on its thickness axis relative to pivot
          x={obj.hingeSide === 'left' ? 0 : -frameW_s}
          y={pivotY_s - leafT_s / 2}
          width={frameW_s}
          height={leafT_s}
          fill={ARCH_DOOR_LEAF_FILL}
          stroke={isSelected ? "blue" : ARCH_DOOR_STROKE}
          strokeWidth={leafStrokeWidth}
        />
      </g>
      {/* Swing Arc */}
      {obj.isOpen && obj.openingAngle > 0 && (
        <path
          d={`M ${arcStartX} ${arcStartY} A ${arcRadius} ${arcRadius} 0 0 ${arcSweepFlag} ${arcEndX} ${arcEndY}`}
          fill="none"
          stroke={isSelected ? "blue" : ARCH_DOOR_STROKE}
          strokeWidth={arcStrokeWidth}
          strokeDasharray="3,2" // Standard dash for door swing
          opacity={isSelected ? 1 : 0.7}
        />
      )}
    </>
  );
};
export default React.memo(DoorVisual);

==== src\components\Configurator\canvas\Grid.jsx ====
// src/components/Configurator/canvas/Grid.jsx
import React from "react";
import {
  GRID_LINE_COLOR,
  GRID_BOLD_LINE_COLOR,
  ORIGIN_POINT_COLOR,
  INITIAL_PPM,
} from "../configuratorConstants";

const Grid = ({ viewTransform, svgWidth, svgHeight }) => {
  // –ü—Ä–∏–Ω–∏–º–∞–µ–º svgWidth, svgHeight
  if (svgWidth === 0 || svgHeight === 0) return null; // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–µ—Å—å

  const { x: viewX, y: viewY, scale } = viewTransform;
  const finalGridLines = [];

  const majorGridSizeWorld = 1;
  const minorGridDivisions = 10;

  const majorGridSizeScaled = majorGridSizeWorld * scale;
  const minorGridSizeScaled = (majorGridSizeWorld / minorGridDivisions) * scale;

  const majorLineThreshold = 20;
  const minorLineThreshold = 5;

  if (majorGridSizeScaled > majorLineThreshold) {
    const startOffsetX = viewX % majorGridSizeScaled;
    for (let x = startOffsetX; x < svgWidth; x += majorGridSizeScaled) {
      finalGridLines.push(
        <line
          key={`major-gv-${x}`}
          x1={x}
          y1={0}
          x2={x}
          y2={svgHeight}
          stroke={GRID_BOLD_LINE_COLOR}
          strokeWidth={0.5}
        />,
      );
    }
    if (
      minorGridSizeScaled > minorLineThreshold &&
      majorGridSizeScaled / minorGridSizeScaled > 1.5
    ) {
      const minorStartOffsetX = viewX % minorGridSizeScaled;
      for (let x = minorStartOffsetX; x < svgWidth; x += minorGridSizeScaled) {
        if (
          Math.abs(
            (x - (viewX % majorGridSizeScaled) + majorGridSizeScaled) %
              majorGridSizeScaled,
          ) >
          minorGridSizeScaled * 0.1
        ) {
          finalGridLines.push(
            <line
              key={`minor-gv-${x}`}
              x1={x}
              y1={0}
              x2={x}
              y2={svgHeight}
              stroke={GRID_LINE_COLOR}
              strokeWidth={0.25}
            />,
          );
        }
      }
    }
  }

  if (majorGridSizeScaled > majorLineThreshold) {
    const startOffsetY = viewY % majorGridSizeScaled;
    for (let y = startOffsetY; y < svgHeight; y += majorGridSizeScaled) {
      finalGridLines.push(
        <line
          key={`major-gh-${y}`}
          x1={0}
          y1={y}
          x2={svgWidth}
          y2={y}
          stroke={GRID_BOLD_LINE_COLOR}
          strokeWidth={0.5}
        />,
      );
    }
    if (
      minorGridSizeScaled > minorLineThreshold &&
      majorGridSizeScaled / minorGridSizeScaled > 1.5
    ) {
      const minorStartOffsetY = viewY % minorGridSizeScaled;
      for (let y = minorStartOffsetY; y < svgHeight; y += minorGridSizeScaled) {
        if (
          Math.abs(
            (y - (viewY % majorGridSizeScaled) + majorGridSizeScaled) %
              majorGridSizeScaled,
          ) >
          minorGridSizeScaled * 0.1
        ) {
          finalGridLines.push(
            <line
              key={`minor-gh-${y}`}
              x1={0}
              y1={y}
              x2={svgWidth}
              y2={y}
              stroke={GRID_LINE_COLOR}
              strokeWidth={0.25}
            />,
          );
        }
      }
    }
  }

  return <g id="grid">{finalGridLines}</g>;
};

export default React.memo(Grid);


==== src\components\Configurator\canvas\MarqueeSelection.jsx ====
// src/components/Configurator/canvas/MarqueeSelection.jsx
import React from "react";
import {
  MARQUEE_FILL_COLOR,
  MARQUEE_STROKE_COLOR,
} from "../configuratorConstants";

const MarqueeSelection = ({ marqueeRect, svgRef }) => {
  if (!marqueeRect || !marqueeRect.active || !svgRef || !svgRef.current) {
    return null;
  }

  const svgDomRect = svgRef.current.getBoundingClientRect();
  // –ï—Å–ª–∏ SVG –µ—â–µ –Ω–µ –æ—Ç—Ä–µ–Ω–¥–µ—Ä–∏–ª—Å—è —Å —Ä–∞–∑–º–µ—Ä–∞–º–∏, –Ω–µ —Ä–∏—Å–æ–≤–∞—Ç—å
  if (svgDomRect.width === 0 || svgDomRect.height === 0) {
    return null;
  }

  // marqueeRect —Å–æ–¥–µ—Ä–∂–∏—Ç startScreenX/Y –∏ currentScreenX/Y –≤ —ç–∫—Ä–∞–Ω–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
  // –ò—Ö –Ω—É–∂–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ SVG —ç–ª–µ–º–µ–Ω—Ç–∞
  const x =
    Math.min(marqueeRect.startScreenX, marqueeRect.currentScreenX) -
    svgDomRect.left;
  const y =
    Math.min(marqueeRect.startScreenY, marqueeRect.currentScreenY) -
    svgDomRect.top;
  const width = Math.abs(marqueeRect.startScreenX - marqueeRect.currentScreenX);
  const height = Math.abs(
    marqueeRect.startScreenY - marqueeRect.currentScreenY,
  );

  return (
    <rect
      x={x}
      y={y}
      width={width}
      height={height}
      fill={MARQUEE_FILL_COLOR}
      stroke={MARQUEE_STROKE_COLOR}
      strokeWidth="1" // –û–±—ã—á–Ω–æ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —à–∏—Ä–∏–Ω–∞ –¥–ª—è —Ä–∞–º–∫–∏ –≤—ã–¥–µ–ª–µ–Ω–∏—è
      pointerEvents="none" // –ù–µ –¥–æ–ª–∂–Ω–∞ –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞—Ç—å —Å–æ–±—ã—Ç–∏—è
    />
  );
};

export default React.memo(MarqueeSelection);


==== src\components\Configurator\canvas\ObjectRendererGroup.jsx ====
// src/components/Configurator/canvas/ObjectRendererGroup.jsx
import React from "react";
import ObjectVisual from "./ObjectVisual";

const ObjectRendererGroup = ({
  objects,
  viewTransform,
  selectedObjectIds,
  lockedObjectIds,
  overlappingObjectIds,
  modifierKeys,
  handleMouseDownOnObject,
  handleMouseDownOnResizeHandle,
  draggingState,
  resizingState,
  onAddObject,
  addingCorridorMode,
  onAddCorridor,
}) => {
  return (
    <>
      {objects.map((obj) => {
        if (!obj) return null;
        return (
          <ObjectVisual
            key={obj.id}
            obj={obj}
            scale={viewTransform.scale}
            isSelected={selectedObjectIds.includes(obj.id)}
            isLocked={lockedObjectIds.includes(obj.id)}
            isOverlapping={overlappingObjectIds.includes(obj.id)}
            modifierKeys={modifierKeys}
            onMouseDown={handleMouseDownOnObject}
            onResizeHandleMouseDown={handleMouseDownOnResizeHandle}
            draggingState={draggingState}
            resizingState={resizingState}
            onAddObject={onAddObject}
            addingCorridorMode={addingCorridorMode}
            onAddCorridor={onAddCorridor}
            objects={objects}
          />
        );
      })}
    </>
  );
};
export default React.memo(ObjectRendererGroup);


==== src\components\Configurator\canvas\ObjectVisual.jsx ====
import React from "react";
import SelectionExtras from "./SelectionExtras";
import DoorVisual from "./DoorVisual";
import WindowVisual from "./WindowVisual"; 
import OutletVisual from "./OutletVisual"; 
import DefaultRectVisual from "./DefaultRectVisual"; 

import {
  objectColors,
  OVERLAP_HIGHLIGHT_COLOR,
  LOCKED_OBJECT_STROKE_COLOR,
  defaultObjectSizes, 
  INITIAL_PPM,
} from "../configuratorConstants";

const ObjectVisual = ({
  obj,
  scale,
  isSelected,
  isLocked,
  isOverlapping,
  modifierKeys,
  onMouseDown,
  onResizeHandleMouseDown,
  draggingState,
  resizingState,
  onAddObject,
  addingCorridorMode,
  onAddCorridor,
  objects,
}) => {
  const [hoveredCorridor, setHoveredCorridor] = React.useState(null);

  const rotationCenterXScaled = (obj.width * scale) / 2;
  const rotationCenterYScaled = (obj.height * scale) / 2;

  let strokeColor = objectColors[obj.type]
    ? objectColors[obj.type] === "lightgray"
      ? "#555"
      : "black"
    : "black";
  if (obj.type === "wall") strokeColor = "#666";
  if (isLocked) strokeColor = LOCKED_OBJECT_STROKE_COLOR;
  else if (isSelected) strokeColor = "blue";

  const baseStrokeWidthUnscaled = 1;
  const selectedStrokeWidthUnscaled = 2;
  const baseStrokeWidth = Math.max(
    0.2,
    baseStrokeWidthUnscaled / (scale / INITIAL_PPM),
  );
  const selectedStrokeWidth = Math.max(
    0.5,
    selectedStrokeWidthUnscaled / (scale / INITIAL_PPM),
  );

  const commonProps = {
    stroke: strokeColor,
    strokeWidth:
      isSelected && !isLocked ? selectedStrokeWidth : baseStrokeWidth,
    style: {
      cursor:
        isLocked && !modifierKeys.shift && !isSelected
          ? "default"
          : draggingState?.initialPositions?.find((p) => p.id === obj.id) ||
              resizingState?.objectId === obj.id
            ? "grabbing"
            : "grab",
    },
    "data-object-id": obj.id,
  };

  const groupTransform = `translate(${obj.x * scale}, ${obj.y * scale}) rotate(${obj.rotation || 0}, ${rotationCenterXScaled}, ${rotationCenterYScaled})`;

  let specificVisual;
  if (obj.type === "door") {
    specificVisual = (
      <DoorVisual
        obj={obj}
        scale={scale}
        commonProps={commonProps}
        isSelected={isSelected}
        isLocked={isLocked}
      />
    );
  } else if (obj.type === "window") {
    specificVisual = (
      <WindowVisual obj={obj} scale={scale} commonProps={commonProps} />
    );
  } else if (obj.type === "outlet") {
    specificVisual = (
      <OutletVisual
        obj={obj}
        scale={scale}
        commonProps={commonProps}
        rotationCenterXScaled={rotationCenterXScaled}
        rotationCenterYScaled={rotationCenterYScaled}
      />
    );
  } else if (obj.type === "corridor") {
    const isVertical = obj.height > obj.width;
    const lineLength = isVertical ? obj.height * scale : obj.width * scale;
    const lineThickness = 2; 
    specificVisual = (
      <line
        x1={isVertical ? lineThickness / 2 : 0}
        y1={isVertical ? 0 : lineThickness / 2}
        x2={isVertical ? lineThickness / 2 : lineLength}
        y2={isVertical ? lineLength : lineThickness / 2}
        stroke="#222"
        strokeWidth={lineThickness}
      />
    );
  } else if (obj.type === "module" && obj.bathroom && obj.shower) {
    specificVisual = (
      <DefaultRectVisual
        obj={obj}
        width={obj.width * scale}
        height={obj.height * scale}
        {...commonProps}
      />
    );
  } else if (obj.type === "module" && obj.bathroom) {
    specificVisual = (
      <DefaultRectVisual
        obj={obj}
        width={obj.width * scale}
        height={obj.height * scale}
        {...commonProps}
      />
    );
  } else if (obj.type === "module" && !obj.corridor && !obj.bathroom && !obj.shower) {
    const patternId = `module-hatch-${obj.id}`;
    const wallThickness = 0.08; 
    const blockSize = 1; 
    
    const wallBlocks = [];
    
    for (let x_seg = 0; x_seg < obj.width; x_seg += blockSize) {
      wallBlocks.push({
        x: x_seg, 
        y: 0,     
        width: Math.min(blockSize, obj.width - x_seg),
        height: wallThickness,
        side: 'top',
        segmentIndex: Math.floor(x_seg / blockSize)
      });
      wallBlocks.push({
        x: x_seg,
        y: obj.height - wallThickness,
        width: Math.min(blockSize, obj.width - x_seg),
        height: wallThickness,
        side: 'bottom',
        segmentIndex: Math.floor(x_seg / blockSize)
      });
    }
    
    for (let y_seg = wallThickness; y_seg < obj.height - wallThickness; y_seg += blockSize) {
       wallBlocks.push({
        x: 0,
        y: y_seg,
        width: wallThickness,
        height: Math.min(blockSize, obj.height - y_seg - wallThickness),
        side: 'left',
        segmentIndex: Math.floor((y_seg - wallThickness) / blockSize)
      });
      wallBlocks.push({
        x: obj.width - wallThickness,
        y: y_seg,
        width: wallThickness,
        height: Math.min(blockSize, obj.height - y_seg - wallThickness),
        side: 'right',
        segmentIndex: Math.floor((y_seg - wallThickness) / blockSize)
      });
    }
    
    let corridorBlocks = [];
    const existingCorridors = (window.__corridorObjectsCache = window.__corridorObjectsCache || []);
    if (Array.isArray(existingCorridors)) {
      existingCorridors.length = 0;
    }
    
    for (let i = 1; i < obj.width; i++) {
      for (let j = 0; j < obj.height - 1; j++) {
         const blockX = i * blockSize * scale;
         const blockY = j * blockSize * scale;
         const blockH = blockSize * scale;
         const plusX = blockX;
         const plusY = blockY + blockH / 2;
         const isHovered = hoveredCorridor && 
           hoveredCorridor.type === 'vertical' && 
           hoveredCorridor.index === i && 
           hoveredCorridor.blockIndex === j;
        
         const corridorExists = Array.isArray(existingCorridors) && existingCorridors.some(c =>
           c.parentId === obj.id &&
           c.orientation === 'vertical' &&
           Math.abs(c.x - (obj.x + i * blockSize)) < 0.01 && 
           Math.abs(c.y - (obj.y + j * blockSize)) < 0.01
         );
         if (!corridorExists) {
           corridorBlocks.push(
             <g key={`corridor-vblock-${i}-${j}`}
               onMouseEnter={() => setHoveredCorridor({ 
                 type: 'vertical', index: i, blockIndex: j,
                 x: obj.x + i * blockSize, y: obj.y + j * blockSize, 
                 width: blockSize, height: blockSize, 
                 orientation: 'vertical', parentId: obj.id 
               })}
               onMouseLeave={() => setHoveredCorridor(null)}
             >
               <rect x={blockX - 8} y={blockY} width={16} height={blockH} fill="transparent" style={{ cursor: 'pointer' }}/>
               {isHovered && <line x1={blockX} y1={blockY} x2={blockX} y2={blockY + blockH} stroke="#4f46e5" strokeWidth={2} strokeDasharray="4,4" opacity={0.5} />}
               {isHovered && (
                 <g style={{ cursor: 'pointer' }} onClick={(e) => {
                     e.stopPropagation();
                     if (typeof onAddCorridor === 'function') { onAddCorridor({ ...hoveredCorridor }); } 
                     else { console.warn('onAddCorridor is not a function!'); }
                   }}>
                   <circle cx={plusX} cy={plusY} r={14} fill="#fff" stroke="#4f46e5" strokeWidth={2} opacity={0.9} style={{ filter: 'drop-shadow(0 2px 4px rgba(0,0,0,0.2))', transition: 'all 0.2s ease' }}/>
                   <text x={plusX} y={plusY + 5} textAnchor="middle" fontSize="20" fill="#4f46e5" fontWeight="bold" opacity={0.9} style={{ filter: 'drop-shadow(0 1px 2px rgba(0,0,0,0.1))', transition: 'all 0.2s ease' }}>+</text>
                 </g>)}
             </g>
           );
         }
       }
     }
    
    for (let j = 1; j < obj.height; j++) {
      for (let i = 0; i < obj.width - 1; i++) {
         const blockX = i * blockSize * scale;
         const blockY = j * blockSize * scale;
         const blockW = blockSize * scale;
         const plusX = blockX + blockW / 2;
         const plusY = blockY;
         const isHovered = hoveredCorridor && 
           hoveredCorridor.type === 'horizontal' && 
           hoveredCorridor.index === j && 
           hoveredCorridor.blockIndex === i;
        
         const corridorExists = Array.isArray(existingCorridors) && existingCorridors.some(c =>
           c.parentId === obj.id &&
           c.orientation === 'horizontal' &&
           Math.abs(c.x - (obj.x + i * blockSize)) < 0.01 &&
           Math.abs(c.y - (obj.y + j * blockSize)) < 0.01
         );
         if (!corridorExists) {
           corridorBlocks.push(
             <g key={`corridor-hblock-${j}-${i}`}
               onMouseEnter={() => setHoveredCorridor({ 
                 type: 'horizontal', index: j, blockIndex: i,
                 x: obj.x + i * blockSize, y: obj.y + j * blockSize, 
                 width: blockSize, height: blockSize, 
                 orientation: 'horizontal', parentId: obj.id 
               })}
               onMouseLeave={() => setHoveredCorridor(null)}
             >
               <rect x={blockX} y={blockY - 8} width={blockW} height={16} fill="transparent" style={{ cursor: 'pointer' }}/>
               {isHovered && <line x1={blockX} y1={blockY} x2={blockX + blockW} y2={blockY} stroke="#4f46e5" strokeWidth={2} strokeDasharray="4,4" opacity={0.5} />}
               {isHovered && (
                 <g style={{ cursor: 'pointer' }} onClick={(e) => {
                     e.stopPropagation();
                     if (typeof onAddCorridor === 'function') { onAddCorridor({ ...hoveredCorridor }); } 
                     else { console.warn('onAddCorridor is not a function!'); }
                   }}>
                   <circle cx={plusX} cy={plusY} r={14} fill="#fff" stroke="#4f46e5" strokeWidth={2} opacity={0.9} style={{ filter: 'drop-shadow(0 2px 4px rgba(0,0,0,0.2))', transition: 'all 0.2s ease' }} />
                   <text x={plusX} y={plusY + 5} textAnchor="middle" fontSize="20" fill="#4f46e5" fontWeight="bold" opacity={0.9} style={{ filter: 'drop-shadow(0 1px 2px rgba(0,0,0,0.1))', transition: 'all 0.2s ease' }}>+</text>
                 </g>)}
             </g>
           );
         }
       }
     }

    const occupiedSegments = new Set();
    if (objects && obj.type === 'module') {
      objects.forEach(el => {
        if (
          (el.type === 'door' || el.type === 'window' || el.type === 'outlet') &&
          el.parentId === obj.id &&
          el.side && typeof el.segmentIndex === 'number'
        ) {
          occupiedSegments.add(`${el.side}-${el.segmentIndex}`);
        }
      });
    }

    specificVisual = (
      <>
        <defs>
          <pattern id={patternId} width={8} height={8} patternTransform="rotate(45)" patternUnits="userSpaceOnUse">
            <line x1="0" y1="0" x2="0" y2="8" stroke="#bbb" strokeWidth="1" />
          </pattern>
        </defs>
        
        <rect
          x={wallThickness * scale}
          y={wallThickness * scale}
          width={(obj.width - 2 * wallThickness) * scale}
          height={(obj.height - 2 * wallThickness) * scale}
          fill={`url(#${patternId})`}
          stroke="none"
        />
        
        {wallBlocks.map((block, index) => (
          occupiedSegments.has(`${block.side}-${block.segmentIndex}`) ? null : (
            <g key={`wall-block-${index}`}>
              <rect 
                x={(block.x + 0.02) * scale}
                y={(block.y + 0.02) * scale}
                width={block.width * scale}
                height={block.height * scale}
                fill="#222"
                opacity="0.3"
              />
              <rect 
                x={block.x * scale}
                y={block.y * scale}
                width={block.width * scale}
                height={block.height * scale}
                fill="#444"
                stroke="#222"
                strokeWidth={0.5}
                style={{
                  cursor: 'pointer',
                  transition: 'all 0.2s ease',
                  filter: 'drop-shadow(0 1px 1px rgba(0,0,0,0.2))'
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.fill = '#666';
                  e.currentTarget.style.filter = 'drop-shadow(0 2px 2px rgba(0,0,0,0.3))';
                  e.currentTarget.style.transform = 'translateY(-1px)';
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.fill = '#444';
                  e.currentTarget.style.filter = 'drop-shadow(0 1px 1px rgba(0,0,0,0.2))';
                  e.currentTarget.style.transform = 'translateY(0)';
                }}
                onClick={(e) => {
                  e.stopPropagation();
                  const panel = document.createElement('div');
                  panel.className = 'fixed bg-white rounded-lg shadow-lg p-4 z-50';
                  panel.style.left = `${e.clientX}px`;
                  panel.style.top = `${e.clientY}px`;
                  
                  const buttons = [
                    { type: 'door', label: '–î–≤–µ—Ä—å', icon: 'üö™' },
                    { type: 'window', label: '–û–∫–Ω–æ', icon: 'ü™ü' },
                    { type: 'outlet', label: '–†–æ–∑–µ—Ç–∫–∞', icon: 'üîå' }
                  ];
                  
                  buttons.forEach(btn => {
                    const button = document.createElement('button');
                    button.className = 'flex items-center gap-2 px-3 py-2 rounded hover:bg-gray-100 w-full mb-2';
                    button.innerHTML = `${btn.icon} ${btn.label}`;
                    button.onclick = () => {
                      if (typeof onAddObject === 'function') {
                        const elementDefaultSize = defaultObjectSizes[btn.type];
                        if (!elementDefaultSize) {
                          console.error(`No default size for type ${btn.type}`);
                          if (panel.parentNode) panel.parentNode.removeChild(panel);
                          return;
                        }

                        const elW = elementDefaultSize.width; 
                        const elH = elementDefaultSize.height; 
                        
                        let newElementX, newElementY;
                        let elementRotation = 0;
                        
                        const moduleWorldX = obj.x;
                        const moduleWorldY = obj.y;
                        const blockLocalX = block.x;
                        const blockLocalY = block.y;
                        const blockW = block.width;
                        const blockH = block.height;
                        
                        // Calculate the center of the wall block in world coordinates
                        const blockCenterX = moduleWorldX + blockLocalX + blockW / 2;
                        const blockCenterY = moduleWorldY + blockLocalY + blockH / 2;

                        // Calculate the top-left corner (newElementX, newElementY) 
                        // needed for the element so its center aligns with the block center.
                        newElementX = blockCenterX - elW / 2;
                        newElementY = blockCenterY - elH / 2;

                        // Assign rotation based on the wall side
                        if (block.side === 'top') {
                          elementRotation = 0;
                        } else if (block.side === 'bottom') {
                          elementRotation = 180; 
                        } else if (block.side === 'left') {
                           elementRotation = -90;
                        } else if (block.side === 'right') {
                           elementRotation = 90;
                        } else {
                          console.error("Unknown block side:", block.side);
                          if (panel.parentNode) panel.parentNode.removeChild(panel);
                          return;
                        }

                        onAddObject(
                          btn.type,
                          newElementX, // Use calculated top-left X
                          newElementY, // Use calculated top-left Y
                          elW, // Use intrinsic element width
                          elH, // Use intrinsic element height
                          {
                            rotation: elementRotation,
                            segmentIndex: block.segmentIndex,
                            side: block.side,
                            parentId: obj.id, 
                            ...(btn.type === 'door' && { isOpen: false, openingAngle: 90, hingeSide: 'left', openingDirection: 'inward' }),
                          }
                        );
                      }
                      if (panel.parentNode) {
                        panel.parentNode.removeChild(panel);
                      }
                    };
                    panel.appendChild(button);
                  });
                  
                  const closeBtn = document.createElement('button');
                  closeBtn.className = 'absolute top-2 right-2 text-gray-500 hover:text-gray-700';
                  closeBtn.innerHTML = '‚úï';
                  closeBtn.onclick = () => {
                    if (panel.parentNode) {
                      panel.parentNode.removeChild(panel);
                    }
                  };
                  panel.appendChild(closeBtn);
                  
                  document.body.appendChild(panel);
                  
                  const closePanel = (e) => {
                    if (panel.parentNode && !panel.contains(e.target)) {
                      panel.parentNode.removeChild(panel);
                      document.removeEventListener('click', closePanel);
                    }
                  };
                  setTimeout(() => document.addEventListener('click', closePanel), 0);
                }}
              />
            </g>
          )
        ))}
        {corridorBlocks}
      </>
    );
  } else if (obj.type === "module") {
    specificVisual = (
      <DefaultRectVisual
        obj={obj}
        width={obj.width * scale}
        height={obj.height * scale}
        {...commonProps}
      />
    );
  } else {
    specificVisual = (
      <DefaultRectVisual obj={obj} scale={scale} commonProps={commonProps} />
    );
  }

  const canInteractWithHandles = !isLocked || modifierKeys.shift;

  return (
    <g transform={groupTransform} onMouseDown={(e) => onMouseDown(e, obj.id)}>
      {specificVisual}
      {isOverlapping && !isLocked && (
        <rect
          x="0"
          y="0"
          width={Math.max(1, obj.width * scale)}
          height={Math.max(1, obj.height * scale)}
          fill={OVERLAP_HIGHLIGHT_COLOR}
          stroke="red"
          strokeWidth={commonProps.strokeWidth * 0.5}
          pointerEvents="none"
        />
      )}
      {isSelected && !isLocked && (
        <SelectionExtras
          obj={obj}
          scale={scale}
          canInteractWithHandles={canInteractWithHandles}
          onResizeHandleMouseDown={onResizeHandleMouseDown}
        />
      )}
      {obj.label && isSelected && !isLocked && (
        <text
          x={(obj.width * scale) / 2}
          y={obj.height * scale + 12 / (scale / INITIAL_PPM)}
          fontSize={`${10 / (scale / INITIAL_PPM)}px`}
          textAnchor="middle"
          fill="#333"
          style={{ pointerEvents: "none" }}
        >
          {obj.label}
        </text>
      )}
    </g>
  );
};
export default React.memo(ObjectVisual);

==== src\components\Configurator\canvas\OutletVisual.jsx ====
import React from "react";
import { ARCH_OUTLET_FILL, ARCH_OUTLET_STROKE } from "../configuratorConstants";

const OutletVisual = ({
  obj,
  scale,
  commonProps,
  rotationCenterXScaled,
  rotationCenterYScaled,
  isSelected
}) => {
 
  const baseRadius = Math.max(1, (obj.width * scale) / 2);
  const strokeWidth = isSelected ? 1.5 : 0.7;
  const radius = baseRadius - strokeWidth / 2;

  return (
    // Simple circle representation for now
    <circle
      cx={rotationCenterXScaled} 
      cy={rotationCenterYScaled}
      r={radius}
      fill={ARCH_OUTLET_FILL}
      stroke={isSelected ? "blue" : ARCH_OUTLET_STROKE}
      strokeWidth={strokeWidth}
      style={commonProps.style}
      data-object-id={commonProps['data-object-id']}
    />
    // Could alternatively use an SVG path for a more standard outlet symbol
  );
};

export default React.memo(OutletVisual);

==== src\components\Configurator\canvas\SelectionExtras.jsx ====
// src/components/Configurator/canvas/SelectionExtras.jsx
import React from "react";
import {
  RESIZE_HANDLE_SIZE_PX,
  RESIZE_HANDLE_COLOR,
  INITIAL_PPM,
  DIMENSION_TEXT_COLOR,
  DIMENSION_TEXT_BG_COLOR,
} from "../configuratorConstants";
import { getResizeCursorForHandle } from "../configuratorUtils";

const SelectionExtras = ({
  obj,
  scale,
  canInteractWithHandles,
  onResizeHandleMouseDown,
}) => {
  const handles = [];
  const dimensionTexts = [];

  // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–º–æ–≥–∞–µ—Ç —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–∏–∑—É–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
  // –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –º–∞—Å—à—Ç–∞–±–∞. –ö–æ–≥–¥–∞ scale —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è (–ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ),
  // 1 / (scale / INITIAL_PPM) —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è, –∫–æ–º–ø–µ–Ω—Å–∏—Ä—É—è —É–≤–µ–ª–∏—á–µ–Ω–∏–µ scale.
  const uiScaleFactor = INITIAL_PPM / scale;

  const OBBHandlesDef = [
    { type: "tl", x: 0, y: 0 },
    { type: "t", x: obj.width / 2, y: 0 },
    { type: "tr", x: obj.width, y: 0 },
    { type: "l", x: 0, y: obj.height / 2 },
    { type: "r", x: obj.width, y: obj.height / 2 },
    { type: "bl", x: 0, y: obj.height },
    { type: "b", x: obj.width / 2, y: obj.height },
    { type: "br", x: obj.width, y: obj.height },
  ];

  const handleSizeBase = RESIZE_HANDLE_SIZE_PX; // –ë–∞–∑–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä –≤ –ø–∏–∫—Å–µ–ª—è—Ö
  // –†–∞–∑–º–µ—Ä –º–∞—Ä–∫–µ—Ä–∞ –≤ SVG –µ–¥–∏–Ω–∏—Ü–∞—Ö, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å –∫–∞–∫ handleSizeBase –ø–∏–∫—Å–µ–ª–µ–π –Ω–∞ —ç–∫—Ä–∞–Ω–µ
  const handleSizeSVG = Math.max(
    4 * uiScaleFactor,
    handleSizeBase * uiScaleFactor,
  );
  const handleStrokeWidthSVG = Math.max(
    0.2 * uiScaleFactor,
    0.5 * uiScaleFactor,
  );

  if (obj.type !== "module") {
    OBBHandlesDef.forEach((h) => {
      handles.push(
        <rect
          key={`handle-${h.type}`}
          data-resize-handle="true"
          // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –º–∞—Ä–∫–µ—Ä—ã –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö –æ–±—ä–µ–∫—Ç–∞ (–∫–æ—Ç–æ—Ä—ã–µ —É–∂–µ —É–º–Ω–æ–∂–µ–Ω—ã –Ω–∞ scale)
          // –∞ –∏—Ö —Ä–∞–∑–º–µ—Ä –∑–∞–¥–∞–µ–º –≤ SVG –µ–¥–∏–Ω–∏—Ü–∞—Ö, –∫–æ—Ç–æ—Ä—ã–µ –∫–æ–º–ø–µ–Ω—Å–∏—Ä—É—é—Ç scale
          x={h.x * scale - handleSizeSVG / 2}
          y={h.y * scale - handleSizeSVG / 2}
          width={handleSizeSVG}
          height={handleSizeSVG}
          fill={RESIZE_HANDLE_COLOR}
          stroke="white"
          strokeWidth={handleStrokeWidthSVG}
          style={{
            cursor: canInteractWithHandles
              ? getResizeCursorForHandle(h.type, obj.rotation || 0)
              : "default",
          }}
          onMouseDown={(e) => {
            if (canInteractWithHandles)
              onResizeHandleMouseDown(e, obj.id, h.type);
            else e.stopPropagation();
          }}
        />,
      );
    });
  }

  const midPointXObjScaled = (obj.width / 2) * scale; // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ –æ–±—ä–µ–∫—Ç–∞ –≤ —ç–∫—Ä–∞–Ω–Ω—ã—Ö SVG –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö (–æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –≥—Ä—É–ø–ø—ã –æ–±—ä–µ–∫—Ç–∞)
  const midPointYObjScaled = (obj.height / 2) * scale;

  const textOffsetBase = 15; // –ë–∞–∑–æ–≤—ã–π –æ—Ç—Å—Ç—É–ø –≤ –ø–∏–∫—Å–µ–ª—è—Ö
  const textOffsetSVG = textOffsetBase * uiScaleFactor; // –û—Ç—Å—Ç—É–ø –≤ SVG –µ–¥–∏–Ω–∏—Ü–∞—Ö

  const fontSizeBase = 10; // –ë–∞–∑–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞ –≤ –ø–∏–∫—Å–µ–ª—è—Ö
  const fontSizeSVG = Math.max(6 * uiScaleFactor, fontSizeBase * uiScaleFactor); // –†–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞ –≤ SVG –µ–¥–∏–Ω–∏—Ü–∞—Ö

  const strokeBgWidthBase = 3; // –ë–∞–∑–æ–≤–∞—è —Ç–æ–ª—â–∏–Ω–∞ –æ–±–≤–æ–¥–∫–∏ —Ñ–æ–Ω–∞
  const strokeBgWidthSVG = Math.max(
    1 * uiScaleFactor,
    strokeBgWidthBase * uiScaleFactor,
  );

  // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ü–µ–Ω—Ç—Ä–∞ –æ–±—ä–µ–∫—Ç–∞, –Ω–æ —Å –æ—Ç—Å—Ç—É–ø–æ–º –≤ SVG –µ–¥–∏–Ω–∏—Ü–∞—Ö, –∫–æ–º–ø–µ–Ω—Å–∏—Ä—É—é—â–∏—Ö scale
  dimensionTexts.push(
    <text
      key="dim-width"
      x={midPointXObjScaled} // –¶–µ–Ω—Ç—Ä –ø–æ X –æ–±—ä–µ–∫—Ç–∞
      y={0 - textOffsetSVG} // –í—ã—à–µ –æ–±—ä–µ–∫—Ç–∞ —Å –æ—Ç—Å—Ç—É–ø–æ–º
      fontSize={`${fontSizeSVG}px`}
      textAnchor="middle"
      fill={DIMENSION_TEXT_COLOR}
      style={{
        paintOrder: "stroke",
        stroke: DIMENSION_TEXT_BG_COLOR,
        strokeWidth: `${strokeBgWidthSVG}px`,
        strokeLinejoin: "round",
        pointerEvents: "none",
      }}
    >
      {obj.width.toFixed(2)} –º
    </text>,
  );
  dimensionTexts.push(
    <text
      key="dim-height"
      x={0 - textOffsetSVG} // –õ–µ–≤–µ–µ –æ–±—ä–µ–∫—Ç–∞ —Å –æ—Ç—Å—Ç—É–ø–æ–º
      y={midPointYObjScaled} // –¶–µ–Ω—Ç—Ä –ø–æ Y –æ–±—ä–µ–∫—Ç–∞
      fontSize={`${fontSizeSVG}px`}
      textAnchor="middle"
      dominantBaseline="middle"
      transform={`rotate(-90, ${0 - textOffsetSVG}, ${midPointYObjScaled})`} // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –≤–æ–∫—Ä—É–≥ —Ç–æ—á–∫–∏ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
      fill={DIMENSION_TEXT_COLOR}
      style={{
        paintOrder: "stroke",
        stroke: DIMENSION_TEXT_BG_COLOR,
        strokeWidth: `${strokeBgWidthSVG}px`,
        strokeLinejoin: "round",
        pointerEvents: "none",
      }}
    >
      {obj.height.toFixed(2)} –º
    </text>,
  );

  return (
    <>
      {handles}
      {dimensionTexts}
    </>
  );
};

export default React.memo(SelectionExtras);


==== src\components\Configurator\canvas\SnapGuides.jsx ====
// src/components/Configurator/canvas/SnapGuides.jsx
import React from "react";
import { SNAP_LINE_COLOR, INITIAL_PPM } from "../configuratorConstants";

const SnapGuides = ({ activeSnapLines, viewTransform }) => {
  if (!activeSnapLines || activeSnapLines.length === 0) {
    return null;
  }

  const { scale } = viewTransform;

  return (
    <g id="snap-guides">
      {activeSnapLines.map((line, index) => {
        // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —É–∂–µ –≤ –º–∏—Ä–æ–≤—ã—Ö –µ–¥–∏–Ω–∏—Ü–∞—Ö, –∏—Ö –Ω—É–∂–Ω–æ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞—Ç—å –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –≤ SVG
        // –Ω–æ –æ–Ω–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ viewTransform (—Ç.–µ. —É–∂–µ –≤ –≥—Ä—É–ø–ø–µ —Å translate)
        // –ø–æ—ç—Ç–æ–º—É –∑–¥–µ—Å—å –ø—Ä–æ—Å—Ç–æ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è
        const scaledVal = line.val * scale;
        const scaledStart = line.start * scale;
        const scaledEnd = line.end * scale;

        // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ–ª—â–∏–Ω—ã –∏ –ø—É–Ω–∫—Ç–∏—Ä–∞
        const strokeWidth = Math.max(1, 1 / (scale / INITIAL_PPM));
        const dashArray = `${3 / (scale / INITIAL_PPM)},${2 / (scale / INITIAL_PPM)}`;

        if (line.type === "x") {
          return (
            <line
              key={`snap-x-${index}`}
              x1={scaledVal} // –£–∂–µ –≤ "–æ—Ç—Ç—Ä–∞–Ω—Å–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö" –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö –≥—Ä—É–ø–ø—ã
              y1={scaledStart}
              x2={scaledVal}
              y2={scaledEnd}
              stroke={SNAP_LINE_COLOR}
              strokeWidth={strokeWidth}
              strokeDasharray={dashArray}
              pointerEvents="none" // –ù–µ –¥–æ–ª–∂–Ω—ã –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞—Ç—å —Å–æ–±—ã—Ç–∏—è –º—ã—à–∏
            />
          );
        } else {
          // line.type === 'y'
          return (
            <line
              key={`snap-y-${index}`}
              x1={scaledStart}
              y1={scaledVal}
              x2={scaledEnd}
              y2={scaledVal}
              stroke={SNAP_LINE_COLOR}
              strokeWidth={strokeWidth}
              strokeDasharray={dashArray}
              pointerEvents="none"
            />
          );
        }
      })}
    </g>
  );
};

export default React.memo(SnapGuides);


==== src\components\Configurator\canvas\SvgCanvas.jsx ====
// src/components/Configurator/canvas/SvgCanvas.jsx
import React, { useState, useEffect, useCallback } from "react"; // –î–æ–±–∞–≤–ª–µ–Ω useState, useEffect, useCallback
import Grid from "./Grid";
import ObjectRendererGroup from "./ObjectRendererGroup";
import SnapGuides from "./SnapGuides";
import MarqueeSelection from "./MarqueeSelection";

const SvgCanvas = ({
  svgRef,
  viewTransform,
  setViewTransform,
  objects,
  selectedObjectIds,
  lockedObjectIds,
  overlappingObjectIds,
  activeSnapLines,
  marqueeRect,
  modifierKeys,
  addingObjectType,
  isPanningWithSpace,
  draggingState,
  resizingState,
  handleMouseMove,
  handleMouseUp,
  handleMouseLeave,
  handleMouseDownOnCanvas,
  handleMouseDownOnObject,
  handleMouseDownOnResizeHandle,
  onAddObject,
  onAddCorridor,
  addingCorridorMode,
}) => {
  const [svgDimensions, setSvgDimensions] = useState({ width: 0, height: 0 });

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤ SVG –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞ –∏–ª–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
  useEffect(() => {
    const currentSvg = svgRef.current;
    if (!currentSvg) return;

    const resizeObserver = new ResizeObserver((entries) => {
      for (let entry of entries) {
        const { width, height } = entry.contentRect;
        setSvgDimensions({ width, height });
      }
    });

    resizeObserver.observe(currentSvg);

    // –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ä–∞–∑–º–µ—Ä–æ–≤
    const rect = currentSvg.getBoundingClientRect();
    if (rect.width > 0 && rect.height > 0) {
      setSvgDimensions({ width: rect.width, height: rect.height });
    }

    return () => {
      resizeObserver.unobserve(currentSvg);
    };
  }, [svgRef]);

  const localHandleMouseMove = useCallback(
    (e) => {
      if (isPanningWithSpace && draggingState?.isPanning) {
        const dxScreen = e.clientX - draggingState.startScreenX;
        const dyScreen = e.clientY - draggingState.startScreenY;
        setViewTransform((prev) => ({
          ...prev,
          x: draggingState.initialViewX + dxScreen,
          y: draggingState.initialViewY + dyScreen,
        }));
      } else {
        handleMouseMove(e);
      }
    },
    [isPanningWithSpace, draggingState, setViewTransform, handleMouseMove],
  );

  return (
    <svg
      ref={svgRef}
      width="100%"
      height="100%"
      onMouseMove={localHandleMouseMove} // –ò—Å–ø–æ–ª—å–∑—É–µ–º localHandleMouseMove
      onMouseUp={handleMouseUp}
      onMouseLeave={handleMouseLeave}
      onMouseDown={handleMouseDownOnCanvas}
      className={`block bg-white ${
        addingObjectType
          ? "cursor-crosshair"
          : isPanningWithSpace
            ? "cursor-grabbing"
            : modifierKeys.spacebar
              ? "cursor-grab"
              : "cursor-default"
      }`}
    >
      {svgDimensions.width > 0 &&
        svgDimensions.height >
          0 /* –†–µ–Ω–¥–µ—Ä–∏–º Grid —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å —Ä–∞–∑–º–µ—Ä—ã */ && (
          <Grid
            viewTransform={viewTransform}
            svgWidth={svgDimensions.width}
            svgHeight={svgDimensions.height}
          />
        )}
      <g transform={`translate(${viewTransform.x}, ${viewTransform.y})`}>
        <ObjectRendererGroup
          objects={objects}
          viewTransform={viewTransform}
          selectedObjectIds={selectedObjectIds}
          lockedObjectIds={lockedObjectIds}
          overlappingObjectIds={overlappingObjectIds}
          modifierKeys={modifierKeys}
          handleMouseDownOnObject={handleMouseDownOnObject}
          handleMouseDownOnResizeHandle={handleMouseDownOnResizeHandle}
          draggingState={draggingState}
          resizingState={resizingState}
          onAddObject={onAddObject}
          onAddCorridor={onAddCorridor}
          addingCorridorMode={addingCorridorMode}
        />
        <SnapGuides
          activeSnapLines={activeSnapLines}
          viewTransform={viewTransform}
        />
      </g>
      <MarqueeSelection marqueeRect={marqueeRect} svgRef={svgRef} />
    </svg>
  );
};

export default SvgCanvas; // –ù–µ –æ–±–æ—Ä–∞—á–∏–≤–∞–µ–º –≤ React.memo, —Ç.–∫. –æ–Ω –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –º–Ω–æ–≥–æ –∫–æ–ª–±—ç–∫–æ–≤ –∏ —Å–æ—Å—Ç–æ—è–Ω–∏–π


==== src\components\Configurator\canvas\WindowVisual.jsx ====
import React from "react";
import { 
    ARCH_WINDOW_FRAME_STROKE, 
    ARCH_WINDOW_GLAZING_STROKE 
} from "../configuratorConstants";

const WindowVisual = ({ obj, scale, commonProps, isSelected }) => {
  const widthScaled = obj.width * scale;
  const heightScaled = obj.height * scale; // Wall thickness

  const frameStrokeWidth = isSelected ? 2 : 1;
  const glazingStrokeWidth = isSelected ? 1 : 0.5;

  // Determine number of glazing lines based on thickness
  const numGlazingLines = heightScaled > 10 ? 3 : 2; // Simple example threshold
  const glazingLines = [];
  if (numGlazingLines === 2) {
    const spacing = heightScaled / 3;
    glazingLines.push(
      <line key="glaze1" x1={0} y1={spacing} x2={widthScaled} y2={spacing} stroke={ARCH_WINDOW_GLAZING_STROKE} strokeWidth={glazingStrokeWidth} />,
      <line key="glaze2" x1={0} y1={heightScaled - spacing} x2={widthScaled} y2={heightScaled - spacing} stroke={ARCH_WINDOW_GLAZING_STROKE} strokeWidth={glazingStrokeWidth} />
    );
  } else { // 3 lines
     const spacing = heightScaled / 4;
     glazingLines.push(
       <line key="glaze1" x1={0} y1={spacing} x2={widthScaled} y2={spacing} stroke={ARCH_WINDOW_GLAZING_STROKE} strokeWidth={glazingStrokeWidth} />,
       <line key="glaze2" x1={0} y1={heightScaled / 2} x2={widthScaled} y2={heightScaled / 2} stroke={ARCH_WINDOW_GLAZING_STROKE} strokeWidth={glazingStrokeWidth} />,
       <line key="glaze3" x1={0} y1={heightScaled - spacing} x2={widthScaled} y2={heightScaled - spacing} stroke={ARCH_WINDOW_GLAZING_STROKE} strokeWidth={glazingStrokeWidth} />
     );
  }

  return (
    <>
      {/* Window Frame */}
      <rect
        x="0"
        y="0"
        width={widthScaled}
        height={heightScaled}
        fill="none" // No fill for window frame itself
        stroke={isSelected ? "blue" : ARCH_WINDOW_FRAME_STROKE}
        strokeWidth={frameStrokeWidth}
        // Use commonProps only for interaction styles/data if needed
        style={commonProps.style} 
        data-object-id={commonProps['data-object-id']} 
      />
      {/* Glazing Lines */}
      {glazingLines}
      {/* Optional Sill/Mullion line - can add if needed */}
       <line
         x1={widthScaled / 2}
         y1={0}
         x2={widthScaled / 2}
         y2={heightScaled}
         stroke={ARCH_WINDOW_FRAME_STROKE}
         strokeWidth={frameStrokeWidth * 0.6} // Thinner mullion
         opacity={0.8}
       />
    </>
  );
};

export default React.memo(WindowVisual);

==== src\components\Configurator\common\PropertyInput.jsx ====
// src/components/Configurator/common/PropertyInput.jsx
import React from "react";
import PropTypes from "prop-types";

const PropertyInput = ({
  label,
  type = "number",
  value,
  onChange,
  step = 0.01,
  children,
  disabled,
  ...props
}) => (
  <div className="mb-2">
    <label className="block text-xs text-gray-600 mb-1">{label}</label>
    {children || (
      <input
        type={type}
        value={value}
        onChange={onChange}
        step={step}
        className={`w-full p-1 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-blue-500 outline-none ${disabled ? "bg-gray-100 cursor-not-allowed" : ""}`}
        disabled={disabled}
        {...props}
      />
    )}
  </div>
);

PropertyInput.propTypes = {
  label: PropTypes.string.isRequired,
  type: PropTypes.string,
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
  onChange: PropTypes.func.isRequired,
  step: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  children: PropTypes.node,
  disabled: PropTypes.bool,
  min: PropTypes.string, // Added missing prop types
  max: PropTypes.string,
  title: PropTypes.string,
};

export default PropertyInput;


==== src\components\Configurator\Configurator.jsx ====
// src/components/Configurator/Configurator.jsx
import React, { useState, useEffect, useRef, useCallback } from "react";
import PropTypes from "prop-types";
import { MODES, DEFAULT_MODE } from "./appConstants";
import { OBJECT_TYPES_TO_ADD } from "./configuratorConstants";

import useConfiguratorState from "./hooks/useConfiguratorState";
import useObjectManagement from "./hooks/useObjectManagement";
import useViewTransform from "./hooks/useViewTransform";
import useModifierKeys from "./hooks/useModifierKeys";
import useMouseInteractions from "./hooks/useMouseInteractions";
import useKeyboardShortcuts from "./hooks/useKeyboardShortcuts";

import ConfiguratorToolbar from "./toolbar/ConfiguratorToolbar";
import SvgCanvas from "./canvas/SvgCanvas";
import PropertiesPanel from "./sidebar/PropertiesPanel";
import StatusBar from "./statusbar/StatusBar";

// Import mode components
import ModularMode from "./modes/ModularMode";
import FramelessMode from "./modes/FramelessMode";
import FrameMode from "./modes/FrameMode";

import { getInitialObjects } from "./hooks/useObjectManagement"; // –≠—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ, –µ—Å–ª–∏ getInitialObjects —Å—Ç–∞—Ç–∏—á–Ω–∞

const Configurator = ({
  activeMode: activeModeProp,
  setProjectInfoData: setProjectInfoDataProp,
  renderModeSpecificUI: renderModeSpecificUIProp,
}) => {
  const [activeModeInternal, setActiveModeInternal] = useState(
    activeModeProp !== undefined ? activeModeProp : DEFAULT_MODE
  );
  const setProjectInfoDataExt = setProjectInfoDataProp || (() => {});
  const renderModeSpecificUIExt = renderModeSpecificUIProp || (() => null);

  const svgRef = useRef(null);
  const mainContainerRef = useRef(null);

  // ---- Hooks ----
  // 1. useConfiguratorState –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–µ—Ä–≤—ã–º, —Ç–∞–∫ –∫–∞–∫ –æ–Ω –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç objectsRef
  const {
    objects,
    objectsRef, // –≠—Ç–æ—Ç objectsRef –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è –≤ useConfiguratorState
    setObjects,
    selectedObjectIds,
    setSelectedObjectIds,
    lockedObjectIds,
    setLockedObjectIds,
    history,
    setHistory,
    handleUndo,
    handleRedo,
    primarySelectedObject,
    copiedObjectsData,
    setCopiedObjectsData,
    overlappingObjectIds,
    setOverlappingObjectIds,
  } = useConfiguratorState(setProjectInfoDataExt, activeModeInternal);

  const modifierKeys = useModifierKeys(mainContainerRef, svgRef);

  // 2. useObjectManagement –∑–∞–≤–∏—Å–∏—Ç –æ—Ç setObjects –∏ objectsRef –∏–∑ useConfiguratorState
  const {
    addObject,
    updateObject,
    deleteObjectById,
    updateSelectedObjectProperty,
    addAndSelectObject,
    defaultObjectSizes,
  } = useObjectManagement(
    setObjects,
    selectedObjectIds,
    lockedObjectIds,
    modifierKeys,
    objectsRef // –ü–µ—Ä–µ–¥–∞–µ–º objectsRef –Ω–∞–ø—Ä—è–º—É—é. –ï–≥–æ .current –±—É–¥–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω—ã–º.
  );

  const { viewTransform, setViewTransform, screenToWorld, screenToWorldRect } =
    useViewTransform(svgRef);

  const [addingObjectType, setAddingObjectType] = useState(null);
  const [addingCorridorMode, setAddingCorridorMode] = useState(false);

  const mouseInteractions = useMouseInteractions({
    objectsRef, // –ü–µ—Ä–µ–¥–∞–µ–º objectsRef
    setObjects, // setObjects (—Å –ª–æ–≥–∏–∫–æ–π –∏—Å—Ç–æ—Ä–∏–∏)
    setObjectsState: setObjects, // –î–ª—è mouseMove, –≥–¥–µ –∏—Å—Ç–æ—Ä–∏—è –Ω–µ –Ω—É–∂–Ω–∞ –ø—Ä–∏ –∫–∞–∂–¥–æ–º —à–∞–≥–µ
    selectedObjectIds,
    setSelectedObjectIds,
    lockedObjectIds,
    setHistory,
    viewTransform,
    screenToWorld,
    screenToWorldRect,
    modifierKeys,
    addingObjectType,
    setAddingObjectType,
    addAndSelectObject,
    mainContainerRef,
    svgRef,
    setOverlappingObjectIdsProp: setOverlappingObjectIds,
    activeMode: activeModeInternal,
  });

  useKeyboardShortcuts({
    mainContainerRef,
    selectedObjectIds,
    setSelectedObjectIds,
    lockedObjectIds,
    setLockedObjectIds,
    objectsRef, // –ü–µ—Ä–µ–¥–∞–µ–º objectsRef
    setObjects,
    handleUndo,
    handleRedo,
    copiedObjectsData,
    setCopiedObjectsData,
    addingObjectType,
    setAddingObjectType,
    marqueeRectActive: mouseInteractions.marqueeRect.active,
    resizingStateActive: !!mouseInteractions.resizingState,
  });

  useEffect(() => {
    mainContainerRef.current?.focus();
  }, []);
  
  // –ï—Å–ª–∏ activeModeProp –º–µ–Ω—è–µ—Ç—Å—è –∏–∑–≤–Ω–µ, –æ–±–Ω–æ–≤–ª—è–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Å—Ç–µ–π—Ç
  useEffect(() => {
    if (activeModeProp !== undefined && activeModeProp !== activeModeInternal) {
        // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É —Å–º–µ–Ω—ã —Ä–µ–∂–∏–º–∞, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ
        // –ø–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º
        setActiveModeInternal(activeModeProp);
    }
  }, [activeModeProp, activeModeInternal]);


  const handleStartAddObject = useCallback(
    (type) => {
      setAddingObjectType(type);
      setSelectedObjectIds([]); 
    },
    [setSelectedObjectIds],
  );

  const handleDeleteSelectedObjectInPanel = useCallback(() => {
    if (
      primarySelectedObject &&
      (!lockedObjectIds.includes(primarySelectedObject.id) ||
        modifierKeys.shift)
    ) {
      deleteObjectById(primarySelectedObject.id);
      setSelectedObjectIds((ids) =>
        ids.filter((id) => id !== primarySelectedObject.id),
      );
    }
  }, [
    primarySelectedObject,
    lockedObjectIds,
    modifierKeys.shift,
    deleteObjectById,
    setSelectedObjectIds,
  ]);

  const handleAddCorridor = useCallback((corridorData) => {
    const blockSize = 1; 
    const corridorThickness = 0.2; 

    const isVertical = corridorData.orientation === 'vertical';
    let finalX, finalY, corridorWidth, corridorHeight;

    if (isVertical) {
      corridorWidth = corridorThickness;
      corridorHeight = blockSize;
      finalX = corridorData.x - corridorThickness / 2; 
      finalY = corridorData.y;
    } else { 
      corridorWidth = blockSize;
      corridorHeight = corridorThickness;
      finalX = corridorData.x;
      finalY = corridorData.y - corridorThickness / 2; 
    }

    addObject(
      'corridor',
      finalX,
      finalY,
      corridorWidth,
      corridorHeight,
      { 
        orientation: corridorData.orientation, 
        parentId: corridorData.parentId,
      }
    );
    setAddingCorridorMode(false);
  }, [addObject]);

  function getInitialObjectsForMode(mode) {
    if (mode === MODES.FRAMELESS) return getInitialObjects();
    return [];
  }

  const handleModeChange = useCallback((newMode) => {
    if (newMode === activeModeInternal) return;
    if (objects.length > 0) { // objects –∏–∑ useConfiguratorState
      const confirmed = window.confirm(
        "–ü—Ä–∏ —Å–º–µ–Ω–µ —Ä–µ–∂–∏–º–∞ –≤—Å–µ –Ω–µ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –±—É–¥—É—Ç –ø–æ—Ç–µ—Ä—è–Ω—ã. –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å?"
      );
      if (!confirmed) return;
    }
    setObjects(getInitialObjectsForMode(newMode));
    setSelectedObjectIds([]);
    setLockedObjectIds([]);
    setHistory({ undo: [], redo: [] }); 
    setAddingObjectType(null);
    setActiveModeInternal(newMode);
  }, [activeModeInternal, objects, setObjects, setSelectedObjectIds, setLockedObjectIds, setHistory]);

  const configuratorInterface = {
    addObject,
    updateObject,
    deleteObject: deleteObjectById,
    getObjects: () => objectsRef.current, // –ò—Å–ø–æ–ª—å–∑—É–µ–º objectsRef.current
    getSelectedObjectIds: () => selectedObjectIds,
    setSelectedObjectIds,
    screenToWorld,
    viewTransform,
    svgRef,
  };

  const renderModeComponent = () => {
    switch (activeModeInternal) {
      case MODES.MODULAR:
        return <ModularMode {...configuratorInterface} />;
      case MODES.FRAMELESS:
        return <FramelessMode {...configuratorInterface} />;
      case MODES.FRAMED:
        return <FrameMode {...configuratorInterface} />;
      default:
        return null;
    }
  };

  return (
    <div
      ref={mainContainerRef}
      className="w-full h-full flex flex-col select-none outline-none"
      tabIndex={0} 
    >
      <ConfiguratorToolbar
        activeModeName={activeModeInternal}
        addingObjectType={addingObjectType}
        onStartAddObject={handleStartAddObject}
        onModeChange={handleModeChange}
      />

      <div className="flex flex-grow overflow-hidden">
        <div className="flex-grow relative bg-gray-200">
          {false && activeModeInternal === 'modular' && primarySelectedObject && primarySelectedObject.type === 'module' && !addingCorridorMode && (
            <button
              className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-indigo-600 text-white px-4 py-2 rounded shadow z-30 hover:bg-indigo-700"
              onClick={() => setAddingCorridorMode(true)}
            >
              –î–æ–±–∞–≤–∏—Ç—å –∫–æ—Ä–∏–¥–æ—Ä
            </button>
          )}
          {addingCorridorMode && (
            <div className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-indigo-100 text-indigo-900 px-4 py-2 rounded shadow z-30">
              –ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ –ª–∏–Ω–∏–∏ –≤–Ω—É—Ç—Ä–∏ –º–æ–¥—É–ª—è –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –∫–æ—Ä–∏–¥–æ—Ä–∞
              <button
                className="ml-4 text-indigo-700 underline"
                onClick={() => setAddingCorridorMode(false)}
              >
                –û—Ç–º–µ–Ω–∞
              </button>
            </div>
          )}
          <SvgCanvas
            svgRef={svgRef}
            viewTransform={viewTransform}
            setViewTransform={setViewTransform} 
            objects={objects} // objects –∏–∑ useConfiguratorState
            selectedObjectIds={selectedObjectIds}
            lockedObjectIds={lockedObjectIds}
            overlappingObjectIds={overlappingObjectIds}
            activeSnapLines={mouseInteractions.activeSnapLines}
            marqueeRect={mouseInteractions.marqueeRect}
            modifierKeys={modifierKeys}
            addingObjectType={addingObjectType}
            isPanningWithSpace={mouseInteractions.isPanningWithSpace}
            draggingState={mouseInteractions.draggingState}
            resizingState={mouseInteractions.resizingState}
            handleMouseMove={mouseInteractions.handleMouseMove}
            handleMouseUp={mouseInteractions.handleMouseUp}
            handleMouseLeave={mouseInteractions.handleMouseLeave}
            handleMouseDownOnCanvas={mouseInteractions.handleMouseDownOnCanvas}
            handleMouseDownOnObject={mouseInteractions.handleMouseDownOnObject}
            handleMouseDownOnResizeHandle={
              mouseInteractions.handleMouseDownOnResizeHandle
            }
            onAddObject={addObject} // –∏–∑ useObjectManagement
            addingCorridorMode={addingCorridorMode}
            onAddCorridor={handleAddCorridor}
          />
          {addingObjectType && (
            <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-yellow-300 text-black px-3 py-1.5 rounded shadow-lg text-xs z-10 pointer-events-none">
              –ö–ª–∏–∫ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è "
              {
                OBJECT_TYPES_TO_ADD.find((o) => o.type === addingObjectType)
                  ?.label
              }
              ". ESC –¥–ª—è –æ—Ç–º–µ–Ω—ã.
            </div>
          )}
          {renderModeComponent()}
          {renderModeSpecificUIExt && (
            <div className="absolute top-2 left-2 p-0 z-20">
              {renderModeSpecificUIExt(configuratorInterface)}
            </div>
          )}
        </div>

        <PropertiesPanel
          primarySelectedObject={primarySelectedObject}
          selectedObjectIds={selectedObjectIds}
          lockedObjectIds={lockedObjectIds}
          modifierKeys={modifierKeys}
          updateSelectedObjectProperty={updateSelectedObjectProperty}
          deleteSelectedObject={handleDeleteSelectedObjectInPanel}
          activeMode={activeModeInternal}
        />
      </div>

      <StatusBar
        selectedObjectIds={selectedObjectIds}
        primarySelectedObject={primarySelectedObject}
        lockedObjectIds={lockedObjectIds}
        history={history}
      />
    </div>
  );
};

Configurator.propTypes = {
  activeMode: PropTypes.oneOf(Object.values(MODES)),
  setProjectInfoData: PropTypes.func,
  renderModeSpecificUI: PropTypes.func,
};

export default Configurator;

==== src\components\Configurator\configuratorConstants.js ====
// src/components/Configurator/configuratorConstants.js
import {
  DEFAULT_PANEL_WIDTH_M as APP_DEFAULT_PANEL_WIDTH_M,
  WALL_THICKNESS_M as APP_WALL_THICKNESS_M,
  DOOR_WIDTH_M as APP_DOOR_WIDTH_M,
  WINDOW_WIDTH_M as APP_WINDOW_WIDTH_M,
} from "./appConstants"; 

// --- Architectural Style Colors ---
const ARCH_WALL_FILL = "#4A5568"; // Dark Gray for wall fill
const ARCH_WALL_STROKE = "#2D3748"; // Very Dark Gray for wall stroke
const ARCH_DOOR_LEAF_FILL = "#E2E8F0"; // Light Gray for door leaf
const ARCH_DOOR_STROKE = "#4A5568"; // Mid Gray for door stroke/arc
const ARCH_WINDOW_FRAME_STROKE = "#4A5568"; // Mid Gray for window frame
const ARCH_WINDOW_GLAZING_STROKE = "#A0AEC0"; // Lighter Gray for glazing lines
const ARCH_FURNITURE_FILL_LIGHT = "#E2E8F0"; // Light Gray for furniture
const ARCH_FURNITURE_FILL_MID = "#CBD5E0"; // Mid Gray for furniture
const ARCH_FURNITURE_STROKE = "#4A5568"; // Mid Gray for furniture stroke
const ARCH_OUTLET_FILL = "#F7FAFC"; // Very Light Gray / Off-white for outlet
const ARCH_OUTLET_STROKE = "#718096"; // Gray stroke for outlet
const ARCH_HATCH_COLOR = "#CBD5E0"; // Floor hatching color
const ARCH_GRID_LINE = "#E2E8F0"; // Grid lines color
const ARCH_GRID_BOLD_LINE = "#CBD5E0"; // Bold grid lines color
const ARCH_CORRIDOR_STROKE = "#4A5568"; // Corridor line color

// --- Other Constants ---
export const PANEL_SIZE_M = APP_DEFAULT_PANEL_WIDTH_M;
export const INITIAL_PPM = 50;
export const GRID_LINE_COLOR = ARCH_GRID_LINE; // Use new arch color
export const GRID_BOLD_LINE_COLOR = ARCH_GRID_BOLD_LINE; // Use new arch color
export const ORIGIN_POINT_COLOR = "transparent";
export const SNAP_THRESHOLD_WORLD = 0.05;
export const SNAP_LINE_COLOR = "rgba(0, 150, 255, 0.6)"; // Keep selection/snap blueish
export const PASTE_OFFSET_M = 0.2;
export const MAX_HISTORY_SIZE = 50;
export const MARQUEE_FILL_COLOR = "rgba(0, 100, 255, 0.1)";
export const MARQUEE_STROKE_COLOR = "rgba(0, 100, 255, 0.5)";
export const MIN_DRAG_FOR_MARQUEE_PAN = 5;
export const RESIZE_HANDLE_SIZE_PX = 8;
export const RESIZE_HANDLE_COLOR = "rgba(0, 100, 255, 0.8)"; // Keep blue for UI feedback
export const DIMENSION_TEXT_COLOR = "#1A202C"; // Dark text
export const DIMENSION_TEXT_BG_COLOR = "rgba(255, 255, 255, 0.8)"; // Semi-transparent white bg
export const OVERLAP_HIGHLIGHT_COLOR = "rgba(255, 0, 0, 0.2)"; // Keep red for overlap warning
export const LOCKED_OBJECT_STROKE_COLOR = "orange"; // Keep orange for locked status
export const DOOR_LEAF_VISUAL_THICKNESS_M = 0.04; // Slightly thinner door leaf

// --- Object specific colors (Using Arch styles) ---
export const objectColors = {
  panel: ARCH_FURNITURE_FILL_MID, // Use a mid-gray for panels if needed
  window: ARCH_WINDOW_FRAME_STROKE, // Window frame color (fill is handled specially)
  door: ARCH_DOOR_LEAF_FILL, // Door leaf fill color
  outlet: ARCH_OUTLET_FILL, // Outlet fill color
  wall: ARCH_WALL_FILL, // Wall fill color
  default: "#A0AEC0", // Default fallback color (a gray)
  sofa: ARCH_FURNITURE_FILL_MID,
  table: ARCH_FURNITURE_FILL_LIGHT,
  cabinet: ARCH_FURNITURE_FILL_MID,
  toilet: ARCH_FURNITURE_FILL_LIGHT,
  bed: ARCH_FURNITURE_FILL_MID,
  corridor: ARCH_CORRIDOR_STROKE, // Corridor color (used for stroke maybe?)
};

// --- Default Object Sizes (No changes needed here based on style request) ---
export const defaultObjectSizes = {
  panel: { width: PANEL_SIZE_M, height: PANEL_SIZE_M },
  window: { width: APP_WINDOW_WIDTH_M, height: APP_WALL_THICKNESS_M },
  door: { width: APP_DOOR_WIDTH_M, height: APP_WALL_THICKNESS_M },
  outlet: { width: 0.1, height: 0.1 }, // Smaller outlet visual
  wall: { width: PANEL_SIZE_M, height: APP_WALL_THICKNESS_M },
  sofa: { width: 1.8, height: 0.8 },
  table: { width: 1.0, height: 0.5 },
  cabinet: { width: 0.8, height: 0.4 },
  toilet: { width: 0.4, height: 0.7 },
  bed: { width: 1.5, height: 2.0 },
  corridor: { width: 1.0, height: 0.15 }, // Default corridor size example
};

// --- Object Types to Add (No changes needed) ---
export const OBJECT_TYPES_TO_ADD = [
  { type: "wall", label: "–°—Ç–µ–Ω–∞" },
  { type: "panel", label: "–ü–∞–Ω–µ–ª—å" },
  { type: "window", label: "–û–∫–Ω–æ" },
  { type: "door", label: "–î–≤–µ—Ä—å" },
  { type: "outlet", label: "–†–æ–∑–µ—Ç–∫–∞" },
  { type: "sofa", label: "–î–∏–≤–∞–Ω" },
  { type: "table", label: "–°—Ç–æ–ª" },
  { type: "cabinet", label: "–®–∫–∞—Ñ" },
  { type: "bed", label: "–ö—Ä–æ–≤–∞—Ç—å" },
  { type: "toilet", label: "–¢—É–∞–ª–µ—Ç" },
];

// --- Export specific Arch colors if needed elsewhere ---
export {
    ARCH_WALL_FILL,
    ARCH_WALL_STROKE,
    ARCH_DOOR_LEAF_FILL,
    ARCH_DOOR_STROKE,
    ARCH_WINDOW_FRAME_STROKE,
    ARCH_WINDOW_GLAZING_STROKE,
    ARCH_FURNITURE_FILL_LIGHT,
    ARCH_FURNITURE_FILL_MID,
    ARCH_FURNITURE_STROKE,
    ARCH_OUTLET_FILL,
    ARCH_OUTLET_STROKE,
    ARCH_HATCH_COLOR,
    ARCH_CORRIDOR_STROKE
};

==== src\components\Configurator\configuratorUtils.js ====
// src/components/Configurator/configuratorUtils.js
import { DOOR_LEAF_VISUAL_THICKNESS_M } from "./configuratorConstants";

// ... (rotatePoint, getAABB, checkAABBIntersection, getResizeCursorForHandle - –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
export const rotatePoint = (point, angleRad, center) => {
  const s = Math.sin(angleRad);
  const c = Math.cos(angleRad);
  const px = point.x - center.x;
  const py = point.y - center.y;
  const xNew = px * c - py * s;
  const yNew = px * s + py * c;
  return { x: xNew + center.x, y: yNew + center.y };
};

export const getAABB = (obj) => {
  const { x, y, width, height, rotation = 0 } = obj;
  const angleRad = (rotation * Math.PI) / 180;
  const localCenterX = width / 2;
  const localCenterY = height / 2;
  const worldRotCenterX = x + localCenterX;
  const worldRotCenterY = y + localCenterY;
  const center = { x: worldRotCenterX, y: worldRotCenterY };
  const corners = [
    { x: x, y: y },
    { x: x + width, y: y },
    { x: x + width, y: y + height },
    { x: x, y: y + height },
  ];
  if (rotation === 0 || rotation % 360 === 0) {
    return {
      minX: x,
      minY: y,
      maxX: x + width,
      maxY: y + height,
      centerX: worldRotCenterX,
      centerY: worldRotCenterY,
    };
  }
  const rotatedCorners = corners.map((p) => rotatePoint(p, angleRad, center));
  const minX = Math.min(...rotatedCorners.map((p) => p.x));
  const minY = Math.min(...rotatedCorners.map((p) => p.y));
  const maxX = Math.max(...rotatedCorners.map((p) => p.x));
  const maxY = Math.max(...rotatedCorners.map((p) => p.y));
  return {
    minX,
    minY,
    maxX,
    maxY,
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2,
  };
};

export const checkAABBIntersection = (aabb1, aabb2) =>
  aabb1.minX < aabb2.maxX &&
  aabb1.maxX > aabb2.minX &&
  aabb1.minY < aabb2.maxY &&
  aabb1.maxY > aabb2.minY;

export const getResizeCursorForHandle = (handleType, rotationDeg) => {
  const angle = ((rotationDeg % 360) + 360) % 360;
  let cursor = "default";
  if (["tl", "br"].includes(handleType)) cursor = "nwse-resize";
  if (["tr", "bl"].includes(handleType)) cursor = "nesw-resize";
  if (["t", "b"].includes(handleType)) cursor = "ns-resize";
  if (["l", "r"].includes(handleType)) cursor = "ew-resize";
  const rotationSegment = Math.round(angle / 45) % 8;
  if (rotationSegment === 1 || rotationSegment === 2) {
    if (cursor === "ns-resize") cursor = "nesw-resize";
    else if (cursor === "ew-resize") cursor = "nwse-resize";
    else if (cursor === "nwse-resize") cursor = "ns-resize";
    else if (cursor === "nesw-resize") cursor = "ew-resize";
  } else if (rotationSegment === 3 || rotationSegment === 4) {
    if (cursor === "ns-resize") cursor = "ew-resize";
    else if (cursor === "ew-resize") cursor = "ns-resize";
    else if (cursor === "nwse-resize") cursor = "nesw-resize";
    else if (cursor === "nesw-resize") cursor = "nwse-resize";
  } else if (rotationSegment === 5 || rotationSegment === 6) {
    if (cursor === "ns-resize") cursor = "nesw-resize";
    else if (cursor === "ew-resize") cursor = "nwse-resize";
    else if (cursor === "nwse-resize") cursor = "ns-resize";
    else if (cursor === "nesw-resize") cursor = "ew-resize";
  } else if (rotationSegment === 7) {
    if (cursor === "ns-resize") cursor = "ew-resize";
    else if (cursor === "ew-resize") cursor = "ns-resize";
    else if (cursor === "nwse-resize") cursor = "nesw-resize";
    else if (cursor === "nesw-resize") cursor = "nwse-resize";
  }
  return cursor;
};


export const getDoorLeafCorners = (door, currentOpeningAngleDegrees) => {
    const {
        x: objX, y: objY, 
        width: frameWidth, 
        height: frameThickness, 
        rotation: objRotationDeg = 0, 
        hingeSide,
        openingDirection
    } = door;

    const leafVisualThickness = DOOR_LEAF_VISUAL_THICKNESS_M; 
    const doorLeafLength = frameWidth; 

    const objRotationRad = objRotationDeg * (Math.PI / 180);

    let hingeLocalX = (hingeSide === 'left') ? 0 : frameWidth;
    let hingeLocalY = frameThickness / 2; 

    const leafCornersRelativeToHingeClosed = [
        { x: 0,                               y: -leafVisualThickness / 2 },
        { x: (hingeSide === 'left' ? doorLeafLength : -doorLeafLength), y: -leafVisualThickness / 2 },
        { x: (hingeSide === 'left' ? doorLeafLength : -doorLeafLength), y:  leafVisualThickness / 2 },
        { x: 0,                               y:  leafVisualThickness / 2 },
    ];

    let swingAngleRad = 0;
    if (currentOpeningAngleDegrees !== 0) {
        let angle = currentOpeningAngleDegrees;
        if (openingDirection === 'outward') angle *= -1;
        swingAngleRad = (hingeSide === 'left' ? angle : -angle) * (Math.PI / 180);
    }

    const cornersAfterSwing = leafCornersRelativeToHingeClosed.map(p =>
        rotatePoint(p, swingAngleRad, { x: 0, y: 0 })
    );

    const cornersInFrameLocalSpace = cornersAfterSwing.map(p => ({
        x: p.x + hingeLocalX,
        y: p.y + hingeLocalY,
    }));

    const frameRotCenterX = frameWidth / 2;
    const frameRotCenterY = frameThickness / 2;
    const cornersAfterFrameRotation = cornersInFrameLocalSpace.map(p =>
        rotatePoint(p, objRotationRad, { x: frameRotCenterX, y: frameRotCenterY })
    );

    const worldCorners = cornersAfterFrameRotation.map(p => ({
        x: p.x + objX,
        y: p.y + objY,
    }));

    return worldCorners;
};

export const getAABBFromCorners = (corners) => {
    if (!corners || corners.length < 2) return { minX: 0, minY: 0, maxX: 0, maxY: 0, centerX:0, centerY:0 };
    const minX = Math.min(...corners.map(p => p.x));
    const minY = Math.min(...corners.map(p => p.y));
    const maxX = Math.max(...corners.map(p => p.x));
    const maxY = Math.max(...corners.map(p => p.y));
    return { minX, minY, maxX, maxY, centerX: (minX + maxX) / 2, centerY: (minY + maxY) / 2 };
};

export const isDoorLeafColliding = (doorObj, openingAngleDegrees, allOtherObjects) => {
    if (openingAngleDegrees === 0) return false; 

    const doorLeafWorldCorners = getDoorLeafCorners(doorObj, openingAngleDegrees);
    const doorLeafAABB = getAABBFromCorners(doorLeafWorldCorners);

    for (const otherObj of allOtherObjects) {
        if (otherObj.id === doorObj.id) continue; // Don't collide with its own frame 
        
        // --- –î–û–ë–ê–í–õ–ï–ù–ê –ü–†–û–í–ï–†–ö–ê ---
        // –ï—Å–ª–∏ —É –¥–≤–µ—Ä–∏ –µ—Å—Ç—å parentId (—Ç.–µ. –æ–Ω–∞ –ø—Ä–∏–∫—Ä–µ–ø–ª–µ–Ω–∞ –∫ –º–æ–¥—É–ª—é)
        // –∏ ID –¥—Ä—É–≥–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å parentId –¥–≤–µ—Ä–∏,
        // —Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å —ç—Ç–∏–º —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–º –º–æ–¥—É–ª–µ–º.
        if (doorObj.parentId && otherObj.id === doorObj.parentId) {
            continue; 
        }
        // --- –ö–û–ù–ï–¶ –î–û–ë–ê–í–õ–ï–ù–ù–û–ô –ü–†–û–í–ï–†–ö–ò ---

        const otherAABB = getAABB(otherObj); 
        
        if (checkAABBIntersection(doorLeafAABB, otherAABB)) {
            // AABB check passed, now potentially more precise checks

            // Handle door-door leaf collision
            if (otherObj.type === 'door' && otherObj.isOpen && otherObj.openingAngle > 0) {
                const otherDoorLeafCorners = getDoorLeafCorners(otherObj, otherObj.openingAngle);
                const otherDoorLeafAABB = getAABBFromCorners(otherDoorLeafCorners);
                if (checkAABBIntersection(doorLeafAABB, otherDoorLeafAABB)) {
                    // More precise check would go here (e.g., SAT)
                    console.warn(`[Collision] Door ${doorObj.id} leaf vs Door ${otherObj.id} leaf`);
                    return true; // Leaf-to-leaf collision detected by AABB for now
                }
                // Leaves don't collide based on AABB, but we already know this door's leaf AABB
                // intersects the other door's overall AABB (frame+leaf), so return true.
                // Or should we only return true on leaf-leaf? Let's stick to AABB vs AABB for now.
                 console.warn(`[Collision] Door ${doorObj.id} leaf (angle ${openingAngleDegrees}) vs ${otherObj.type} ${otherObj.id} (Frame AABB)`);
                 return true; // Collision with the other door object's bounding box
            } else {
                // Collision with a non-door or a closed door object
                 console.warn(`[Collision] Door ${doorObj.id} leaf (angle ${openingAngleDegrees}) vs ${otherObj.type} ${otherObj.id}`);
                 return true; // AABB collision is sufficient for now
            }
        }
    }
    return false; // No collisions detected
};

==== src\components\Configurator\ElementRenderer.jsx ====
// components/Configurator/ElementRenderer.jsx
import React from 'react';
import PropTypes from 'prop-types'; // –î–æ–±–∞–≤–∏–º PropTypes –¥–ª—è –ª—É—á—à–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
import {
    RENDER_SCALE,
    DOOR_LEAF_THICKNESS_PX,
    DOOR_HANDLE_SIZE_PX,
    DOOR_HANDLE_OFFSET_FROM_EDGE_PX,
} from './constants'; // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è, —á—Ç–æ appConstants.js –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω –≤ constants.js –∏–ª–∏ –Ω–∞–æ–±–æ—Ä–æ—Ç

const ElementRenderer = ({ element, wallThicknessPx, isSelected, onClick }) => {
    const {
        id,
        type,
        position, // { x, y } - hinge position for doors, center for windows
        rotation, // degrees (0, 90, 180, -90) - overall rotation of the element
        width: elementWidthMm, // Specific width of the element in mm
        isOpen,
        openingSide, // 'left' or 'right'
        openingDirection, // 'inward' or 'outward'
        moduleId, // For data attributes
    } = element;

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Å–≤–æ–π—Å—Ç–≤
    if (!id || !type || !position || typeof position.x !== 'number' || typeof position.y !== 'number' || typeof rotation !== 'number' || typeof elementWidthMm !== 'number') {
        console.warn('[ElementRenderer] Missing or invalid core element properties:', element);
        return null;
    }
    
    const elementTypeNormalized = type.toLowerCase();
    const elementWidthPx = elementWidthMm * RENDER_SCALE;

    if (elementWidthPx <= 0) {
        console.warn('[ElementRenderer] Invalid elementWidthPx:', elementWidthPx, 'for element:', element);
        return null;
    }


    const groupTransform = `translate(${position.x.toFixed(3)}, ${position.y.toFixed(3)}) rotate(${rotation.toFixed(3)})`;

    const handleClick = (e) => {
        e.stopPropagation(); 
        if (onClick) {
            onClick(element, e); // –ü–µ—Ä–µ–¥–∞–µ–º —Å–∞–º —ç–ª–µ–º–µ–Ω—Ç –∏ —Å–æ–±—ã—Ç–∏–µ
        }
    };

    const gProps = {
        'data-module-id': moduleId,
        'data-element-id': id,
        'data-interactive': 'true',
        // className: `cursor-pointer element-group ${isSelected ? 'selected-element-highlight' : ''}`, // –ö–ª–∞—Å—Å –¥–ª—è —Å—Ç–∏–ª–∏–∑–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ CSS, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        style: { 
            cursor: onClick ? 'pointer' : 'default',
            outline: isSelected ? '1px dashed #007bff' : 'none', // –ü—Ä–∏–º–µ—Ä –ø–æ–¥—Å–≤–µ—Ç–∫–∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
            outlineOffset: '2px', // –û—Ç—Å—Ç—É–ø –¥–ª—è outline
        },
        onClick: handleClick,
        transform: groupTransform,
    };


    if (elementTypeNormalized.includes('drzwi')) {
        const doorLeafWidthPx = elementWidthPx;
        const doorLeafThicknessPx = DOOR_LEAF_THICKNESS_PX;

        let swingAngleDeg = 0; // –£–≥–æ–ª –ø–æ–≤–æ—Ä–æ—Ç–∞ –≤ –≥—Ä–∞–¥—É—Å–∞—Ö
        if (isOpen) {
            if (openingDirection === 'inward') {
                swingAngleDeg = (openingSide === 'left') ? 90 : -90;
            } else { // outward
                swingAngleDeg = (openingSide === 'left') ? -90 : 90;
            }
        }

        // –ü—É—Ç—å –¥–ª—è –¥–≤–µ—Ä–Ω–æ–≥–æ –ø–æ–ª–æ—Ç–Ω–∞. –ü–µ—Ç–ª—è –≤ –ª–æ–∫–∞–ª—å–Ω—ã—Ö (0,0).
        const leafPath = openingSide === 'left'
            ? `M 0 ${-doorLeafThicknessPx / 2} L ${doorLeafWidthPx} ${-doorLeafThicknessPx / 2} L ${doorLeafWidthPx} ${doorLeafThicknessPx / 2} L 0 ${doorLeafThicknessPx / 2} Z`
            : `M 0 ${-doorLeafThicknessPx / 2} L ${-doorLeafWidthPx} ${-doorLeafThicknessPx / 2} L ${-doorLeafWidthPx} ${doorLeafThicknessPx / 2} L 0 ${doorLeafThicknessPx / 2} Z`;
        
        // –ü–æ–∑–∏—Ü–∏—è —Ä—É—á–∫–∏ (–æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø–æ–ª–æ—Ç–Ω–∞, –¥–æ –µ–≥–æ –ø–æ–≤–æ—Ä–æ—Ç–∞)
        const handleOffsetFromEdge = DOOR_HANDLE_OFFSET_FROM_EDGE_PX; // –ë–æ–ª–µ–µ –ø–æ–Ω—è—Ç–Ω–æ–µ –∏–º—è
        const handleRadius = DOOR_HANDLE_SIZE_PX / 2;
        const handleCenterX = openingSide === 'left'
            ? doorLeafWidthPx - handleOffsetFromEdge - handleRadius
            : -doorLeafWidthPx + handleOffsetFromEdge + handleRadius;
        const handleCenterY = 0; 

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥—É–≥–∏ –æ—Ç–∫—Ä—ã–≤–∞–Ω–∏—è
        let arcPathD = "";
        if (isOpen) {
            const radius = doorLeafWidthPx;
            const startX = 0; // –ü–µ—Ç–ª—è
            const startY = 0;

            // –ö–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞ –¥—É–≥–∏
            const endX_arc = radius * Math.cos(swingAngleDeg * Math.PI / 180);
            const endY_arc = radius * Math.sin(swingAngleDeg * Math.PI / 180);
            
            // –§–ª–∞–≥–∏ –¥–ª—è SVG path arc
            // large-arc-flag –≤—Å–µ–≥–¥–∞ 0 –¥–ª—è <= 90 –≥—Ä–∞–¥—É—Å–æ–≤
            // sweep-flag: 0 = –ø—Ä–æ—Ç–∏–≤ —á–∞—Å–æ–≤–æ–π, 1 = –ø–æ —á–∞—Å–æ–≤–æ–π
            let sweepFlag;
            if (openingSide === 'left') {
                sweepFlag = (openingDirection === 'inward') ? 1 : 0; // Inward (+90 deg) -> clockwise, Outward (-90 deg) -> counter-clockwise
            } else { // openingSide === 'right'
                sweepFlag = (openingDirection === 'inward') ? 0 : 1; // Inward (-90 deg) -> counter-clockwise, Outward (+90 deg) -> clockwise
            }

            // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –ø—Ä—è–º–æ–π –ª–∏–Ω–∏–∏ –æ—Ç –ø–µ—Ç–ª–∏ –¥–æ –∫—Ä–∞—è –∑–∞–∫—Ä—ã—Ç–æ–π –¥–≤–µ—Ä–∏
            const lineToX = (openingSide === 'left') ? doorLeafWidthPx : -doorLeafWidthPx;

            arcPathD = `M ${startX} ${startY} L ${lineToX} ${startY} A ${radius} ${radius} 0 0 ${sweepFlag} ${endX_arc} ${endY_arc}`;
        }

        return (
            <g {...gProps}>
                {/* –î–≤–µ—Ä–Ω–æ–µ –ø–æ–ª–æ—Ç–Ω–æ - —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è –Ω–∞ swingAngleDeg */}
                <g transform={`rotate(${swingAngleDeg})`}>
                    <path
                        d={leafPath}
                        fill={isSelected ? "rgba(75, 125, 230, 0.5)" : "rgba(160, 120, 80, 0.6)"} 
                        stroke={isSelected ? "#3B82F6" : "#6D513D"}
                        strokeWidth="0.5" 
                    />
                    {/* –†—É—á–∫–∞ –¥–≤–µ—Ä–∏ - –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è –≤—Å–µ–≥–¥–∞, –≤—Ä–∞—â–∞–µ—Ç—Å—è —Å –ø–æ–ª–æ—Ç–Ω–æ–º */}
                    <circle
                        cx={handleCenterX}
                        cy={handleCenterY}
                        r={handleRadius}
                        fill={isOpen ? "#A0A0A0" : "#808080"} // –†–∞–∑–Ω—ã–π —Ü–≤–µ—Ç –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–æ–π/–∑–∞–∫—Ä—ã—Ç–æ–π
                        stroke="#505050"
                        strokeWidth="0.2"
                    />
                </g>
                {/* –î—É–≥–∞ –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –æ—Ç–∫—Ä—ã–≤–∞–Ω–∏—è (—Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –æ—Ç–∫—Ä—ã—Ç–∞) */}
                {isOpen && (
                    <path
                        d={arcPathD}
                        fill="none"
                        stroke={isSelected ? "#3B82F6" : "#A0A0A0"}
                        strokeWidth="0.3" 
                        strokeDasharray="1.5,1.5" 
                    />
                )}
            </g>
        );

    } else if (elementTypeNormalized.includes('okno')) {
        if (typeof wallThicknessPx !== 'number' || wallThicknessPx <= 0) {
            console.warn('[ElementRenderer] Invalid wallThicknessPx for window:', wallThicknessPx, 'for element:', element);
            return ( // –ú–æ–∂–Ω–æ –≤–µ—Ä–Ω—É—Ç—å –∑–∞–≥–ª—É—à–∫—É –∏–ª–∏ null
                <g {...gProps}>
                    <text x="0" y="0" fontSize="3" fill="red">Invalid Wall</text>
                </g>
            );
        }
        const windowDrawWidthPx = elementWidthPx; 
        
        return (
            <g {...gProps}>
                {/* –°—Ç–µ–∫–ª–æ –æ–∫–Ω–∞ */}
                <rect
                    x={-windowDrawWidthPx / 2}
                    y={-wallThicknessPx / 2}
                    width={windowDrawWidthPx}
                    height={wallThicknessPx}
                    fill={isSelected ? "rgba(135, 206, 250, 0.6)" : "rgba(173, 216, 230, 0.5)"} 
                    stroke={isSelected ? "#3B82F6" : "#708090"} 
                    strokeWidth="0.5" 
                />
                {/* –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è —Ä–∞–º—ã (–≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è) */}
                <line
                    x1="0" y1={-wallThicknessPx / 2}
                    x2="0" y2={wallThicknessPx / 2}
                    stroke={isSelected ? "#FFFFFF" : "#B0C4DE"} 
                    strokeWidth="0.3" 
                />
                 {/* –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è —Ä–∞–º—ã (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è) */}
                <line
                    x1={-windowDrawWidthPx / 2} y1="0"
                    x2={windowDrawWidthPx / 2} y2="0"
                    stroke={isSelected ? "#FFFFFF" : "#B0C4DE"} 
                    strokeWidth="0.3" 
                />
            </g>
        );
    }

    // console.warn(`ElementRenderer: Unsupported element type: ${type}`);
    return null; 
};

ElementRenderer.propTypes = {
    element: PropTypes.shape({
        id: PropTypes.string.isRequired,
        type: PropTypes.string.isRequired,
        position: PropTypes.shape({
            x: PropTypes.number.isRequired,
            y: PropTypes.number.isRequired,
        }).isRequired,
        rotation: PropTypes.number.isRequired,
        width: PropTypes.number.isRequired, // 'width' from element object is elementWidthMm
        isOpen: PropTypes.bool,
        openingSide: PropTypes.oneOf(['left', 'right']),
        openingDirection: PropTypes.oneOf(['inward', 'outward']),
        moduleId: PropTypes.string,
    }).isRequired,
    wallThicknessPx: PropTypes.number, // Required for windows
    isSelected: PropTypes.bool,
    onClick: PropTypes.func,
};

ElementRenderer.defaultProps = {
    isSelected: false,
    onClick: null,
    wallThicknessPx: 0, // Default to 0, but windows should have a valid one
};

export default ElementRenderer;

==== src\components\Configurator\HelpPanel.jsx ====
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { FaQuestionCircle, FaTimes } from 'react-icons/fa';

const HelpPanel = () => {
    const [isOpen, setIsOpen] = useState(false);

    const helpContent = {
        modular: [
            {
                title: '–°—Ç–≤–æ—Ä–µ–Ω–Ω—è –º–æ–¥—É–ª—è',
                content: '–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –Ω–∞ –∫–Ω–æ–ø–∫—É "–î–æ–¥–∞—Ç–∏ –º–æ–¥—É–ª—å" –∞–±–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—é –∫–ª–∞–≤—ñ—à Ctrl + M'
            },
            {
                title: '–ü–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è –º–æ–¥—É–ª—è',
                content: '–ü–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å –º–æ–¥—É–ª—å –∑–∞ –π–æ–≥–æ —Ü–µ–Ω—Ç—Ä –∞–±–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Å—Ç—Ä—ñ–ª–∫–∏ –Ω–∞ –∫–ª–∞–≤—ñ–∞—Ç—É—Ä—ñ'
            },
            {
                title: '–ó–º—ñ–Ω–∞ —Ä–æ–∑–º—ñ—Ä—É',
                content: '–ü–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å –∫—É—Ç–æ–≤–∏–π –º–∞—Ä–∫–µ—Ä –º–æ–¥—É–ª—è –¥–ª—è –∑–º—ñ–Ω–∏ –π–æ–≥–æ —Ä–æ–∑–º—ñ—Ä—É'
            },
            {
                title: '–ü–æ–≤–æ—Ä–æ—Ç –º–æ–¥—É–ª—è',
                content: '–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∫–Ω–æ–ø–∫—É –ø–æ–≤–æ—Ä–æ—Ç—É –∞–±–æ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—é –∫–ª–∞–≤—ñ—à Ctrl + R'
            }
        ],
        frame: [
            {
                title: '–°—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫–∞—Ä–∫–∞—Å—É',
                content: '–í–∏–±–µ—Ä—ñ—Ç—å —Ç–∏–ø –∫–∞—Ä–∫–∞—Å—É —Ç–∞ –≤–∫–∞–∂—ñ—Ç—å –π–æ–≥–æ —Ä–æ–∑–º—ñ—Ä–∏'
            },
            {
                title: '–î–æ–¥–∞–≤–∞–Ω–Ω—è –µ–ª–µ–º–µ–Ω—Ç—ñ–≤',
                content: '–ü–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å –µ–ª–µ–º–µ–Ω—Ç–∏ –∑ –ø–∞–Ω–µ–ª—ñ —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ñ–≤ –Ω–∞ –∫–∞—Ä–∫–∞—Å'
            }
        ],
        frameless: [
            {
                title: '–°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Å—Ç—ñ–Ω',
                content: '–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –Ω–∞ –∫–Ω–æ–ø–∫—É "–î–æ–¥–∞—Ç–∏ —Å—Ç—ñ–Ω—É" —Ç–∞ –≤–∫–∞–∂—ñ—Ç—å —ó—ó –ø–∞—Ä–∞–º–µ—Ç—Ä–∏'
            },
            {
                title: '–ó\'—î–¥–Ω–∞–Ω–Ω—è —Å—Ç—ñ–Ω',
                content: '–ü–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å –∫—ñ–Ω–µ—Ü—å —Å—Ç—ñ–Ω–∏ –¥–æ —ñ–Ω—à–æ—ó —Å—Ç—ñ–Ω–∏ –¥–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –∑\'—î–¥–Ω–∞–Ω–Ω—è'
            }
        ]
    };

    return (
        <>
            <button
                onClick={() => setIsOpen(true)}
                className="fixed bottom-4 left-4 p-3 bg-white rounded-full shadow-lg text-gray-600 hover:text-gray-900 transition-colors"
                title="–î–æ–≤—ñ–¥–∫–∞"
            >
                <FaQuestionCircle className="w-6 h-6" />
            </button>

            <AnimatePresence>
                {isOpen && (
                    <motion.div
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
                    >
                        <motion.div
                            initial={{ scale: 0.9, opacity: 0 }}
                            animate={{ scale: 1, opacity: 1 }}
                            exit={{ scale: 0.9, opacity: 0 }}
                            className="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto"
                        >
                            <div className="flex justify-between items-center mb-6">
                                <h2 className="text-2xl font-semibold text-gray-800">
                                    –î–æ–≤—ñ–¥–∫–∞
                                </h2>
                                <button
                                    onClick={() => setIsOpen(false)}
                                    className="p-2 text-gray-500 hover:text-gray-700 transition-colors"
                                >
                                    <FaTimes className="w-5 h-5" />
                                </button>
                            </div>

                            <div className="space-y-6">
                                {Object.entries(helpContent).map(([mode, tips]) => (
                                    <div key={mode} className="space-y-4">
                                        <h3 className="text-lg font-medium text-gray-800 capitalize">
                                            {mode === 'modular' ? '–ú–æ–¥—É–ª—å–Ω–∏–π —Ä–µ–∂–∏–º' :
                                             mode === 'frame' ? '–ö–∞—Ä–∫–∞—Å–Ω–∏–π —Ä–µ–∂–∏–º' :
                                             '–ë–µ–∑–∫–∞—Ä–∫–∞—Å–Ω–∏–π —Ä–µ–∂–∏–º'}
                                        </h3>
                                        <div className="space-y-3">
                                            {tips.map((tip, index) => (
                                                <div
                                                    key={index}
                                                    className="bg-gray-50 rounded-lg p-4"
                                                >
                                                    <h4 className="font-medium text-gray-800 mb-1">
                                                        {tip.title}
                                                    </h4>
                                                    <p className="text-gray-600">
                                                        {tip.content}
                                                    </p>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </motion.div>
                    </motion.div>
                )}
            </AnimatePresence>
        </>
    );
};

export default HelpPanel; 

==== src\components\Configurator\hooks\useConfiguratorState.js ====
// src/components/Configurator/hooks/useConfiguratorState.js
import { useState, useCallback, useRef, useEffect } from "react";
import { MAX_HISTORY_SIZE } from "../configuratorConstants";
import { getInitialObjects } from "./useObjectManagement";

const useConfiguratorState = (setProjectInfoDataProp, activeMode) => {
  const [objects, setObjectsState] = useState(() => {
    if (activeMode === 'modular') return [];
    if (activeMode === 'frameless') return getInitialObjects();
    // –î–ª—è –¥—Ä—É–≥–∏—Ö —Ä–µ–∂–∏–º–æ–≤ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø—É—Å—Ç–æ
    return [];
  });
  const [selectedObjectIds, setSelectedObjectIds] = useState([]);
  const [lockedObjectIds, setLockedObjectIds] = useState([]);
  const [history, setHistory] = useState({ undo: [], redo: [] });
  const [copiedObjectsData, setCopiedObjectsData] = useState(null); // For copy/paste
  const [overlappingObjectIds, setOverlappingObjectIds] = useState([]);

  const objectsRef = useRef(objects);
  useEffect(() => {
    objectsRef.current = objects;
  }, [objects]);

  const setProjectInfoData = setProjectInfoDataProp || (() => {});

  const setObjects = useCallback(
    (newObjectsOrCallback, saveToHistory = false) => {
      const objectsBeforeUpdate = objectsRef.current;
      setObjectsState((prevState) => {
        const newState =
          typeof newObjectsOrCallback === "function"
            ? newObjectsOrCallback(prevState)
            : newObjectsOrCallback;
        if (saveToHistory) {
          if (
            JSON.stringify(newState) !== JSON.stringify(objectsBeforeUpdate)
          ) {
            setHistory((prevHistory) => ({
              undo: [objectsBeforeUpdate, ...prevHistory.undo].slice(
                0,
                MAX_HISTORY_SIZE,
              ),
              redo: [],
            }));
          }
        }
        // Update project info data
        let totalArea = 0;
        newState.forEach((obj) => {
          if (
            obj &&
            typeof obj.width === "number" &&
            typeof obj.height === "number" &&
            (obj.type === "panel" ||
              obj.type === "wall" ||
              obj.type.match(/sofa|table|cabinet|toilet|bed/))
          ) {
            totalArea += obj.width * obj.height;
          }
        });
        setProjectInfoData((prev) => ({
          ...prev,
          area: totalArea,
          elements: [{ name: "Objects", count: newState.length }],
        }));
        return newState;
      });
    },
    [setProjectInfoData],
  );

  const handleUndo = useCallback(() => {
    setHistory((prevHistory) => {
      if (prevHistory.undo.length > 0) {
        const stateToRestore = prevHistory.undo[0];
        const remainingUndo = prevHistory.undo.slice(1);
        const currentStateForRedo = objectsRef.current; // Use ref for current state
        setObjectsState(stateToRestore); // Directly set state, history handled by setObjects
        setSelectedObjectIds([]); // Clear selection on undo
        return {
          undo: remainingUndo,
          redo: [currentStateForRedo, ...prevHistory.redo].slice(
            0,
            MAX_HISTORY_SIZE,
          ),
        };
      }
      return prevHistory;
    });
  }, []);

  const handleRedo = useCallback(() => {
    setHistory((prevHistory) => {
      if (prevHistory.redo.length > 0) {
        const [stateToRestore, ...remainingRedo] = prevHistory.redo;
        const currentStateForUndo = objectsRef.current; // Use ref for current state
        setObjectsState(stateToRestore); // Directly set state
        setSelectedObjectIds([]); // Clear selection on redo
        return {
          undo: [currentStateForUndo, ...prevHistory.undo].slice(
            0,
            MAX_HISTORY_SIZE,
          ),
          redo: remainingRedo,
        };
      }
      return prevHistory;
    });
  }, []);

  const primarySelectedObject =
    selectedObjectIds.length === 1
      ? objects.find((obj) => obj.id === selectedObjectIds[0])
      : null;

  return {
    objects,
    objectsRef,
    setObjects,
    selectedObjectIds,
    setSelectedObjectIds,
    lockedObjectIds,
    setLockedObjectIds,
    history,
    setHistory, // Expose for direct manipulation if needed (e.g. mouse up after drag)
    handleUndo,
    handleRedo,
    primarySelectedObject,
    copiedObjectsData,
    setCopiedObjectsData,
    overlappingObjectIds,
    setOverlappingObjectIds,
  };
};

export default useConfiguratorState;


==== src\components\Configurator\hooks\useKeyboardShortcuts.js ====
// src/components/Configurator/hooks/useKeyboardShortcuts.js
import { useEffect, useCallback } from "react";
import { PASTE_OFFSET_M } from "../configuratorConstants";
// createObject, getNextId needs to be accessible, e.g. from useObjectManagement context or passed in
// For simplicity here, assuming they are imported if static, or passed if instance-based.
import { createObject } from "./useObjectManagement";

const useKeyboardShortcuts = ({
  mainContainerRef,
  selectedObjectIds,
  setSelectedObjectIds,
  lockedObjectIds,
  setLockedObjectIds,
  objectsRef, // direct ref to current objects array
  setObjects, // state setter with history
  handleUndo,
  handleRedo,
  copiedObjectsData,
  setCopiedObjectsData,
  addingObjectType, // To cancel adding mode
  setAddingObjectType,
  marqueeRectActive, // To cancel marquee
  resizingStateActive, // To cancel resize
}) => {
  const deleteSelectedObjects = useCallback(() => {
    if (selectedObjectIds.length === 0) return;
    const deletableIds = selectedObjectIds.filter(
      (id) => !lockedObjectIds.includes(id),
    );
    if (deletableIds.length > 0) {
      setObjects(
        (prev) => prev.filter((obj) => !deletableIds.includes(obj.id)),
        true,
      );
      setSelectedObjectIds((prev) =>
        prev.filter(
          (id) => !deletableIds.includes(id) || lockedObjectIds.includes(id),
        ),
      );
    }
  }, [selectedObjectIds, lockedObjectIds, setObjects, setSelectedObjectIds]);

  const copySelectedObjects = useCallback(() => {
    if (selectedObjectIds.length > 0) {
      const selected = objectsRef.current.filter(
        (obj) =>
          selectedObjectIds.includes(obj.id) &&
          !lockedObjectIds.includes(obj.id),
      );
      if (selected.length > 0) {
        setCopiedObjectsData({
          objects: JSON.parse(JSON.stringify(selected)), // Deep copy
          pasteCount: 0,
        });
      }
    }
  }, [selectedObjectIds, objectsRef, lockedObjectIds, setCopiedObjectsData]);

  const pasteCopiedObjects = useCallback(() => {
    if (copiedObjectsData && copiedObjectsData.objects.length > 0) {
      const pasteCount = copiedObjectsData.pasteCount + 1;
      const newIds = [];
      const newObjects = copiedObjectsData.objects.map((objToPaste) => {
        const newObj = createObject(
          // Uses imported createObject which handles new IDs
          objToPaste.type,
          objToPaste.x + PASTE_OFFSET_M * pasteCount,
          objToPaste.y + PASTE_OFFSET_M * pasteCount,
          objToPaste.width,
          objToPaste.height,
          {
            ...objToPaste,
            id: undefined,
            label: objToPaste.label ? `${objToPaste.label} (copy)` : "",
          }, // Exclude ID to get new one
        );
        newIds.push(newObj.id);
        return newObj;
      });
      setObjects((prev) => [...prev, ...newObjects], true);
      setSelectedObjectIds(newIds);
      setCopiedObjectsData((prev) => ({ ...prev, pasteCount }));
    }
  }, [
    copiedObjectsData,
    setCopiedObjectsData,
    setObjects,
    setSelectedObjectIds,
  ]);

  useEffect(() => {
    const mainEl = mainContainerRef.current;
    if (!mainEl) return;

    const handleKeyDown = (e) => {
      const isCtrlOrCmd = e.ctrlKey || e.metaKey;
      const activeEl = document.activeElement;
      const isInputFocused =
        activeEl && ["INPUT", "TEXTAREA", "SELECT"].includes(activeEl.tagName);

      if (isInputFocused) {
        // Allow native copy/paste/undo/redo in inputs
        if (
          isCtrlOrCmd &&
          ["c", "v", "x", "z", "y"].includes(e.key.toLowerCase())
        )
          return;
        if (e.key === "Escape") {
          setAddingObjectType(null); // Also cancel add mode if input focused
          if (activeEl instanceof HTMLElement) activeEl.blur();
          return;
        }
        // Allow delete/backspace in inputs
        if (e.key === "Delete" || e.key === "Backspace") return;
      }

      // Global shortcuts (if not in input or specific keys)
      if (isCtrlOrCmd && e.key.toLowerCase() === "z" && !e.shiftKey) {
        e.preventDefault();
        handleUndo();
      } else if (
        (isCtrlOrCmd && e.key.toLowerCase() === "y") ||
        (isCtrlOrCmd && e.shiftKey && e.key.toLowerCase() === "z")
      ) {
        e.preventDefault();
        handleRedo();
      } else if (
        isCtrlOrCmd &&
        e.key.toLowerCase() === "c" &&
        !isInputFocused
      ) {
        e.preventDefault();
        copySelectedObjects();
      } else if (
        isCtrlOrCmd &&
        e.key.toLowerCase() === "v" &&
        !isInputFocused
      ) {
        e.preventDefault();
        pasteCopiedObjects();
      } else if (
        (e.key === "Delete" || e.key === "Backspace") &&
        selectedObjectIds.length > 0 &&
        !isInputFocused
      ) {
        e.preventDefault();
        deleteSelectedObjects();
      } else if (e.key === "Escape") {
        e.preventDefault();
        if (addingObjectType) setAddingObjectType(null);
        else if (marqueeRectActive || resizingStateActive) {
          /* Handled by mouse up/leave */
        } else if (selectedObjectIds.length > 0) setSelectedObjectIds([]);
        else mainContainerRef.current?.focus(); // Refocus main if nothing else to cancel
      } else if (e.key.toLowerCase() === "l" && !isInputFocused) {
        e.preventDefault();
        if (selectedObjectIds.length > 0) {
          setLockedObjectIds((prevLockedIds) => {
            const newLockedIds = new Set(prevLockedIds);
            selectedObjectIds.forEach((id) => {
              newLockedIds.has(id)
                ? newLockedIds.delete(id)
                : newLockedIds.add(id);
            });
            return Array.from(newLockedIds);
          });
        }
      }
    };
    mainEl.addEventListener("keydown", handleKeyDown);
    return () => {
      mainEl.removeEventListener("keydown", handleKeyDown);
    };
  }, [
    mainContainerRef,
    selectedObjectIds,
    setSelectedObjectIds,
    lockedObjectIds,
    setLockedObjectIds,
    handleUndo,
    handleRedo,
    copySelectedObjects,
    pasteCopiedObjects,
    deleteSelectedObjects,
    addingObjectType,
    setAddingObjectType,
    marqueeRectActive,
    resizingStateActive,
  ]);
};

export default useKeyboardShortcuts;


==== src\components\Configurator\hooks\useModifierKeys.js ====
// src/components/Configurator/hooks/useModifierKeys.js
import { useState, useEffect, useCallback } from "react";

const useModifierKeys = (mainContainerRef, svgRef) => {
  const [modifierKeys, setModifierKeys] = useState({
    ctrl: false,
    alt: false,
    meta: false,
    shift: false,
    spacebar: false,
  });

  const handleKeyDown = useCallback(
    (e) => {
      setModifierKeys((prev) => ({
        ...prev,
        ctrl: e.ctrlKey,
        alt: e.altKey,
        meta: e.metaKey,
        shift: e.shiftKey,
        spacebar: e.code === "Space" ? true : prev.spacebar,
      }));

      if (
        e.code === "Space" &&
        mainContainerRef.current &&
        svgRef.current &&
        (document.activeElement === mainContainerRef.current ||
          svgRef.current.contains(document.activeElement))
      ) {
        e.preventDefault();
      }
    },
    [mainContainerRef, svgRef],
  );

  const handleKeyUp = useCallback((e) => {
    setModifierKeys((prev) => ({
      ...prev,
      ctrl: e.ctrlKey,
      alt: e.altKey,
      meta: e.metaKey,
      shift: e.shiftKey,
      spacebar: e.code === "Space" ? false : prev.spacebar,
    }));
  }, []);

  useEffect(() => {
    const mainEl = mainContainerRef.current;
    if (!mainEl) return;

    mainEl.addEventListener("keydown", handleKeyDown);
    mainEl.addEventListener("keyup", handleKeyUp);

    // Also listen on window for keyup in case focus is lost
    window.addEventListener("keyup", handleKeyUp);

    return () => {
      mainEl.removeEventListener("keydown", handleKeyDown);
      mainEl.removeEventListener("keyup", handleKeyUp);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [mainContainerRef, handleKeyDown, handleKeyUp]);

  return modifierKeys;
};

export default useModifierKeys;


==== src\components\Configurator\hooks\useMouseInteractions.js ====
// src/components/Configurator/hooks/useMouseInteractions.js
import { useState, useCallback, useRef } from "react";
import { getAABB, checkAABBIntersection } from "../configuratorUtils";
import {
  PANEL_SIZE_M,
  SNAP_THRESHOLD_WORLD,
  MIN_DRAG_FOR_MARQUEE_PAN,
  MAX_HISTORY_SIZE,
} from "../configuratorConstants";

const useMouseInteractions = ({
  objectsRef,
  setObjects, // from useConfiguratorState
  setObjectsState, // direct setter from useConfiguratorState for non-history updates
  selectedObjectIds,
  setSelectedObjectIds,
  lockedObjectIds,
  setHistory,
  viewTransform,
  screenToWorld,
  screenToWorldRect,
  modifierKeys,
  addingObjectType,
  setAddingObjectType, // To reset after adding
  addAndSelectObject, // from useObjectManagement
  mainContainerRef,
  svgRef,
  setOverlappingObjectIdsProp, // Renamed to avoid conflict
  activeMode, // –Ω–æ–≤—ã–π –ø—Ä–æ–ø
}) => {
  const [draggingState, setDraggingState] = useState(null);
  const [resizingState, setResizingState] = useState(null);
  const [marqueeRect, setMarqueeRect] = useState({
    active: false,
    startScreenX: 0,
    startScreenY: 0,
    currentScreenX: 0,
    currentScreenY: 0,
  });
  const [isPanningWithSpace, setIsPanningWithSpace] = useState(false);
  const [activeSnapLines, setActiveSnapLines] = useState([]);
  const mouseDownStartPosRef = useRef(null); // Stores {x, y, shiftKeyAtStart}

  const checkAndSetOverlaps = useCallback(() => {
    const overlaps = new Set();
    const currentManipulatedIds = resizingState
      ? [resizingState.objectId]
      : draggingState?.initialPositions?.map((p) => p.id) || [];

    if (currentManipulatedIds.length > 0) {
      const activeObjects = objectsRef.current.filter((obj) =>
        currentManipulatedIds.includes(obj.id),
      );
      const staticObjects = objectsRef.current.filter(
        (obj) => !currentManipulatedIds.includes(obj.id),
      );
      activeObjects.forEach((activeObj) => {
        const activeAABB = getAABB(activeObj);
        staticObjects.forEach((staticObj) => {
          const staticAABB = getAABB(staticObj);
          if (checkAABBIntersection(activeAABB, staticAABB)) {
            overlaps.add(activeObj.id);
            overlaps.add(staticObj.id);
          }
        });
      });
    }
    setOverlappingObjectIdsProp(Array.from(overlaps));
  }, [resizingState, draggingState, objectsRef, setOverlappingObjectIdsProp]);

  const handleMouseDownOnObject = useCallback(
    (e, clickedObjectId) => {
      e.stopPropagation();
      if (addingObjectType) return;

      const objectIsLocked = lockedObjectIds.includes(clickedObjectId);
      if (objectIsLocked && !modifierKeys.shift) return;

      mainContainerRef.current?.focus();
      mouseDownStartPosRef.current = {
        x: e.clientX,
        y: e.clientY,
        shiftKeyAtStart: modifierKeys.shift,
      };

      const newSelectedIds = modifierKeys.shift
        ? selectedObjectIds.includes(clickedObjectId)
          ? selectedObjectIds.filter((id) => id !== clickedObjectId)
          : [...selectedObjectIds, clickedObjectId]
        : selectedObjectIds.includes(clickedObjectId) &&
            selectedObjectIds.length === 1
          ? selectedObjectIds
          : [clickedObjectId];
      setSelectedObjectIds(newSelectedIds);

      if (activeMode === 'modular') {
        setDraggingState(null); // –ó–∞–ø—Ä–µ—Ç–∏—Ç—å drag, –Ω–æ —Ä–∞–∑—Ä–µ—à–∏—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ
        return;
      }

      if (
        newSelectedIds.length > 0 &&
        (!objectIsLocked || modifierKeys.shift)
      ) {
        const initialPositions = objectsRef.current
          .filter((obj) => newSelectedIds.includes(obj.id))
          .map((obj) => ({
            id: obj.id,
            x: obj.x,
            y: obj.y,
            rotation: obj.rotation,
          }));
        setDraggingState({
          primaryDraggedObjectId: clickedObjectId,
          startScreenX: e.clientX,
          startScreenY: e.clientY,
          initialPositions: initialPositions,
          objectsBeforeOp: [...objectsRef.current], // For history
        });
      } else {
        setDraggingState(null);
      }
    },
    [
      addingObjectType,
      lockedObjectIds,
      modifierKeys.shift,
      selectedObjectIds,
      setSelectedObjectIds,
      objectsRef,
      mainContainerRef,
      activeMode,
    ],
  );

  const handleMouseDownOnResizeHandle = useCallback(
    (e, objectId, handleType) => {
      if (activeMode === 'modular') return; // –ó–∞–ø—Ä–µ—Ç–∏—Ç—å resize
      e.stopPropagation();
      const obj = objectsRef.current.find((o) => o.id === objectId);
      if (!obj) return;
      if (obj.type === "module") return;
      const objectIsLocked = lockedObjectIds.includes(objectId);
      if (objectIsLocked && !modifierKeys.shift) return;

      mainContainerRef.current?.focus();
      setResizingState({
        objectId,
        handleType,
        startScreenX: e.clientX,
        startScreenY: e.clientY,
        originalObject: { ...obj },
        objectsBeforeOp: [...objectsRef.current], // For history
      });
      setDraggingState(null); // Ensure no conflict with dragging
    },
    [lockedObjectIds, modifierKeys.shift, objectsRef, mainContainerRef, activeMode],
  );

  const handleMouseDownOnCanvas = useCallback(
    (e) => {
      mainContainerRef.current?.focus();
      if (e.button !== 0) return; // Only left click
      setActiveSnapLines([]);
      mouseDownStartPosRef.current = {
        x: e.clientX,
        y: e.clientY,
        shiftKeyAtStart: modifierKeys.shift,
      };

      if (addingObjectType) {
        const { x: worldX, y: worldY } = screenToWorld(e.clientX, e.clientY);
        const newId = addAndSelectObject(addingObjectType, worldX, worldY);
        setSelectedObjectIds([newId]);
        setAddingObjectType(null);
      } else if (modifierKeys.spacebar) {
        setIsPanningWithSpace(true);
        setDraggingState({
          // Re-using draggingState for panning info
          isPanning: true,
          startScreenX: e.clientX,
          startScreenY: e.clientY,
          initialViewX: viewTransform.x,
          initialViewY: viewTransform.y,
        });
      } else {
        setMarqueeRect({
          startScreenX: e.clientX,
          startScreenY: e.clientY,
          currentScreenX: e.clientX,
          currentScreenY: e.clientY,
          active: false, // Will be set to true on mousemove if drag exceeds threshold
        });
        if (!modifierKeys.shift) {
          setSelectedObjectIds([]);
        }
      }
    },
    [
      addingObjectType,
      setAddingObjectType,
      modifierKeys,
      screenToWorld,
      addAndSelectObject,
      setSelectedObjectIds,
      viewTransform.x,
      viewTransform.y,
      mainContainerRef,
    ],
  );

  const handleMouseMove = useCallback(
    (e) => {
      if (
        addingObjectType &&
        !draggingState?.primaryDraggedObjectId &&
        !resizingState
      )
        return;

      if (isPanningWithSpace && draggingState?.isPanning) {
        const dxScreen = e.clientX - draggingState.startScreenX;
        const dyScreen = e.clientY - draggingState.startScreenY;
        // This should call setViewTransform from useViewTransform hook,
        // but hooks cannot call other hooks' setters directly except via parent.
        // For now, this logic needs to be in Configurator.jsx or SvgCanvas.jsx
        // Or, viewTransform setter is passed to this hook. Let's assume it's handled by parent.
        // Here, we just update state for cursor or visual feedback if any.
        // Actual viewTransform update is in SvgCanvas or Configurator.
        // Let's pass setViewTransform to this hook for simplicity in this refactor.
        // No, that makes this hook too powerful. SvgCanvas should handle this.
        // This hook focuses on object interactions. Panning is a view interaction.
        // We'll leave the panning logic here and assume SvgCanvas calls setViewTransform.
        // The `draggingState` (for `isPanning`) is returned by this hook for SvgCanvas to use.
        return; // Panning logic will be in SvgCanvas based on draggingState.isPanning
      }

      // Marquee activation
      if (
        mouseDownStartPosRef.current &&
        !draggingState?.initialPositions &&
        !resizingState &&
        !addingObjectType &&
        !isPanningWithSpace
      ) {
        const dx = Math.abs(e.clientX - mouseDownStartPosRef.current.x);
        const dy = Math.abs(e.clientY - mouseDownStartPosRef.current.y);
        if (
          !marqueeRect.active &&
          (dx > MIN_DRAG_FOR_MARQUEE_PAN || dy > MIN_DRAG_FOR_MARQUEE_PAN)
        ) {
          setMarqueeRect((prev) => ({
            ...prev,
            startScreenX: mouseDownStartPosRef.current.x,
            startScreenY: mouseDownStartPosRef.current.y,
            currentScreenX: e.clientX,
            currentScreenY: e.clientY,
            active: true,
          }));
        } else if (marqueeRect.active) {
          setMarqueeRect((prev) => ({
            ...prev,
            currentScreenX: e.clientX,
            currentScreenY: e.clientY,
          }));
        }
      }

      // Resizing logic
      if (resizingState) {
        const {
          objectId,
          handleType,
          startScreenX,
          startScreenY,
          originalObject,
        } = resizingState;
        const obj = objectsRef.current.find((o) => o.id === objectId);
        if (obj && obj.type === "module") return;
        const scale = viewTransform.scale;
        const dxScreen = e.clientX - startScreenX;
        const dyScreen = e.clientY - startScreenY;
        let dxWorld = dxScreen / scale;
        let dyWorld = dyScreen / scale;

        // Simplified rotation logic from original for brevity, full logic would be complex.
        // Assume original logic for rotated resize is complex and needs careful porting.
        // This is a placeholder for the detailed resize math.
        let newX = originalObject.x;
        let newY = originalObject.y;
        let newWidth = originalObject.width;
        let newHeight = originalObject.height;

        if (
          originalObject.rotation === 0 ||
          originalObject.rotation % 360 === 0
        ) {
          if (handleType.includes("r")) newWidth += dxWorld;
          if (handleType.includes("l")) {
            newWidth -= dxWorld;
            newX = originalObject.x + dxWorld;
          }
          if (handleType.includes("b")) newHeight += dyWorld;
          if (handleType.includes("t")) {
            newHeight -= dyWorld;
            newY = originalObject.y + dyWorld;
          }
        } else {
          // Placeholder for rotated resize:
          // Needs to transform dxWorld, dyWorld into object's local coords
          const angleRad = (-originalObject.rotation * Math.PI) / 180;
          const cosA = Math.cos(angleRad);
          const sinA = Math.sin(angleRad);
          const localDx = dxWorld * cosA + dyWorld * sinA;
          const localDy = -dxWorld * sinA + dyWorld * cosA;

          if (handleType.includes("r")) newWidth += localDx;
          if (handleType.includes("l")) {
            newWidth -= localDx;
            // This part needs careful derivation for rotated object origin shift
            newX += dxWorld * cosA * cosA + dyWorld * sinA * cosA;
            newY += dxWorld * cosA * sinA + dyWorld * sinA * sinA;
          }
          if (handleType.includes("b")) newHeight += localDy;
          if (handleType.includes("t")) {
            newHeight -= localDy;
            newX += -dxWorld * sinA * cosA + dyWorld * cosA * cosA;
            newY += dxWorld * sinA * sinA + dyWorld * cosA * cosA;
          }
        }

        newWidth = Math.max(0.01, newWidth);
        newHeight = Math.max(0.01, newHeight);

        setObjectsState((prevObjs) =>
          prevObjs.map((obj) => {
            if (obj.id === objectId)
              return {
                ...obj,
                width: newWidth,
                height: newHeight,
                x: newX,
                y: newY,
              };
            return obj;
          }),
        );
        checkAndSetOverlaps();
        return;
      }

      // Dragging logic
      if (
        draggingState &&
        draggingState.initialPositions &&
        draggingState.initialPositions.length > 0
      ) {
        const currentSnapLines = [];
        const dxScreen = e.clientX - draggingState.startScreenX;
        const dyScreen = e.clientY - draggingState.startScreenY;
        let dxWorld = dxScreen / viewTransform.scale;
        let dyWorld = dyScreen / viewTransform.scale;
        let finalDx = dxWorld;
        let finalDy = dyWorld;

        // Snapping logic (simplified, full logic from original is extensive)
        if (modifierKeys.ctrl && draggingState.primaryDraggedObjectId) {
          // ... (Full snapping logic here) ...
        } else if (modifierKeys.alt && draggingState.primaryDraggedObjectId) {
          const pOI = draggingState.initialPositions.find(
            (p) => p.id === draggingState.primaryDraggedObjectId,
          );
          if (pOI) {
            const snappedPosX =
              Math.round((pOI.x + dxWorld) / PANEL_SIZE_M) * PANEL_SIZE_M;
            const snappedPosY =
              Math.round((pOI.y + dyWorld) / PANEL_SIZE_M) * PANEL_SIZE_M;
            finalDx = snappedPosX - pOI.x;
            finalDy = snappedPosY - pOI.y;
          }
        }

        setObjectsState((prevObjs) =>
          prevObjs.map((obj) => {
            const initialPos = draggingState.initialPositions.find(
              (p) => p.id === obj.id,
            );
            if (initialPos) {
              if (lockedObjectIds.includes(obj.id) && !modifierKeys.shift)
                return obj;
              return {
                ...obj,
                x: initialPos.x + finalDx,
                y: initialPos.y + finalDy,
              };
            }
            return obj;
          }),
        );
        setActiveSnapLines(currentSnapLines);
        checkAndSetOverlaps();
      } else {
        if (!marqueeRect.active) setActiveSnapLines([]);
      }
    },
    [
      addingObjectType,
      draggingState,
      resizingState,
      isPanningWithSpace,
      marqueeRect.active,
      viewTransform.scale,
      modifierKeys,
      selectedObjectIds,
      lockedObjectIds,
      checkAndSetOverlaps,
      PANEL_SIZE_M,
      setObjectsState, // Use direct setter for mouse move updates
      // SNAP_THRESHOLD_WORLD, getAABB, (needed for full snap logic)
    ],
  );

  const handleMouseUp = useCallback(
    (e) => {
      const currentMouseDownStartPos = mouseDownStartPosRef.current;
      let opMadeChange = false;
      let objectsBeforeCurrentOperation = null;

      if (draggingState && draggingState.objectsBeforeOp) {
        objectsBeforeCurrentOperation = draggingState.objectsBeforeOp;
        if (
          JSON.stringify(objectsBeforeCurrentOperation) !==
          JSON.stringify(objectsRef.current)
        ) {
          opMadeChange = true;
        }
      } else if (resizingState && resizingState.objectsBeforeOp) {
        objectsBeforeCurrentOperation = resizingState.objectsBeforeOp;
        if (
          JSON.stringify(objectsBeforeCurrentOperation) !==
          JSON.stringify(objectsRef.current)
        ) {
          opMadeChange = true;
        }
      }

      if (opMadeChange && objectsBeforeCurrentOperation) {
        setHistory((prevH) => ({
          undo: [objectsBeforeCurrentOperation, ...prevH.undo].slice(
            0,
            MAX_HISTORY_SIZE,
          ),
          redo: [],
        }));
      }

      if (isPanningWithSpace) setIsPanningWithSpace(false);

      if (marqueeRect.active) {
        const worldMarquee = screenToWorldRect(marqueeRect);
        const newlySelectedInMarquee = objectsRef.current
          .filter((obj) => {
            const objectIsLocked = lockedObjectIds.includes(obj.id);
            return (
              !objectIsLocked ||
              (objectIsLocked && currentMouseDownStartPos?.shiftKeyAtStart)
            );
          })
          .filter((obj) => checkAABBIntersection(getAABB(obj), worldMarquee))
          .map((obj) => obj.id);

        if (currentMouseDownStartPos?.shiftKeyAtStart) {
          setSelectedObjectIds((prevIds) =>
            Array.from(new Set([...prevIds, ...newlySelectedInMarquee])),
          );
        } else {
          setSelectedObjectIds(newlySelectedInMarquee);
        }
      } else if (
        !draggingState?.initialPositions &&
        !resizingState &&
        !modifierKeys.spacebar &&
        !addingObjectType &&
        currentMouseDownStartPos
      ) {
        // Click logic (not drag, not marquee)
        const downPos = currentMouseDownStartPos;
        const dx =
          e.clientX !== undefined ? Math.abs(e.clientX - downPos.x) : 0;
        const dy =
          e.clientY !== undefined ? Math.abs(e.clientY - downPos.y) : 0;

        if (dx < MIN_DRAG_FOR_MARQUEE_PAN && dy < MIN_DRAG_FOR_MARQUEE_PAN) {
          if (!downPos.shiftKeyAtStart && e.target) {
            const clickedElement =
              e.target instanceof Element ? e.target : null;
            const clickedOnObject =
              clickedElement && clickedElement.closest("[data-object-id]");
            const clickedOnResizeHandle =
              clickedElement && clickedElement.closest("[data-resize-handle]");
            const targetIsCanvasOrGrid =
              svgRef.current === e.target ||
              e.target.id === "grid" ||
              e.target.parentNode?.id === "grid";

            if (
              targetIsCanvasOrGrid &&
              !clickedOnObject &&
              !clickedOnResizeHandle
            ) {
              setSelectedObjectIds([]);
            }
          }
        }
      }

      setMarqueeRect((prev) => ({ ...prev, active: false }));
      setDraggingState(null);
      setResizingState(null);
      setActiveSnapLines([]);
      setOverlappingObjectIdsProp([]); // Reset overlaps
      mouseDownStartPosRef.current = null;
    },
    [
      isPanningWithSpace,
      marqueeRect,
      screenToWorldRect,
      draggingState,
      resizingState,
      modifierKeys.spacebar,
      addingObjectType,
      lockedObjectIds,
      objectsRef,
      setHistory,
      setSelectedObjectIds,
      setOverlappingObjectIdsProp,
      svgRef,
      // checkAABBIntersection, getAABB, MIN_DRAG_FOR_MARQUEE_PAN (needed for full logic)
    ],
  );

  const handleMouseLeave = useCallback(() => {
    if (isPanningWithSpace) setIsPanningWithSpace(false);
    if (marqueeRect.active)
      setMarqueeRect((prev) => ({ ...prev, active: false }));

    if (draggingState || resizingState) {
      // Simulate a mouse up to finalize any ongoing operation
      handleMouseUp({}); // Pass empty event, or undefined.
    }

    setActiveSnapLines([]);
    setOverlappingObjectIdsProp([]);
    if (!draggingState && !resizingState && !marqueeRect.active) {
      mouseDownStartPosRef.current = null;
    }
  }, [
    isPanningWithSpace,
    marqueeRect.active,
    draggingState,
    resizingState,
    handleMouseUp,
    setOverlappingObjectIdsProp,
  ]);

  return {
    draggingState,
    resizingState,
    marqueeRect,
    isPanningWithSpace, // For SvgCanvas to handle pan and cursor
    activeSnapLines,
    handleMouseDownOnObject,
    handleMouseDownOnResizeHandle,
    handleMouseDownOnCanvas,
    handleMouseMove,
    handleMouseUp,
    handleMouseLeave,
  };
};

export default useMouseInteractions;


==== src\components\Configurator\hooks\useObjectManagement.js ====
// src/components/Configurator/hooks/useObjectManagement.js
import { useCallback } from "react";
import {
  WALL_THICKNESS_M,
  DOOR_WIDTH_M as APP_DOOR_WIDTH_M,
  WINDOW_WIDTH_M as APP_WINDOW_WIDTH_M,
} from "../appConstants";
import { defaultObjectSizes } from "../configuratorConstants";
import {
    getAABB, 
    checkAABBIntersection, 
    getDoorLeafCorners,
    isDoorLeafColliding 
} from "../configuratorUtils"; 

let objectIdCounter = 0;
const getNextId = () => `obj-${objectIdCounter++}`;

export const createObject = (type, x, y, width, height, data = {}) => {
  const baseObj = {
    id: getNextId(),
    type,
    x,
    y,
    width,
    height,
    rotation: data.rotation || 0,
    label: data.label || "",
    ...data,
  };
  if (type === "door") {
    baseObj.isOpen = data.isOpen === undefined ? false : data.isOpen;
    baseObj.openingAngle =
      data.openingAngle === undefined ? 90 : data.openingAngle; 
    baseObj.hingeSide = data.hingeSide || "left";
    baseObj.openingDirection = data.openingDirection || "inward";
  }
  return baseObj;
};

export const getInitialObjects = () => {
  objectIdCounter = 0;
  const initialObjects = [];
  const WT = WALL_THICKNESS_M;

  const houseWidthOuter = 6;
  const houseDepthOuter = 3.5;

  initialObjects.push(
    createObject("wall", 0, 0, houseWidthOuter, WT, { label: "–í–µ—Ä—Ö–Ω—è—è —Å—Ç–µ–Ω–∞" }),
  );
  initialObjects.push(
    createObject("wall", 0, houseDepthOuter - WT, houseWidthOuter, WT, {
      label: "–ù–∏–∂–Ω—è—è —Å—Ç–µ–Ω–∞",
    }),
  );
  initialObjects.push(
    createObject("wall", 0, WT, WT, houseDepthOuter - 2 * WT, {
      label: "–õ–µ–≤–∞—è —Å—Ç–µ–Ω–∞",
    }),
  );
  initialObjects.push(
    createObject(
      "wall",
      houseWidthOuter - WT,
      WT,
      WT,
      houseDepthOuter - 2 * WT,
      { label: "–ü—Ä–∞–≤–∞—è —Å—Ç–µ–Ω–∞" },
    ),
  );

  const mainDoorWidth = APP_DOOR_WIDTH_M;
  initialObjects.push(
    createObject("door", 1.0, houseDepthOuter - WT, mainDoorWidth, WT, {
      hingeSide: "left",
      openingDirection: "inward",
      isOpen: false,
      openingAngle: 0, 
      label: "–í—Ö–æ–¥–Ω–∞—è –¥–≤–µ—Ä—å",
    }),
  );

  const mainWindowWidth = APP_WINDOW_WIDTH_M;
  initialObjects.push(
    createObject(
      "window",
      houseWidthOuter / 2 - mainWindowWidth / 2,
      0,
      mainWindowWidth,
      WT,
      { label: "–û–∫–Ω–æ –≥–æ—Å—Ç–∏–Ω–æ–π" },
    ),
  );

  const gap = 0.1;
  const sofaWidth = 1.8;
  const sofaDepth = 0.8;
  initialObjects.push(
    createObject("sofa", WT + gap, WT + gap, sofaWidth, sofaDepth, {
      label: "–î–∏–≤–∞–Ω",
    }),
  );
  const coffeeTableWidth = 1.0;
  const coffeeTableDepth = 0.5;
  initialObjects.push(
    createObject(
      "table",
      WT + gap + (sofaWidth - coffeeTableWidth) / 2,
      WT + gap + sofaDepth + 0.3,
      coffeeTableWidth,
      coffeeTableDepth,
      { label: "–ö–æ—Ñ–µ–π–Ω—ã–π —Å—Ç–æ–ª–∏–∫" },
    ),
  );

  const bedWidth = 1.5;
  const bedDepth = 2.0;
  const bedX = houseWidthOuter - WT - gap - bedWidth;
  const bedY = WT + gap;
  initialObjects.push(
    createObject("bed", bedX, bedY, bedWidth, bedDepth, { label: "–ö—Ä–æ–≤–∞—Ç—å" }),
  );
  const wardrobeWidth = 0.8;
  const wardrobeDepth = 0.5;
  initialObjects.push(
    createObject(
      "cabinet",
      bedX - gap - wardrobeWidth,
      bedY,
      wardrobeWidth,
      wardrobeDepth,
      { label: "–®–∫–∞—Ñ" },
    ),
  );

  const bathroomWidthInner = 1.5;
  const bathroomDepthInner = 1.8;
  const bathroomOuterWallX =
    houseWidthOuter - WT - gap - bathroomWidthInner - WT;
  const bathroomOuterWallY = WT + gap;
  initialObjects.push(
    createObject(
      "wall",
      bathroomOuterWallX,
      bathroomOuterWallY,
      bathroomWidthInner + WT,
      WT,
      { label: "–°—Ç–µ–Ω–∞ –≤–∞–Ω–Ω–æ–π (–≤–µ—Ä—Ö)" },
    ),
  );
  initialObjects.push(
    createObject(
      "wall",
      bathroomOuterWallX,
      bathroomOuterWallY + WT,
      WT,
      bathroomDepthInner,
      { label: "–°—Ç–µ–Ω–∞ –≤–∞–Ω–Ω–æ–π (–ª–µ–≤–æ)" },
    ),
  );
  const bathroomBottomWallDoorOpening = 0.75;
  const bathroomBottomWallSegment1Length =
    (bathroomWidthInner + WT - bathroomBottomWallDoorOpening) / 2;
  initialObjects.push(
    createObject(
      "wall",
      bathroomOuterWallX,
      bathroomOuterWallY + WT + bathroomDepthInner,
      bathroomBottomWallSegment1Length,
      WT,
      { label: "–°—Ç–µ–Ω–∞ –≤–∞–Ω–Ω–æ–π (–Ω–∏–∑1)" },
    ),
  );
  initialObjects.push(
    createObject(
      "wall",
      bathroomOuterWallX +
        bathroomBottomWallSegment1Length +
        bathroomBottomWallDoorOpening,
      bathroomOuterWallY + WT + bathroomDepthInner,
      bathroomBottomWallSegment1Length,
      WT,
      { label: "–°—Ç–µ–Ω–∞ –≤–∞–Ω–Ω–æ–π (–Ω–∏–∑2)" },
    ),
  );
  const bathroomDoorWidth = 0.7;
  initialObjects.push(
    createObject(
      "door",
      bathroomOuterWallX + bathroomBottomWallSegment1Length,
      bathroomOuterWallY + WT + bathroomDepthInner,
      bathroomDoorWidth,
      WT,
      {
        hingeSide: "right",
        openingDirection: "inward",
        isOpen: false,
        openingAngle: 0, 
        label: "–î–≤–µ—Ä—å –≤ –≤–∞–Ω–Ω—É—é",
      },
    ),
  );
  const toiletWidth = 0.4;
  const toiletDepth = 0.7;
  initialObjects.push(
    createObject(
      "toilet",
      bathroomOuterWallX + WT + gap,
      bathroomOuterWallY + WT + gap,
      toiletWidth,
      toiletDepth,
      { label: "–¢—É–∞–ª–µ—Ç" },
    ),
  );

  return initialObjects;
};


const useObjectManagement = (
  setObjects,
  selectedObjectIds,
  lockedObjectIds,
  modifierKeys,
  objectsRef // –ò—Å–ø–æ–ª—å–∑—É–µ–º objectsRef –Ω–∞–ø—Ä—è–º—É—é
) => {
  const addObject = useCallback(
    (type, x, y, width, height, data) => {
      const newObject = createObject(type, x, y, width, height, data);
      setObjects((prev) => [...prev, newObject], true);
      return newObject;
    },
    [setObjects],
  );

  const updateObject = useCallback(
    (id, updates) => {
      setObjects(
        (prev) =>
          prev.map((obj) => (obj.id === id ? { ...obj, ...updates } : obj)),
        true,
      );
    },
    [setObjects],
  );

  const deleteObjectById = useCallback(
    (id) => {
      setObjects((prev) =>
        prev.filter(
          (obj) => obj.id !== id && obj.parentId !== id
        ), true);
    },
    [setObjects],
  );

  const updateSelectedObjectProperty = useCallback(
    (property, value) => {
      if (selectedObjectIds.length !== 1) return;
      const targetId = selectedObjectIds[0];
      
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º objectsRef.current –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –∞–∫—Ç—É–∞–ª—å–Ω–æ–º—É –º–∞—Å—Å–∏–≤—É –æ–±—ä–µ–∫—Ç–æ–≤
      if (!objectsRef || !objectsRef.current) {
        console.error("useObjectManagement: objectsRef or objectsRef.current is undefined.");
        return;
      }
      const currentObjects = objectsRef.current; 

      const objToUpdate = currentObjects.find(obj => obj.id === targetId);

      if (!objToUpdate) return;

      const objectIsLocked = lockedObjectIds.includes(targetId);
      if (objectIsLocked && !modifierKeys.shift) {
        console.warn("Cannot modify locked object properties without Shift key.");
        return;
      }

      let parsedValue = value;
      if (typeof objToUpdate[property] === 'number' && property !== 'rotation') { 
          const numVal = parseFloat(value);
          if (isNaN(numVal)) {
              console.warn(`Invalid number format for ${property}: ${value}. Update cancelled.`);
              return;
          }
          parsedValue = numVal;
      } else if (typeof objToUpdate[property] === 'boolean') {
          parsedValue = typeof value === 'string' ? value.toLowerCase() === "true" : Boolean(value);
      }


      if (objToUpdate.type === "door" && (property === "isOpen" || property === "openingAngle")) {
        let newIsOpen = objToUpdate.isOpen;
        let newOpeningAngle = objToUpdate.openingAngle; 

        if (property === "isOpen") {
          newIsOpen = parsedValue;
          if (newIsOpen) { 
            newOpeningAngle = (objToUpdate.openingAngle > 0) ? objToUpdate.openingAngle : 90; 
          } else { 
            newOpeningAngle = 0;
          }
        } else { 
          newOpeningAngle = parsedValue;
          if (newOpeningAngle <= 0) {
            newIsOpen = false;
            newOpeningAngle = 0; 
          } else {
            newIsOpen = true;
          }
        }
        
        let finalAngle = newOpeningAngle;
        let finalIsOpen = newIsOpen;

        if (finalIsOpen && finalAngle > 0) {
          const MAX_DOOR_ANGLE = 170; 
          const MIN_DOOR_ANGLE_STEP = 1; 
          let targetAngle = Math.min(Math.max(finalAngle, 0), MAX_DOOR_ANGLE);
          
          let resolvedAngle = 0; 
          let canOpenAtAll = false;

          for (let angleCheck = targetAngle; angleCheck >= MIN_DOOR_ANGLE_STEP; angleCheck -= 1) { 
            if (!isDoorLeafColliding(objToUpdate, angleCheck, currentObjects)) {
              resolvedAngle = angleCheck;
              canOpenAtAll = true;
              break;
            }
          }
          
          if (canOpenAtAll) {
            finalAngle = resolvedAngle;
          } else { 
            console.warn(`Door ${targetId} cannot open to ${targetAngle}¬∞ due to collision. Keeping closed.`);
            finalAngle = 0;
            finalIsOpen = false;
          }
        } else { 
            finalAngle = 0;
            finalIsOpen = false;
        }
        
        setObjects(
          (prev) =>
            prev.map((obj) =>
              obj.id === targetId ? { ...obj, isOpen: finalIsOpen, openingAngle: finalAngle } : obj,
            ),
          true,
        );
        return; 
      }

      setObjects(
        (prev) =>
          prev.map((obj) =>
            obj.id === targetId ? { ...obj, [property]: parsedValue } : obj,
          ),
        true,
      );
    },
    [selectedObjectIds, objectsRef, lockedObjectIds, modifierKeys.shift, setObjects], // –î–æ–±–∞–≤–ª–µ–Ω objectsRef –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ useCallback
  );

  const addAndSelectObject = useCallback(
    (type, worldX, worldY) => {
      const defaultSize = defaultObjectSizes[type] || { width: 1, height: 1 };
      const newObject = createObject(
        type,
        worldX - defaultSize.width / 2,
        worldY - defaultSize.height / 2,
        defaultSize.width,
        defaultSize.height,
      );
      setObjects((prev) => [...prev, newObject], true);
      return newObject.id;
    },
    [setObjects],
  );

  return {
    createObject,
    getInitialObjects,
    addObject,
    updateObject,
    deleteObjectById,
    updateSelectedObjectProperty,
    addAndSelectObject,
    defaultObjectSizes,
  };
};

export default useObjectManagement;

==== src\components\Configurator\hooks\useViewTransform.js ====
// src/components/Configurator/hooks/useViewTransform.js
import { useState, useCallback, useEffect } from "react";
import { INITIAL_PPM } from "../configuratorConstants";

const useViewTransform = (svgRef) => {
  const [viewTransform, setViewTransform] = useState({
    x: 80,
    y: 60,
    scale: INITIAL_PPM * 0.6,
  });
  const [initialized, setInitialized] = useState(false);

  // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –º–∏—Ä –ø–æ —Ü–µ–Ω—Ç—Ä—É SVG –ø—Ä–∏ –ø–µ—Ä–≤–æ–º —Ä–µ–Ω–¥–µ—Ä–µ
  useEffect(() => {
    if (initialized) return;
    const svg = svgRef.current;
    if (svg) {
      const rect = svg.getBoundingClientRect();
      if (rect.width > 0 && rect.height > 0) {
        setViewTransform((prev) => ({
          ...prev,
          x: rect.width / 2,
          y: rect.height / 2,
        }));
        setInitialized(true);
      }
    }
  }, [svgRef, initialized]);

  const screenToWorld = useCallback(
    (screenX, screenY) => {
      if (!svgRef.current) return { x: 0, y: 0 };
      const svgRect = svgRef.current.getBoundingClientRect();
      return {
        x: (screenX - svgRect.left - viewTransform.x) / viewTransform.scale,
        y: (screenY - svgRect.top - viewTransform.y) / viewTransform.scale,
      };
    },
    [viewTransform, svgRef],
  );

  const screenToWorldRect = useCallback(
    (rect) => {
      const tl = screenToWorld(rect.startScreenX, rect.startScreenY);
      const br = screenToWorld(rect.currentScreenX, rect.currentScreenY);
      return {
        minX: Math.min(tl.x, br.x),
        minY: Math.min(tl.y, br.y),
        maxX: Math.max(tl.x, br.x),
        maxY: Math.max(tl.y, br.y),
      };
    },
    [screenToWorld],
  );

  useEffect(() => {
    const currentSvgElement = svgRef.current;
    if (!currentSvgElement) return;

    const wheelHandler = (e) => {
      e.preventDefault();
      const scaleAmount = 1.1;
      const newScaleFactor = e.deltaY > 0 ? 1 / scaleAmount : scaleAmount;

      const svgRect = currentSvgElement.getBoundingClientRect();
      const mouseX = e.clientX - svgRect.left;
      const mouseY = e.clientY - svgRect.top;

      setViewTransform((prevTransform) => {
        const worldBeforeZoomX =
          (mouseX - prevTransform.x) / prevTransform.scale;
        const worldBeforeZoomY =
          (mouseY - prevTransform.y) / prevTransform.scale;
        const newScale = prevTransform.scale * newScaleFactor;
        const newViewX = mouseX - worldBeforeZoomX * newScale;
        const newViewY = mouseY - worldBeforeZoomY * newScale;
        return { x: newViewX, y: newViewY, scale: newScale };
      });
    };

    currentSvgElement.addEventListener("wheel", wheelHandler, {
      passive: false,
    });
    return () => {
      currentSvgElement.removeEventListener("wheel", wheelHandler);
    };
  }, [svgRef]);

  return {
    viewTransform,
    setViewTransform,
    screenToWorld,
    screenToWorldRect,
  };
};

export default useViewTransform;


==== src\components\Configurator\modes\FramelessMode.jsx ====
import React from "react";
import PropTypes from 'prop-types';
import { FaCube, FaPlusSquare } from "react-icons/fa";
import { toast } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import { DEFAULT_PANEL_WIDTH_M } from '../appConstants';

// Constants for construction
const MODULE_WIDTH_METERS = 6;
const MODULE_DEPTH_METERS = 2.4;
const WALL_THICKNESS_M = 0.15;
const PANEL_SIZE_M = 1.15;

const FramelessMode = ({ 
  addObject, 
  getObjects,
  screenToWorld,
  viewTransform 
}) => {
  const handleAddModule = () => {
    if (!addObject) {
      toast.error("Add object function not available.");
      return;
    }

    // Attempt to place the new module not overlapping existing ones
    const existingObjects = getObjects ? getObjects() : [];
    let newX = 1; // Start at 1m
    let newY = 1; // Start at 1m

    if (existingObjects.length > 0) {
      const lastObject = existingObjects[existingObjects.length - 1];
      newX = lastObject.x + lastObject.width + 1; // Place 1m to the right of the last object
      newY = lastObject.y;
    }

    const moduleObj = addObject(
      "panel", // Or a new 'module' type if defined with special rendering
      newX,
      newY,
      MODULE_WIDTH_METERS,
      MODULE_DEPTH_METERS,
      { name: "Standard Module" },
    );
    if (moduleObj) {
      toast.success(`–ú–æ–¥—É–ª—å ${moduleObj.id} –¥–æ–±–∞–≤–ª–µ–Ω!`);
    }
  };

  const handleAddInternalWall = () => {
    if (!addObject) {
      toast.error("Add object function not available.");
      return;
    }

    const { x: worldMouseX, y: worldMouseY } = screenToWorld
      ? screenToWorld(window.innerWidth / 2, window.innerHeight / 2)
      : { x: 2, y: 2 };

    const wallObj = addObject(
      "wall", // Assuming 'wall' type has distinct rendering
      worldMouseX - PANEL_SIZE_M / 2, // Center the wall
      worldMouseY - WALL_THICKNESS_M / 2,
      PANEL_SIZE_M, // Wall length of one panel
      WALL_THICKNESS_M, // Wall thickness
      { name: "Internal Wall" },
    );
    if (wallObj) {
      toast.success(`–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Å—Ç–µ–Ω–∞ ${wallObj.id} –¥–æ–±–∞–≤–ª–µ–Ω–∞!`);
    }
  };

  return (
    <div className="bg-gray-100 p-2 rounded shadow-md">
      <h3 className="text-sm font-semibold mb-2 text-gray-700">
        –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
      </h3>
      <div className="flex flex-col space-y-2">
        <button
          onClick={handleAddModule}
          className="flex items-center justify-center px-3 py-1.5 bg-blue-500 text-white text-xs rounded hover:bg-blue-600 transition-colors"
          title="–î–æ–±–∞–≤–∏—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –º–æ–¥—É–ª—å (6x2.4–º)"
        >
          <FaCube className="mr-2" /> –î–æ–±–∞–≤–∏—Ç—å –ú–æ–¥—É–ª—å
        </button>
        <button
          onClick={handleAddInternalWall}
          className="flex items-center justify-center px-3 py-1.5 bg-green-500 text-white text-xs rounded hover:bg-green-600 transition-colors"
          title="–î–æ–±–∞–≤–∏—Ç—å –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é —Å—Ç–µ–Ω—É"
        >
          <FaPlusSquare className="mr-2" /> –î–æ–±–∞–≤–∏—Ç—å –°—Ç–µ–Ω—É
        </button>
      </div>
    </div>
  );
};

FramelessMode.propTypes = {
  addObject: PropTypes.func.isRequired,
  getObjects: PropTypes.func.isRequired,
  screenToWorld: PropTypes.func,
  viewTransform: PropTypes.object,
};

export default FramelessMode;


==== src\components\Configurator\modes\FrameMode.jsx ====
import React from "react";
import PropTypes from 'prop-types';

const FrameMode = ({ addObject, getObjects }) => {
  // Placeholder for Frame Mode
  // This will be implemented later
  return null;
};

FrameMode.propTypes = {
  addObject: PropTypes.func.isRequired,
  getObjects: PropTypes.func.isRequired,
};

export default FrameMode;


==== src\components\Configurator\modes\ModularMode.jsx ====
import React, { useState } from 'react';
import PropTypes from 'prop-types';
import { FaFilePdf } from "react-icons/fa";

// SVG-–∫–æ–º–ø–æ–Ω–µ–Ω—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
const PlatformVisual = ({ width = 6, height = 2, label = "–í—ã–±–µ—Ä–∏—Ç–µ –∏ –¥–æ–±–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä" }) => {
  const scale = 50;
  const w = width * scale;
  const h = height * scale;
  const pad = 8;
  return (
    <svg width={w} height={h} viewBox={`0 0 ${w} ${h}`} style={{ width: "100%", height: "100%" }}>
      <rect x={0} y={0} width={w} height={h} fill="#fff" stroke="#888" strokeWidth={2} />
      <pattern id="hatch-platform" width="8" height="8" patternTransform="rotate(45)" patternUnits="userSpaceOnUse">
        <line x1="0" y1="0" x2="0" y2="8" stroke="#bbb" strokeWidth="1" />
      </pattern>
      <rect x={pad} y={pad} width={w - 2 * pad} height={h - 2 * pad} fill="url(#hatch-platform)" opacity="0.12" />
      <text x={w / 2} y={h / 2} textAnchor="middle" fill="#444" fontSize={scale * 0.18} fontWeight="bold" dy={-scale * 0.1}>
        {label}
      </text>
    </svg>
  );
};

// SVG-–∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è –º–∏–Ω–∏–∞—Ç—é—Ä—ã –º–æ–¥—É–ª—è
const ModuleThumb = ({ width = 60, height = 32 }) => (
  <svg width={width} height={height} viewBox="0 0 60 32" fill="none">
    <rect x="1" y="1" width="58" height="30" rx="3" fill="#f3f4f6" stroke="#333" strokeWidth="2" />
    <rect x="6" y="6" width="15" height="8" fill="#ddd" stroke="#aaa" strokeWidth="1" />
    <rect x="40" y="18" width="10" height="6" fill="#ddd" stroke="#aaa" strokeWidth="1" />
    <rect x="25" y="12" width="10" height="8" fill="#eee" stroke="#bbb" strokeWidth="1" />
  </svg>
);

// –í—Å–µ —à–∞–±–ª–æ–Ω—ã –æ–¥–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ 6x2–º
const MODULE_TEMPLATES = [
  {
    code: 'DEFAULT',
    name: '–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –º–æ–¥—É–ª—å',
    type: 'module',
    width: 6,
    height: 2,
    config: {},
    thumb: <ModuleThumb />,
  }
];

// –§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–≤–æ–¥–∞ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤ —ç–∫—Ä–∞–Ω–Ω—ã–µ
function worldToScreen(x, y, viewTransform, svgRef) {
  if (!svgRef?.current) return { screenX: 0, screenY: 0 };
  // svgRef –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –¥–ª—è offset, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
  return {
    screenX: x * viewTransform.scale + viewTransform.x,
    screenY: y * viewTransform.scale + viewTransform.y,
  };
}

const ModularMode = ({
  addObject,
  getObjects,
  screenToWorld,
  viewTransform,
  svgRef,
}) => {
  const [showTemplates, setShowTemplates] = useState(false);

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ –º–æ–¥—É–ª—å (type: 'module')
  const hasModule = getObjects().some(obj => obj.type === 'module');

  // –¶–µ–Ω—Ç—Ä –±–ª–∏–∂–∞–π—à–µ–π –∫–ª–µ—Ç–∫–∏ —Å–µ—Ç–∫–∏ 1–º (–≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö)
  const gridSize = 1;
  const gridCenterX = Math.round(0 / gridSize) * gridSize; // 0 ‚Äî —Ü–µ–Ω—Ç—Ä –º–∏—Ä–∞
  const gridCenterY = Math.round(0 / gridSize) * gridSize;
  // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–ª–æ—â–∞–¥–∫–∏ (—Ü–µ–Ω—Ç—Ä 6x2)
  const areaWidth = 6;
  const areaHeight = 2;
  const areaX = gridCenterX - areaWidth / 2;
  const areaY = gridCenterY - areaHeight / 2;

  // –ü–µ—Ä–µ–≤–æ–¥–∏–º –º–∏—Ä–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–ª–æ—â–∞–¥–∫–∏ –≤ —ç–∫—Ä–∞–Ω–Ω—ã–µ
  const topLeft = worldToScreen(areaX, areaY, viewTransform, svgRef);
  const bottomRight = worldToScreen(areaX + areaWidth, areaY + areaHeight, viewTransform, svgRef);
  const overlayStyle = {
    position: 'absolute',
    left: `${topLeft.screenX}px`,
    top: `${topLeft.screenY}px`,
    width: `${bottomRight.screenX - topLeft.screenX}px`,
    height: `${bottomRight.screenY - topLeft.screenY}px`,
    pointerEvents: 'auto',
    zIndex: 20,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
  };

  const handleAreaClick = () => {
    setShowTemplates(true);
  };

  const handleSelectTemplate = (template) => {
    addObject(
      template.type,
      areaX,
      areaY,
      areaWidth,
      areaHeight,
      { rotation: 0, ...template.config }
    );
    setShowTemplates(false);
  };

  const moduleTypes = [
    {
      id: 'default',
      name: 'Default Module',
      code: 'DEFAULT',
      width: 6,
      height: 2,
      type: 'module'
    }
  ];

  return (
    <>
      {!hasModule && !showTemplates && (
        <div style={overlayStyle} onClick={handleAreaClick}>
          <PlatformVisual width={areaWidth} height={areaHeight} />
        </div>
      )}
      {showTemplates && (
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white border rounded shadow-lg p-0 z-30 min-w-[340px] max-w-[95vw]">
          <div className="flex flex-col divide-y divide-gray-200">
            {MODULE_TEMPLATES.map((tpl) => (
              <button
                key={tpl.code}
                className="flex items-center w-full px-0 py-0 hover:bg-blue-50 transition group focus:outline-none"
                onClick={() => handleSelectTemplate(tpl)}
              >
                <div className="flex-1 bg-gray-900 text-white p-4 text-left min-w-[120px] max-w-[160px] h-full flex flex-col justify-center">
                  <div className="font-bold text-lg leading-tight">{tpl.code}</div>
                  <div className="text-xs opacity-80 mt-1">{tpl.name}</div>
                </div>
                <div className="flex items-center justify-center p-2 bg-white min-w-[80px]">
                  {tpl.thumb}
                </div>
                <div className="flex flex-col items-center justify-center px-2">
                  <FaFilePdf className="text-gray-400 group-hover:text-blue-400 mb-1" title="PDF" />
                  <span className="text-[10px] text-gray-400">PDF</span>
                </div>
              </button>
            ))}
          </div>
          <button
            className="block w-full py-2 text-gray-500 hover:text-gray-700 text-xs underline border-t border-gray-200 bg-white"
            onClick={() => setShowTemplates(false)}
          >
            –û—Ç–º–µ–Ω–∞
          </button>
        </div>
      )}
    </>
  );
};

ModularMode.propTypes = {
  addObject: PropTypes.func.isRequired,
  getObjects: PropTypes.func.isRequired,
  screenToWorld: PropTypes.func,
  viewTransform: PropTypes.object,
  svgRef: PropTypes.object,
};

export default ModularMode;


==== src\components\Configurator\ProjectInfo.jsx ====
import React from 'react';
import { motion } from 'framer-motion';

const ProjectInfo = ({ area = 0, cost = 0, elements = [] }) => {
    return (
        <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            className="fixed bottom-4 right-4 bg-white rounded-lg shadow-lg p-4 w-80"
        >
            <h3 className="text-lg font-semibold text-gray-800 mb-4">
                –Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –ø—Ä–æ–µ–∫—Ç
            </h3>
            
            <div className="space-y-3">
                <div className="flex justify-between items-center">
                    <span className="text-gray-600">–ó–∞–≥–∞–ª—å–Ω–∞ –ø–ª–æ—â–∞:</span>
                    <span className="font-medium text-gray-800">{area.toFixed(2)} –º¬≤</span>
                </div>
                
                <div className="flex justify-between items-center">
                    <span className="text-gray-600">–û—Ä—ñ—î–Ω—Ç–æ–≤–Ω–∞ –≤–∞—Ä—Ç—ñ—Å—Ç—å:</span>
                    <span className="font-medium text-gray-800">{cost.toLocaleString('uk-UA')} –≥—Ä–Ω</span>
                </div>
                
                {elements.length > 0 && (
                    <div className="pt-3 border-t border-gray-200">
                        <h4 className="text-sm font-medium text-gray-600 mb-2">
                            –ï–ª–µ–º–µ–Ω—Ç–∏ –ø—Ä–æ–µ–∫—Ç—É:
                        </h4>
                        <div className="space-y-2">
                            {elements.map((element, index) => (
                                <div key={index} className="flex justify-between items-center text-sm">
                                    <span className="text-gray-600">{element.name}</span>
                                    <span className="text-gray-800">{element.count} —à—Ç.</span>
                                </div>
                            ))}
                        </div>
                    </div>
                )}
            </div>
        </motion.div>
    );
};

export default ProjectInfo; 

==== src\components\Configurator\sidebar\PropertiesPanel.jsx ====
// src/components/Configurator/sidebar/PropertiesPanel.jsx
import React from "react";
import PropertyInput from "../common/PropertyInput"; // Use the moved component

const PropertiesPanel = ({
  primarySelectedObject,
  selectedObjectIds, // For count
  lockedObjectIds,
  modifierKeys,
  updateSelectedObjectProperty,
  deleteSelectedObject, // Assumes a function to delete the primary selected object
  activeMode, // –Ω–æ–≤—ã–π –ø—Ä–æ–ø
}) => {
  if (!primarySelectedObject && selectedObjectIds.length === 0) {
    return (
      <div className="w-64 bg-gray-50 border-l border-gray-300 p-3 overflow-y-auto flex-shrink-0">
        <h2 className="text-md font-semibold mb-3 border-b pb-2">–°–≤–æ–π—Å—Ç–≤–∞</h2>
        <p className="text-sm text-gray-500">–ù–∏—á–µ–≥–æ –Ω–µ –≤—ã–±—Ä–∞–Ω–æ.</p>
      </div>
    );
  }

  if (selectedObjectIds.length > 1) {
    return (
      <div className="w-64 bg-gray-50 border-l border-gray-300 p-3 overflow-y-auto flex-shrink-0">
        <h2 className="text-md font-semibold mb-3 border-b pb-2">–°–≤–æ–π—Å—Ç–≤–∞</h2>
        <p className="text-sm text-gray-500">
          –í—ã–±—Ä–∞–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –æ–±—ä–µ–∫—Ç–æ–≤ ({selectedObjectIds.length} —à—Ç).
          {selectedObjectIds.some((id) => lockedObjectIds.includes(id)) && (
            <span className="ml-1 text-xs text-orange-500">
              (–µ—Å—Ç—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ)
            </span>
          )}
        </p>
      </div>
    );
  }

  const isLockedAndCantEdit =
    lockedObjectIds.includes(primarySelectedObject.id) && !modifierKeys.shift;

  return (
    <div className="w-64 bg-gray-50 border-l border-gray-300 p-3 overflow-y-auto flex-shrink-0">
      <h2 className="text-md font-semibold mb-3 border-b pb-2">–°–≤–æ–π—Å—Ç–≤–∞</h2>
      {primarySelectedObject && (
        <div>
          <p className="text-xs text-gray-500 mb-1">
            ID: {primarySelectedObject.id}{" "}
            {primarySelectedObject.label
              ? `(${primarySelectedObject.label})`
              : ""}
          </p>
          <p className="text-sm font-medium mb-2 capitalize">
            –¢–∏–ø: {primarySelectedObject.type}
            {lockedObjectIds.includes(primarySelectedObject.id) && (
              <span className="ml-2 text-orange-500 text-xs font-normal">
                (Locked)
              </span>
            )}
          </p>
          {!(activeMode === "modular" && primarySelectedObject.type === "module") && (
            <PropertyInput
              label="X (–º):"
              value={primarySelectedObject.x.toFixed(3)}
              onChange={(e) => updateSelectedObjectProperty("x", e.target.value)}
              disabled={isLockedAndCantEdit || activeMode === 'modular'}
            />
          )}
          {!(activeMode === "modular" && primarySelectedObject.type === "module") && (
            <PropertyInput
              label="Y (–º):"
              value={primarySelectedObject.y.toFixed(3)}
              onChange={(e) => updateSelectedObjectProperty("y", e.target.value)}
              disabled={isLockedAndCantEdit || activeMode === 'modular'}
            />
          )}
          {!(activeMode === "modular" && primarySelectedObject.type === "module") && (
            <PropertyInput
              label={
                primarySelectedObject.type === "door" ||
                primarySelectedObject.type === "window"
                  ? "–î–ª–∏–Ω–∞ (–º):"
                  : "–®–∏—Ä–∏–Ω–∞ (–º):"
              }
              value={primarySelectedObject.width.toFixed(3)}
              min="0.01"
              onChange={(e) =>
                updateSelectedObjectProperty("width", e.target.value)
              }
              disabled={isLockedAndCantEdit || activeMode === 'modular'}
            />
          )}
          {!(activeMode === "modular" && primarySelectedObject.type === "module") && (
            <PropertyInput
              label={
                primarySelectedObject.type === "door" ||
                primarySelectedObject.type === "window" ||
                primarySelectedObject.type === "wall"
                  ? "–¢–æ–ª—â–∏–Ω–∞ (–º):"
                  : "–í—ã—Å–æ—Ç–∞ (–º):"
              }
              value={primarySelectedObject.height.toFixed(3)}
              min="0.01"
              onChange={(e) =>
                updateSelectedObjectProperty("height", e.target.value)
              }
              disabled={isLockedAndCantEdit || activeMode === 'modular'}
            />
          )}
          <PropertyInput
            label="–í—Ä–∞—â–µ–Ω–∏–µ (¬∞):"
            type="number"
            value={primarySelectedObject.rotation || 0}
            step="1"
            min="-360"
            max="360"
            onChange={(e) =>
              updateSelectedObjectProperty("rotation", e.target.value)
            }
            disabled={isLockedAndCantEdit || activeMode === 'modular'}
          />
          {primarySelectedObject.type === "door" && (
            <>
              <PropertyInput label="–û—Ç–∫—Ä—ã—Ç–∞:">
                <button
                  onClick={() =>
                    updateSelectedObjectProperty(
                      "isOpen",
                      !primarySelectedObject.isOpen,
                    )
                  }
                  className={`w-full p-1 border border-gray-300 rounded text-sm bg-white hover:bg-gray-100 focus:outline-none focus:ring-1 focus:ring-blue-500 ${isLockedAndCantEdit ? "cursor-not-allowed opacity-50" : ""}`}
                  disabled={isLockedAndCantEdit}
                >
                  {primarySelectedObject.isOpen
                    ? "–î–∞ (–ó–∞–∫—Ä—ã—Ç—å)"
                    : "–ù–µ—Ç (–û—Ç–∫—Ä—ã—Ç—å)"}
                </button>
              </PropertyInput>
              <PropertyInput
                label="–£–≥–æ–ª –æ—Ç–∫—Ä. (¬∞):"
                type="number"
                value={primarySelectedObject.openingAngle || 90}
                step="1"
                min="0"
                max="170"
                onChange={(e) =>
                  updateSelectedObjectProperty("openingAngle", e.target.value)
                }
                disabled={isLockedAndCantEdit || !primarySelectedObject.isOpen}
                title={
                  !primarySelectedObject.isOpen ? "–°–Ω–∞—á–∞–ª–∞ –æ—Ç–∫—Ä–æ–π—Ç–µ –¥–≤–µ—Ä—å" : ""
                }
              />
              <PropertyInput label="–ü–µ—Ç–ª–∏:">
                <select
                  value={primarySelectedObject.hingeSide || "left"}
                  onChange={(e) =>
                    updateSelectedObjectProperty("hingeSide", e.target.value)
                  }
                  className={`w-full p-1 border border-gray-300 rounded text-sm ${isLockedAndCantEdit ? "bg-gray-100 cursor-not-allowed" : "bg-white focus:ring-1 focus:ring-blue-500 outline-none"}`}
                  disabled={isLockedAndCantEdit}
                >
                  <option value="left">–°–ª–µ–≤–∞</option>
                  <option value="right">–°–ø—Ä–∞–≤–∞</option>
                </select>
              </PropertyInput>
              <PropertyInput label="–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—Ç–∫—Ä.:">
                <select
                  value={primarySelectedObject.openingDirection || "inward"}
                  onChange={(e) =>
                    updateSelectedObjectProperty(
                      "openingDirection",
                      e.target.value,
                    )
                  }
                  className={`w-full p-1 border border-gray-300 rounded text-sm ${isLockedAndCantEdit ? "bg-gray-100 cursor-not-allowed" : "bg-white focus:ring-1 focus:ring-blue-500 outline-none"}`}
                  disabled={isLockedAndCantEdit}
                >
                  <option value="inward">–í–Ω—É—Ç—Ä—å</option>
                  <option value="outward">–ù–∞—Ä—É–∂—É</option>
                </select>
              </PropertyInput>
            </>
          )}
          <button
            onClick={deleteSelectedObject}
            className={`mt-4 w-full text-white text-sm py-1.5 rounded ${isLockedAndCantEdit ? "bg-red-300 cursor-not-allowed" : "bg-red-500 hover:bg-red-600"}`}
            disabled={isLockedAndCantEdit && primarySelectedObject}
          >
            –£–¥–∞–ª–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–π
          </button>
        </div>
      )}
    </div>
  );
};

export default PropertiesPanel;


==== src\components\Configurator\statusbar\StatusBar.jsx ====
// src/components/Configurator/statusbar/StatusBar.jsx
import React from "react";

const StatusBar = ({
  selectedObjectIds = [],
  primarySelectedObject,
  lockedObjectIds = [],
  history = { undo: [], redo: [] },
}) => {
  return (
    <div className="p-1 bg-gray-100 border-t text-xs text-gray-700 flex justify-between">
      <span>
        {selectedObjectIds.length === 1 && primarySelectedObject
          ? `–í—ã–±—Ä–∞–Ω: ${primarySelectedObject.type} ${primarySelectedObject.label ? `(${primarySelectedObject.label})` : `(ID: ${primarySelectedObject.id})`}${lockedObjectIds.includes(primarySelectedObject.id) ? " [Locked]" : ""}`
          : selectedObjectIds.length > 1
            ? `${selectedObjectIds.length} –æ–±—ä–µ–∫—Ç–æ–≤ –≤—ã–±—Ä–∞–Ω–æ`
            : "–ù–∏—á–µ–≥–æ –Ω–µ –≤—ã–±—Ä–∞–Ω–æ"}
      </span>
      <span>
        Undo: {history?.undo?.length || 0}, Redo: {history?.redo?.length || 0}
      </span>
    </div>
  );
};

export default StatusBar;


==== src\components\Configurator\toolbar\ConfiguratorToolbar.jsx ====
// src/components/Configurator/toolbar/ConfiguratorToolbar.jsx
import React from "react";
import { OBJECT_TYPES_TO_ADD } from "../configuratorConstants";
import { MODES } from "../appConstants";

const ConfiguratorToolbar = ({
  activeModeName,
  addingObjectType,
  onStartAddObject,
  onModeChange,
}) => {
  return (
    <div className="p-2 bg-gray-800 text-white border-b border-gray-700 flex justify-between items-center flex-shrink-0">
      <div className="flex items-center space-x-4">
        <div>
          <h1 className="text-lg font-semibold">
            –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ç–æ—Ä
          </h1>
          <p className="text-xs text-gray-400">
            Space+Drag:Pan. Drag:Marquee. Shift+Click:Multi-select.
            Ctrl/Cmd+C/V/Z/Y. Alt:Grid Snap. Ctrl:Object Snap. Del/Esc.
            L:Lock/Unlock (Shift+Click locked item to select).
          </p>
        </div>
        <div className="flex space-x-2">
          <button
            onClick={() => onModeChange(MODES.MODULAR)}
            className={`px-3 py-1.5 rounded ${
              activeModeName === MODES.MODULAR
                ? "bg-blue-700 ring-2 ring-blue-400"
                : "bg-blue-500 hover:bg-blue-600"
            }`}
          >
            –ú–æ–¥—É–ª—å–Ω—ã–π
          </button>
          <button
            onClick={() => onModeChange(MODES.FRAMELESS)}
            className={`px-3 py-1.5 rounded ${
              activeModeName === MODES.FRAMELESS
                ? "bg-blue-700 ring-2 ring-blue-400"
                : "bg-blue-500 hover:bg-blue-600"
            }`}
          >
            –ë–µ–∑–∫–∞—Ä–∫–∞—Å–Ω—ã–π
          </button>
          <button
            onClick={() => onModeChange(MODES.FRAMED)}
            className={`px-3 py-1.5 rounded ${
              activeModeName === MODES.FRAMED
                ? "bg-blue-700 ring-2 ring-blue-400"
                : "bg-blue-500 hover:bg-blue-600"
            }`}
          >
            –ö–∞—Ä–∫–∞—Å–Ω—ã–π
          </button>
        </div>
      </div>
      <div className="flex space-x-1 overflow-x-auto pb-1">
        {OBJECT_TYPES_TO_ADD.map((item) => (
          <button
            key={item.type}
            onClick={() => onStartAddObject(item.type)}
            title={`–î–æ–±–∞–≤–∏—Ç—å ${item.label}`}
            className={`px-2 py-1 text-xs sm:px-3 sm:py-1.5 sm:text-sm rounded whitespace-nowrap hover:bg-blue-600 transition-colors ${
              addingObjectType === item.type
                ? "bg-blue-700 ring-2 ring-blue-400"
                : "bg-blue-500"
            }`}
          >
            {item.label}
          </button>
        ))}
      </div>
    </div>
  );
};

export default ConfiguratorToolbar;


==== src\index.css ====
/* src/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Add any global styles below */
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
} 

==== src\index.js ====
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css'; // Assuming you have global styles here
import App from './App';
import reportWebVitals from './reportWebVitals'; // Optional: for performance monitoring

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
    <App />

);



==== src\reportWebVitals.js ====
// src/reportWebVitals.js
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals; 

==== tailwind.config.js ====
// ========================================================================
// FILE: tailwind.config.js
// ========================================================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./public/index.html",
    "./src/**/*.{js,jsx,ts,tsx}", // –°–∫–∞–Ω–∏—Ä—É–µ–º –≤—Å–µ JS/JSX/TS/TSX —Ñ–∞–π–ª—ã –≤ src
  ],
  theme: {
    extend: {
      // –û—Å–Ω–æ–≤–Ω–∞—è –ø–∞–ª–∏—Ç—Ä–∞
      colors: {
        "dark-bg": "#121212", // –ï—â–µ —Ç–µ–º–Ω–µ–µ —Ñ–æ–Ω –¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞
        "card-bg": "#1E1E1E", // –§–æ–Ω –∫–∞—Ä—Ç–æ—á–µ–∫ –∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ UI
        "primary-blue": "#007BFF", // –û—Å–Ω–æ–≤–Ω–æ–π –∞–∫—Ü–µ–Ω—Ç–Ω—ã–π —Å–∏–Ω–∏–π
        "gradient-blue": "#00C4FF", // –í—Ç–æ—Ä–∏—á–Ω—ã–π —Å–∏–Ω–∏–π –¥–ª—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–≤
        "hover-blue": "#0056b3", // –°–∏–Ω–∏–π –¥–ª—è hover —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
        // –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö —Ü–≤–µ—Ç–æ–≤ Tailwind
        gray: {
          900: "#111827", // –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Ñ–æ–Ω–∞, –µ—Å–ª–∏ dark-bg –Ω–µ –∑–∞–¥–∞–Ω
          800: "#1F2937", // –¢–µ–º–Ω–æ-—Å–µ—Ä—ã–π –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ UI
          700: "#374151", // –°–µ—Ä—ã–π –¥–ª—è –≥—Ä–∞–Ω–∏—Ü, —Ñ–æ–Ω–∞ –∏–Ω–ø—É—Ç–æ–≤
          600: "#4B5563", // –°–µ—Ä—ã–π –¥–ª—è —Ç–µ–∫—Å—Ç–∞, –≥—Ä–∞–Ω–∏—Ü
          500: "#6B7280", // –°–µ—Ä—ã–π –¥–ª—è –≤—Ç–æ—Ä–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞, –∏–∫–æ–Ω–æ–∫
          400: "#9CA3AF", // –°–≤–µ—Ç–ª–æ-—Å–µ—Ä—ã–π –¥–ª—è —Ç–µ–∫—Å—Ç–∞
          300: "#D1D5DB", // –ï—â–µ —Å–≤–µ—Ç–ª–µ–µ
          200: "#E5E7EB", // –ü–æ—á—Ç–∏ –±–µ–ª—ã–π
          100: "#F3F4F6", // –û—á–µ–Ω—å —Å–≤–µ—Ç–ª—ã–π
        },
        // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥—Ä—É–≥–∏–µ –∞–∫—Ü–µ–Ω—Ç–Ω—ã–µ —Ü–≤–µ—Ç–∞
        // 'accent-green': '#10B981',
        // 'accent-red': '#EF4444',
        // 'accent-yellow': '#F59E0B',
      },
      // –®—Ä–∏—Ñ—Ç—ã
      fontFamily: {
        sans: [
          "Inter",
          "system-ui",
          "-apple-system",
          "BlinkMacSystemFont",
          '"Segoe UI"',
          "Roboto",
          '"Helvetica Neue"',
          "Arial",
          '"Noto Sans"',
          "sans-serif",
          '"Apple Color Emoji"',
          '"Segoe UI Emoji"',
          '"Segoe UI Symbol"',
          '"Noto Color Emoji"',
        ],
        // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –º–æ–Ω–æ—à–∏—Ä–∏–Ω–Ω—ã–π —à—Ä–∏—Ñ—Ç
        mono: [
          "ui-monospace",
          "SFMono-Regular",
          "Menlo",
          "Monaco",
          "Consolas",
          '"Liberation Mono"',
          '"Courier New"',
          "monospace",
        ],
      },
      // –ê–Ω–∏–º–∞—Ü–∏–∏
      animation: {
        // spin —É–∂–µ –µ—Å—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤ Tailwind v3+
        "fade-in": "fadeIn 0.5s ease-out forwards",
        "slide-up": "slideUp 0.5s ease-out forwards",
      },
      keyframes: {
        fadeIn: {
          "0%": { opacity: "0" },
          "100%": { opacity: "1" },
        },
        slideUp: {
          "0%": { opacity: "0", transform: "translateY(10px)" },
          "100%": { opacity: "1", transform: "translateY(0)" },
        },
      },
      // –¢–µ–Ω–∏
      boxShadow: {
        md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
        lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
        xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
        "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
        "inner-md": "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
        "blue-glow-sm":
          "0 1px 3px 0 rgba(0, 123, 255, 0.1), 0 1px 2px -1px rgba(0, 123, 255, 0.1)",
        "blue-glow-md":
          "0 4px 6px -1px rgba(0, 123, 255, 0.1), 0 2px 4px -2px rgba(0, 123, 255, 0.1)",
        "blue-glow-lg":
          "0 10px 15px -3px rgba(0, 123, 255, 0.1), 0 4px 6px -4px rgba(0, 123, 255, 0.1)",
      },
    },
  },
  plugins: [
    // –û—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–µ –ø–ª–∞–≥–∏–Ω—ã Tailwind
    require("@tailwindcss/forms"), // –°—Ç–∏–ª–∏ –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Ñ–æ—Ä–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    require("@tailwindcss/typography"), // –°—Ç–∏–ª–∏ –¥–ª—è –ø—Ä–æ–∑—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∏–∑ Markdown)
    require("@tailwindcss/aspect-ratio"), // –î–ª—è —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏—è —Å—Ç–æ—Ä–æ–Ω
    require("@tailwindcss/line-clamp"), // –î–ª—è –æ–±—Ä–µ–∑–∫–∏ —Ç–µ–∫—Å—Ç–∞ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É —Å—Ç—Ä–æ–∫
  ],
  // variants –≤ Tailwind v3+ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Ä–µ–∂–µ, –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–µ–µ –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã (hover:, focus:, group-hover:)
  // –ù–æ –µ—Å–ª–∏ –Ω—É–∂–Ω—ã —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã:
  variants: {
    extend: {
      // –ü—Ä–∏–º–µ—Ä:
      backgroundColor: ["active"],
      opacity: ["disabled"],
      cursor: ["disabled"],
    },
  },
};


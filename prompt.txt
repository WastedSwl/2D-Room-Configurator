Структура проекта:
- .eslintrc.js
+ backend
  + config
    - config.json
  + controllers
    - aiController.js
    - authController.js
  + middleware
    - authMiddleware.js
  + models
    - index.js
    - user.js
  - package-lock.json
  - package.json
  + routes
    - aiRoutes.js
    - authRoutes.js
  - server.js
- package-lock.json
- package.json
- postcss.config.js
+ public
  - index.html
  - manifest.json
- README.md
+ src
  - App.js
  + components
    + api
      - aiService.js
      - authService.js
      - axiosConfig.js
    + Auth
      - LoginPage.jsx
      - RegisterPage.jsx
    + Configurator
      - appConstants.js
      + canvas
        - Grid.jsx
        - SvgCanvas.jsx
      + common
        - ContextMenu.jsx
        - PropertyInput.jsx
      - Configurator.jsx
      - configuratorConstants.js
      - configuratorUtils.js
      + hooks
        - useKeyboardShortcuts.js
        - useModifierKeys.js
        - useMouseInteractions.js
        - useViewTransform.js
      + renderers
        - AddModuleButtonRenderer.jsx
        - CeilingLightRenderer.jsx
        - DoorRenderer.jsx
        - KitchenElementRenderer.jsx
        - ModuleRenderer.jsx
        - OutletRenderer.jsx
        - PanoramicWindowRenderer.jsx
        - RadiatorRenderer.jsx
        - SwitchDoubleRenderer.jsx
        - SwitchRenderer.jsx
        - WallMountedLightRenderer.jsx
        - WallSegmentRenderer.jsx
        - WindowRenderer.jsx
      + sidebar
        - ElementSelectionPanel.jsx
        - ModulePreviewRenderer.jsx
        - ModuleTemplateSelectionPanel.jsx
        - PropertiesPanel.jsx
      + statusbar
        - StatusBar.jsx
      + toolbar
        - ConfiguratorToolbar.jsx
    + contexts
      - AuthContext.js
    + utils
      - ProtectedRoute.jsx
  - index.css
  - index.js
  - reportWebVitals.js
- tailwind.config.js

Содержимое некоторых файлов:

==== .eslintrc.js ====
/* eslint-disable no-unused-vars */

module.exports = {
  env: {
    browser: true,
    es2021: true,
    jest: true,
  },
  extends: [
    "eslint:recommended",
    "react-app",
    "react-app/jest",
  ],
  parserOptions: {
    ecmaFeatures: {
      jsx: true,
    },
    ecmaVersion: "latest",
    sourceType: "module",
  },
  rules: {
    "react/react-in-jsx-scope": "off",
    "react/prop-types": "warn",
    "jsx-a11y/anchor-is-valid": "warn",
    "no-unused-vars": ["warn", { argsIgnorePattern: "^_" }],
    "react/no-unknown-property": "off", // specific for this project due to custom attributes
    "react/no-unescaped-entities": "off", // for things like "don't"
  },
  settings: {
    react: {
      version: "detect",
    },
  },
  overrides: [
    {
      files: ["**/*.test.js", "**/*.test.jsx"],
      env: {
        jest: true,
      },
    },
  ],
};

==== package.json ====
{
  "name": "bird",
  "version": "0.2.0",
  "private": true,
  "dependencies": {
    "@dnd-kit/core": "^6.1.0",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@heroicons/react": "^2.2.0",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.2.0",
    "@testing-library/user-event": "^13.5.0",
    "aos": "^2.3.4",
    "axios": "^1.8.4",
    "dotenv": "^16.4.7",
    "framer-motion": "^12.5.0",
    "lucide-react": "^0.511.0",
    "prop-types": "^15.8.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-icons": "^5.5.0",
    "react-router-dom": "^7.4.0",
    "react-scripts": "^5.0.1",
    "react-select": "^5.10.1",
    "react-slick": "^0.30.3",
    "react-toastify": "^11.0.5",
    "slick-carousel": "^1.8.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@tailwindcss/aspect-ratio": "^0.4.2",
    "@tailwindcss/forms": "^0.5.10",
    "@tailwindcss/line-clamp": "^0.4.4",
    "@tailwindcss/postcss": "^4.0.15",
    "@tailwindcss/typography": "^0.5.16",
    "autoprefixer": "^10.4.21",
    "clsx": "^2.1.1",
    "eslint": "^8.57.1",
    "eslint-plugin-jsx-a11y": "^6.8.0",
    "eslint-plugin-react": "^7.34.1",
    "eslint-plugin-react-hooks": "^4.6.2",
    "husky": "^9.1.7",
    "lint-staged": "^15.5.0",
    "nodemon": "^3.1.9",
    "postcss": "^8.5.3",
    "postcss-flexbugs-fixes": "^5.0.2",
    "postcss-preset-env": "^10.1.5",
    "prettier": "^3.5.3",
    "tailwindcss": "^3.4.3"
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "*.{js,jsx,css,md}": "prettier --write",
    "*.{js,jsx}": "eslint --fix"
  },
  "resolutions": {
    "nth-check": "2.0.1"
  }
}


==== postcss.config.js ====
// ========================================================================
// FILE: postcss.config.js
// ========================================================================
// Adjusted for standard Tailwind v3+ installation
module.exports = {
  plugins: {
    tailwindcss: {}, // Standard Tailwind plugin
    autoprefixer: {},
    // Removed '@tailwindcss/postcss7-compat' as using standard Tailwind now
    // Removed '@tailwindcss/postcss' which seems redundant/incorrect here
    // Removed 'postcss-flexbugs-fixes' and 'postcss-preset-env' as Autoprefixer handles prefixes
  },
};


==== public\index.html ====
<!-- FILE: public/index.html -->
<!-- No changes needed based on the prompt -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!-- Consider adding fonts here if needed, e.g., Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <title>Mission Hire | HRM App</title>
    <!-- Updated Title -->
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>


==== public\manifest.json ====
{
  "short_name": "Mission Hire",
  "name": "Mission Hire - Recruitment Platform",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#007BFF",
  "background_color": "#1A1A1A"
}


==== README.md ====
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)


==== src\App.js ====
import React from "react";
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from "./components/contexts/AuthContext"; // <--- ПРОВЕРЬТЕ ЭТОТ ПУТЬ
import Configurator from "./components/Configurator/Configurator";
import LoginPage from "./components/Auth/LoginPage";
import RegisterPage from "./components/Auth/RegisterPage";
import ProtectedRoute from "./components/utils/ProtectedRoute"; // <--- ПРОВЕРЬТЕ ЭТОТ ПУТЬ
import "./index.css";
import { ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';


function App() {
  return (
    <AuthProvider>
      <Router>
        <div className="App-container h-screen flex flex-col bg-dark-bg text-gray-200">
          <Routes>
            <Route path="/login" element={<LoginPage />} />
            <Route path="/register" element={<RegisterPage />} />
            <Route element={<ProtectedRoute />}>
              <Route path="/" element={<Configurator />} />
            </Route>
            <Route path="*" element={<Navigate to="/" replace />} />
          </Routes>
           <ToastContainer theme="dark" position="bottom-right" autoClose={3000} hideProgressBar={false} newestOnTop={false} closeOnClick rtl={false} pauseOnFocusLoss draggable pauseOnHover />
        </div>
      </Router>
    </AuthProvider>
  );
}

export default App;

==== src\components\Configurator\appConstants.js ====
// src/components/Configurator/appConstants.js
// This file is intentionally left sparse or empty as per the refactoring request.
// Add constants here if needed for future grid-only related features.

export const WALL_THICKNESS_M = 0.15; // Standard wall thickness in meters, e.g., 15cm

export {}; // To make it a module


==== src\components\Configurator\canvas\Grid.jsx ====
// src/components/Configurator/canvas/Grid.jsx
import React from "react";
import {
  GRID_LINE_COLOR,
  GRID_BOLD_LINE_COLOR,
  GRID_CELL_SIZE_M, // Use this for main grid
  INITIAL_PPM,
} from "../configuratorConstants";

const Grid = ({ viewTransform, svgWidth, svgHeight }) => {
  if (svgWidth === 0 || svgHeight === 0) return null;

  const { x: viewX, y: viewY, scale } = viewTransform;
  const finalGridLines = [];

  const cellSizeWorld = GRID_CELL_SIZE_M; // 1.15 meters
  const cellSizeScaled = cellSizeWorld * scale;

  // Thresholds for showing lines
  const cellLineThreshold = 10; // Show cell lines if they are at least 10px apart
  const boldLineDivisor = 5; // Make every 5th cell line bold

  // Vertical Lines
  if (cellSizeScaled > cellLineThreshold) {
    const startOffsetX = viewX % cellSizeScaled;
    let counter = Math.floor((0 - viewX) / cellSizeScaled); // To keep track for bold lines

    for (let x = startOffsetX; x < svgWidth; x += cellSizeScaled) {
      const isBold = counter % boldLineDivisor === 0;
      finalGridLines.push(
        <line
          key={`grid-v-${x}`}
          x1={x}
          y1={0}
          x2={x}
          y2={svgHeight}
          stroke={isBold ? GRID_BOLD_LINE_COLOR : GRID_LINE_COLOR}
          strokeWidth={
            isBold
              ? scale > INITIAL_PPM * 0.5
                ? 0.5
                : 0.3
              : scale > INITIAL_PPM * 0.5
                ? 0.25
                : 0.15
          }
        />,
      );
      counter++;
    }
  }

  // Horizontal Lines
  if (cellSizeScaled > cellLineThreshold) {
    const startOffsetY = viewY % cellSizeScaled;
    let counter = Math.floor((0 - viewY) / cellSizeScaled); // To keep track for bold lines

    for (let y = startOffsetY; y < svgHeight; y += cellSizeScaled) {
      const isBold = counter % boldLineDivisor === 0;
      finalGridLines.push(
        <line
          key={`grid-h-${y}`}
          x1={0}
          y1={y}
          x2={svgWidth}
          y2={y}
          stroke={isBold ? GRID_BOLD_LINE_COLOR : GRID_LINE_COLOR}
          strokeWidth={
            isBold
              ? scale > INITIAL_PPM * 0.5
                ? 0.5
                : 0.3
              : scale > INITIAL_PPM * 0.5
                ? 0.25
                : 0.15
          }
        />,
      );
      counter++;
    }
  }
  return <g id="grid">{finalGridLines}</g>;
};

export default React.memo(Grid);


==== src\components\Configurator\canvas\SvgCanvas.jsx ====
import React, { useState, useEffect, useCallback } from "react";
import Grid from "./Grid";
import ModuleRenderer from "../renderers/ModuleRenderer";
import AddModuleButtonRenderer from "../renderers/AddModuleButtonRenderer";
import { MODES, OBJECT_TYPES } from "../configuratorConstants";

const SvgCanvas = ({
  svgRef,
  viewTransform,
  modifierKeys,
  isPanningWithSpace,
  isDraggingModule,
  handleMouseMove,
  handleMouseUp,
  handleMouseLeave,
  handleMouseDownOnCanvas,
  onContextMenu,
  objects,
  activeMode,
  selectedObjectId,
  setSelectedObjectId,
  scale,
  canAddInitialModule,
  onAddModule,
  onToggleWallSegment,
  primarySelectedObject,
  elementTypeToPlace,
  onWallSegmentClick,
  suitableWallSegmentIds, // Added
}) => {
  const [svgDimensions, setSvgDimensions] = useState({ width: 0, height: 0 });

  useEffect(() => {
    const currentSvg = svgRef.current;
    if (!currentSvg) return;
    const resizeObserver = new ResizeObserver((entries) => {
      for (let entry of entries) {
        const { width, height } = entry.contentRect;
        setSvgDimensions({ width, height });
      }
    });
    resizeObserver.observe(currentSvg);
    const rect = currentSvg.getBoundingClientRect();
    if (rect.width > 0 && rect.height > 0) {
      setSvgDimensions({ width: rect.width, height: rect.height });
    }
    return () => {
      if (currentSvg) resizeObserver.unobserve(currentSvg);
    };
  }, [svgRef]);

  const localHandleMouseMoveForCanvas = useCallback(
    (e) => {
      if ((isPanningWithSpace || isDraggingModule) && handleMouseMove) {
        handleMouseMove(e);
      }
    },
    [isPanningWithSpace, isDraggingModule, handleMouseMove],
  );

  let cursorClass = "cursor-default";
  if (isDraggingModule)
    cursorClass = "cursor-grabbing";
  else if (isPanningWithSpace) cursorClass = "cursor-grabbing";
  else if (modifierKeys?.spacebar) cursorClass = "cursor-grab";
  else if (elementTypeToPlace) cursorClass = "cursor-crosshair";

  const handleSvgContextMenu = (e) => {
    const targetIsCanvas =
      e.target === svgRef.current || e.target.closest("g#grid");
    if (targetIsCanvas && onContextMenu) {
      e.preventDefault();
      onContextMenu(e, null, "canvas", {});
    }
  };

  const existingModulesCount = objects.filter(
    (obj) => obj.type === OBJECT_TYPES.MODULE,
  ).length;


  return (
    <svg
      ref={svgRef}
      width="100%"
      height="100%"
      onMouseMove={localHandleMouseMoveForCanvas}
      onMouseUp={handleMouseUp}
      onMouseLeave={handleMouseLeave}
      onMouseDown={handleMouseDownOnCanvas}
      onContextMenu={handleSvgContextMenu}
      className={`block ${cursorClass} bg-card-bg`}
    >
      {svgDimensions.width > 0 && svgDimensions.height > 0 && (
        <Grid
          viewTransform={viewTransform}
          svgWidth={svgDimensions.width}
          svgHeight={svgDimensions.height}
        />
      )}
      <g transform={`translate(${viewTransform.x}, ${viewTransform.y})`}>
        {activeMode === MODES.MODULAR && canAddInitialModule && (
          <AddModuleButtonRenderer
            scale={scale}
            onClick={onAddModule}
            hasModules={existingModulesCount > 0}
          />
        )}
        {objects.map((obj) => {
          if (
            obj.type === OBJECT_TYPES.MODULE &&
            activeMode === MODES.MODULAR
          ) {
            return (
              <ModuleRenderer
                key={obj.id}
                module={obj}
                scale={scale}
                selectedObjectId={selectedObjectId}
                setSelectedObjectId={setSelectedObjectId}
                onToggleWallSegment={onToggleWallSegment}
                primarySelectedObject={primarySelectedObject}
                onContextMenu={onContextMenu}
                elementTypeToPlace={elementTypeToPlace}
                onWallSegmentClick={onWallSegmentClick}
                suitableWallSegmentIds={suitableWallSegmentIds} // Pass down
              />
            );
          }
          return null;
        })}
      </g>
    </svg>
  );
};
export default SvgCanvas;

==== src\components\Configurator\common\ContextMenu.jsx ====
import React, { useEffect, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";

const ContextMenu = ({ x, y, options, onClose }) => {
  const menuRef = useRef(null);

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (menuRef.current && !menuRef.current.contains(event.target)) {
        onClose();
      }
    };
    const handleEsc = (event) => {
      if (event.key === "Escape") {
        onClose();
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    document.addEventListener("keydown", handleEsc);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
      document.removeEventListener("keydown", handleEsc);
    };
  }, [onClose]);

  if (!options || options.length === 0) return null;

  const menuWidth = 180; 
  const menuHeight = options.length * 35; 
  const adjustedX =
    x + menuWidth > window.innerWidth ? window.innerWidth - menuWidth - 10 : x;
  const adjustedY =
    y + menuHeight > window.innerHeight
      ? window.innerHeight - menuHeight - 10
      : y;

  const menuVariants = {
    hidden: { opacity: 0, scale: 0.95, y: -10 },
    visible: { opacity: 1, scale: 1, y: 0, transition: { duration: 0.15, ease: "easeOut" } },
    exit: { opacity: 0, scale: 0.95, y: -10, transition: { duration: 0.1, ease: "easeIn" } },
  };

  return (
    <motion.div
      ref={menuRef}
      className="fixed bg-card-bg border border-gray-500 shadow-2xl rounded-lg py-2 z-[100] text-sm text-gray-100 min-w-[200px]"
      style={{ top: adjustedY, left: adjustedX }}
      variants={menuVariants}
      initial="hidden"
      animate="visible"
      exit="exit"
    >
      {options.map((option, index) => {
        if (option.isSeparator) {
          return (
            <div
              key={`sep-${index}`}
              className="border-t border-gray-600 my-1.5 h-0 p-0"
            ></div>
          );
        }
        return (
          <div
            key={option.label || index}
            onClick={() => {
              if (option.onClick && !option.disabled) {
                option.onClick();
              }
              if (!option.keepOpen) {
                onClose();
              }
            }}
            className={`px-4 py-2 whitespace-nowrap transition-colors duration-150 rounded-md mx-1 ${
              option.disabled
                ? "text-gray-500 cursor-not-allowed"
                : "hover:bg-primary-blue hover:text-white cursor-pointer"
            }`}
          >
            {option.label}
          </div>
        );
      })}
    </motion.div>
  );
};

export default ContextMenu;

==== src\components\Configurator\common\PropertyInput.jsx ====
import React from "react";

const PropertyInput = ({
  label,
  value,
  onChange,
  type = "text",
  disabled,
  children,
  className,
  inputClassName,
  labelClassName,
  ...props
}) => {
  return (
    <div className={`mb-2 ${className || ""}`}>
      {label && (
        <label
          className={`block text-xs text-gray-400 mb-0.5 ${labelClassName || ""}`}
        >
          {label}
        </label>
      )}
      {children ? (
        React.Children.map(children, (child) =>
          React.isValidElement(child)
            ? React.cloneElement(child, { disabled })
            : child,
        )
      ) : (
        <input
          type={type}
          value={value}
          onChange={onChange}
          disabled={disabled}
          className={`w-full px-3 py-2 border border-gray-600 rounded-md text-sm bg-gray-700/50 text-gray-100 focus:ring-2 focus:ring-primary-blue focus:border-primary-blue outline-none transition-colors duration-150 placeholder-gray-500 ${disabled ? "bg-gray-800 opacity-70 cursor-not-allowed" : "hover:border-gray-500"} ${inputClassName || ""}`}
          {...props}
        />
      )}
    </div>
  );
};

export default PropertyInput;

==== src\components\Configurator\Configurator.jsx ====
// ==== src\components\Configurator\Configurator.jsx ====
import React, { useRef, useEffect, useState, useCallback, useContext } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { toast } from 'react-toastify';
import useViewTransform from "./hooks/useViewTransform";
import useModifierKeys from "./hooks/useModifierKeys";
import useMouseInteractions from "./hooks/useMouseInteractions";
import useKeyboardShortcuts from "./hooks/useKeyboardShortcuts";
import ConfiguratorToolbar from "./toolbar/ConfiguratorToolbar";
import SvgCanvas from "./canvas/SvgCanvas";
import StatusBar from "./statusbar/StatusBar";
import PropertiesPanel from "./sidebar/PropertiesPanel";
import ElementSelectionPanel from "./sidebar/ElementSelectionPanel";
import ModuleTemplateSelectionPanel from "./sidebar/ModuleTemplateSelectionPanel";
import ContextMenu from "./common/ContextMenu";
import {
  MODES,
  OBJECT_TYPES,
  DEFAULT_MODULE_CELLS_LONG,
  DEFAULT_MODULE_CELLS_WIDE,
  GRID_CELL_SIZE_M,
  defaultObjectSizes,
  WALL_THICKNESS_M_RENDER,
  INITIAL_PPM,
  EPSILON,
  MODULE_TEMPLATES,
  DOCKED_SPLIT_WALL_THICKNESS_M,
  DOCKED_SPLIT_WALL_OFFSET_M,
} from "./configuratorConstants";
import { checkOverlapWithRotation, getModuleVertices, subtractVectors, normalizeVector, dotProduct, distance } from "./configuratorUtils";
import AuthContext from "../contexts/AuthContext";

const generateId = (prefix = "id_") =>
  `${prefix}${Date.now().toString(36)}${Math.random().toString(36).substring(2, 7)}`;

const initialFloorId = "floor_0";
const initialFloors = [{ id: initialFloorId, name: "Этаж 1" }];
const initialProjectObjects = { [initialFloorId]: [] };

const faceDefinitions = [
  { name: "Top",    indices: [0,1], getExtent: mod => mod.cellsWide, getSegKey: (i,mod) => `${i},0_h`,             getOffsetSign: () => -1, mapsKDirectly: true },
  { name: "Right",  indices: [1,2], getExtent: mod => mod.cellsLong, getSegKey: (i,mod) => `${mod.cellsWide},${i}_v`, getOffsetSign: () =>  1, mapsKDirectly: true },
  { name: "Bottom", indices: [2,3], getExtent: mod => mod.cellsWide, getSegKey: (i,mod) => `${i},${mod.cellsLong}_h`, getOffsetSign: () =>  1, mapsKDirectly: false },
  { name: "Left",   indices: [3,0], getExtent: mod => mod.cellsLong, getSegKey: (i,mod) => `0,${i}_v`,             getOffsetSign: () => -1, mapsKDirectly: false }
];

const Configurator = () => {
  const { user, logout } = useContext(AuthContext);
  const svgRef = useRef(null);
  const mainContainerRef = useRef(null);
  const loadFileInputRef = useRef(null);
  const [activeMode, setActiveMode] = useState(MODES.MODULAR);
  const [projectObjects, setProjectObjects] = useState(initialProjectObjects);
  const [floors, setFloors] = useState(initialFloors);
  const [currentFloorId, setCurrentFloorId] = useState(initialFloorId);
  const [selectedObjectId, setSelectedObjectId] = useState(null);
  const [isTemplatePanelOpen, setIsTemplatePanelOpen] = useState(false);
  const [modulePlacementCoords, setModulePlacementCoords] = useState(null);
  const [contextMenu, setContextMenu] = useState(null);
  const modifierKeys = useModifierKeys(mainContainerRef, svgRef);
  const { viewTransform, setViewTransform, screenToWorld } = useViewTransform(svgRef);
  const [elementTypeToPlace, setElementTypeToPlace] = useState(null);
  const objectsOnCurrentFloor = projectObjects[currentFloorId] || [];

  const getObjectById = useCallback(
    (id, floorIdToSearch = currentFloorId) => {
      if (!id) return null;
      const objectsToSearch = projectObjects[floorIdToSearch] || [];
      const module = objectsToSearch.find(
        (obj) => obj.id === id && obj.type === OBJECT_TYPES.MODULE,
      );
      if (module) return module;
      for (const mod of objectsToSearch.filter((o) => o.type === OBJECT_TYPES.MODULE)) {
        for (const segmentKey in mod.wallSegments) {
          const segment = mod.wallSegments[segmentKey];
          if (segment.id === id) {
            return {
              ...segment,
              type: OBJECT_TYPES.WALL_SEGMENT,
              parentModule: mod,
              segmentKey,
            };
          }
          if (segment.elements) {
            for (const element of segment.elements) {
              if (element.id === id)
                return {
                  ...element,
                  type: element.type,
                  parentWallSegment: segment,
                  parentModule: mod,
                  segmentKey,
                };
            }
          }
        }
      }
      return null;
    },
    [projectObjects, currentFloorId],
  );

  const primarySelectedObject = getObjectById(selectedObjectId);
  const canShowInitialModuleButton =
    activeMode === MODES.MODULAR &&
    objectsOnCurrentFloor.filter(obj => obj.type === OBJECT_TYPES.MODULE).length === 0;
  const closeContextMenu = useCallback(() => setContextMenu(null), []);

  const createNewModule = useCallback((config) => {
    const {
      posX = 0,
      posY = 0,
      cellsWide = DEFAULT_MODULE_CELLS_WIDE,
      cellsLong = DEFAULT_MODULE_CELLS_LONG,
      label,
      internalWallSegments: templateInternalWalls = {},
      predefinedElements: templatePredefinedElements = [],
      rotation = 0,
      mirroredX = false,
    } = config;
    const moduleId = generateId("module_");
    const actualLabel = label || `Модуль ${cellsWide}x${cellsLong}`;
    const newModuleWallSegments = {};

    const getDefaultSegmentProps = () => ({
        elements: [],
        thickness: WALL_THICKNESS_M_RENDER,
        isDocked: false,
        renderOffset: 0,
        isPassageWithPartner: false,
        isFullyOpenPassage: false,
        partnerSegmentId: null,
        partnerModuleId: null,
        wasPartnerModuleId: null,
        wasRenderOffset: null,
    });

    for (let i = 0; i < cellsWide; i++) {
      newModuleWallSegments[`${i},0_h`] = { id: generateId("wall_"), ...getDefaultSegmentProps() };
      newModuleWallSegments[`${i},${cellsLong}_h`] = { id: generateId("wall_"), ...getDefaultSegmentProps() };
    }
    for (let j = 0; j < cellsLong; j++) {
      newModuleWallSegments[`0,${j}_v`] = { id: generateId("wall_"), ...getDefaultSegmentProps() };
      newModuleWallSegments[`${cellsWide},${j}_v`] = { id: generateId("wall_"), ...getDefaultSegmentProps() };
    }

    for (const segmentKey in templateInternalWalls) {
      if (Object.prototype.hasOwnProperty.call(templateInternalWalls, segmentKey)) {
        const wallData = templateInternalWalls[segmentKey];
        newModuleWallSegments[segmentKey] = {
            id: generateId("wall_"),
            ...getDefaultSegmentProps(),
            thickness: wallData.thickness || WALL_THICKNESS_M_RENDER
        };
      }
    }

    templatePredefinedElements.forEach(elConfig => {
      const targetSegment = newModuleWallSegments[elConfig.segmentKey];
      if (targetSegment) {
        let elementWidth = elConfig.properties?.width || defaultObjectSizes[elConfig.type]?.width || GRID_CELL_SIZE_M;
        let positionOnSegment = elConfig.properties?.positionOnSegment || 0.5;

        if (elConfig.type === OBJECT_TYPES.DOOR || elConfig.type === OBJECT_TYPES.WINDOW) {
            elementWidth = GRID_CELL_SIZE_M;
            positionOnSegment = 0.5;
        }
        
        const newElement = { 
            id: generateId(`${elConfig.type}_`), 
            type: elConfig.type, 
            ...elConfig.properties,
            width: elementWidth,
            positionOnSegment: positionOnSegment
        };
        if (!Array.isArray(targetSegment.elements)) {
            targetSegment.elements = [];
        }
        targetSegment.elements.push(newElement);
      }
    });

    return {
      id: moduleId, type: OBJECT_TYPES.MODULE, x: posX, y: posY, cellsWide, cellsLong,
      width: cellsWide * GRID_CELL_SIZE_M, height: cellsLong * GRID_CELL_SIZE_M,
      rotation: rotation, label: actualLabel, wallSegments: newModuleWallSegments,
      mirroredX: mirroredX,
    };
  }, [GRID_CELL_SIZE_M]);

  const openTemplateSelectionPanel = useCallback((coords = { worldX: 0, worldY: 0 }) => {
    if (!canShowInitialModuleButton && !coords) return;
    setModulePlacementCoords(coords);
    setIsTemplatePanelOpen(true);
    setSelectedObjectId(null);
    closeContextMenu();
  }, [canShowInitialModuleButton, closeContextMenu]);

  const addModuleFromTemplate = useCallback((template) => {
    if (!modulePlacementCoords) {
      setIsTemplatePanelOpen(false);
      return;
    }
    const { worldX, worldY } = modulePlacementCoords;
    const snappedX = Math.round(worldX / GRID_CELL_SIZE_M) * GRID_CELL_SIZE_M;
    const snappedY = Math.round(worldY / GRID_CELL_SIZE_M) * GRID_CELL_SIZE_M;
    const moduleConfig = {
      posX: snappedX, posY: snappedY, cellsWide: template.cellsWide, cellsLong: template.cellsLong,
      label: template.label, internalWallSegments: template.internalWallSegments, predefinedElements: template.predefinedElements,
      rotation: 0, mirroredX: template.mirroredX || false,
    };
    const tempNewModule = createNewModule(moduleConfig);
    const existingModulesOnFloor = (projectObjects[currentFloorId] || []).filter(
      obj => obj.type === OBJECT_TYPES.MODULE
    );
    let canPlaceModule = true;
    for (const existingModule of existingModulesOnFloor) {
      if (checkOverlapWithRotation(tempNewModule, existingModule)) {
        canPlaceModule = false;
        break;
      }
    }
    if (!canPlaceModule) {
      toast.error("Невозможно разместить модуль: пересечение с существующим модулем.");
      setIsTemplatePanelOpen(false);
      setModulePlacementCoords(null);
      closeContextMenu();
      return;
    }
    const newModule = tempNewModule;
    setProjectObjects(prev => ({
      ...prev,
      [currentFloorId]: [...(prev[currentFloorId] || []), newModule]
    }));
    setSelectedObjectId(newModule.id);
    setIsTemplatePanelOpen(false);
    setModulePlacementCoords(null);
    closeContextMenu();
  }, [createNewModule, closeContextMenu, modulePlacementCoords, GRID_CELL_SIZE_M, currentFloorId, projectObjects]);

  const addModuleFromToolbar = useCallback(() => {
    let newX = 0;
    let newY = 0;
    const modulesOnly = objectsOnCurrentFloor.filter((o) => o.type === OBJECT_TYPES.MODULE);
    if (modulesOnly.length > 0) {
      const rightmostModule = modulesOnly.filter((obj) => typeof obj.x === "number" && typeof obj.y === "number")
        .sort((a, b) => (b.x || 0) + (b.width || 0) - ((a.x || 0) + (a.width || 0)))[0] || modulesOnly[modulesOnly.length - 1];
      if (rightmostModule) {
        newX = (rightmostModule.x || 0) + (rightmostModule.width || DEFAULT_MODULE_CELLS_WIDE * GRID_CELL_SIZE_M) + GRID_CELL_SIZE_M * 2;
        newY = rightmostModule.y || 0;
      } else {
        newX = (DEFAULT_MODULE_CELLS_WIDE * GRID_CELL_SIZE_M + GRID_CELL_SIZE_M * 2) * modulesOnly.length;
      }
    }
    setModulePlacementCoords({ worldX: newX, worldY: newY });
    setIsTemplatePanelOpen(true);
    setSelectedObjectId(null);
    closeContextMenu();
  }, [objectsOnCurrentFloor, closeContextMenu, GRID_CELL_SIZE_M]);

  const addNewModuleViaContextMenu = useCallback((worldX, worldY) => {
    if (activeMode !== MODES.MODULAR) return;
    openTemplateSelectionPanel({ worldX, worldY });
  }, [activeMode, openTemplateSelectionPanel]);

  const handleAiGeneratedModules = useCallback((aiModules, notes) => {
    if (!aiModules || !Array.isArray(aiModules) || aiModules.length === 0) {
      toast.info(notes || "ИИ не сгенерировал модули или вернул пустой результат.");
      return;
    }
    setProjectObjects(prev => {
      let currentFloorObjects = [...(prev[currentFloorId] || [])];
      const newModulesToAdd = [];
      let firstNewModuleId = null;
      for (const aiModuleData of aiModules) {
        const moduleConfig = {
          posX: parseFloat(aiModuleData.posX) || 0,
          posY: parseFloat(aiModuleData.posY) || 0,
          cellsWide: parseInt(aiModuleData.cellsWide) || DEFAULT_MODULE_CELLS_WIDE,
          cellsLong: parseInt(aiModuleData.cellsLong) || DEFAULT_MODULE_CELLS_LONG,
          label: aiModuleData.label || `AI Модуль`,
          internalWallSegments: aiModuleData.internalWallSegments || {},
          predefinedElements: aiModuleData.predefinedElements || [],
          rotation: parseInt(aiModuleData.rotation) || 0,
          mirroredX: aiModuleData.mirroredX === true,
        };
        moduleConfig.posX = Math.round(moduleConfig.posX / GRID_CELL_SIZE_M) * GRID_CELL_SIZE_M;
        moduleConfig.posY = Math.round(moduleConfig.posY / GRID_CELL_SIZE_M) * GRID_CELL_SIZE_M;
        const newModule = createNewModule(moduleConfig);
        let canPlaceModule = true;
        const modulesToCheckOverlap = [...currentFloorObjects, ...newModulesToAdd];
        for (const existingModule of modulesToCheckOverlap) {
          if (checkOverlapWithRotation(newModule, existingModule)) {
            canPlaceModule = false;
            toast.warn(`Модуль "${newModule.label}" от ИИ (${newModule.id.slice(-4)}) пересекается и не будет добавлен.`);
            break;
          }
        }
        if (canPlaceModule) {
          newModulesToAdd.push(newModule);
          if (!firstNewModuleId) firstNewModuleId = newModule.id;
        }
      }
      if (newModulesToAdd.length > 0) {
        if (firstNewModuleId) setSelectedObjectId(firstNewModuleId);
        return { ...prev, [currentFloorId]: [...currentFloorObjects, ...newModulesToAdd] };
      }
      return prev;
    });
    if (notes) toast.info(`Заметки от ИИ: ${notes}`, { autoClose: 7000 });
  }, [currentFloorId, createNewModule, GRID_CELL_SIZE_M]);

  const handleToggleWallSegment = useCallback(
    (moduleId, cellX, cellY, orientation, segmentIdToToggle) => {
      setProjectObjects(prevProjectObjects => {
        const currentFloorObjects = prevProjectObjects[currentFloorId] || [];
        const newFloorObjects = currentFloorObjects.map((obj) => {
          if (obj.id === moduleId && obj.type === OBJECT_TYPES.MODULE) {
            const newModule = { ...obj, wallSegments: { ...obj.wallSegments } };
            const segmentKey = `${cellX},${cellY}_${orientation}`;
            let isPerimeter = false;
            if (orientation === "h" && (cellY === 0 || cellY === newModule.cellsLong)) isPerimeter = true;
            if (orientation === "v" && (cellX === 0 || cellX === newModule.cellsWide)) isPerimeter = true;
            if (newModule.wallSegments[segmentKey]) {
              if (newModule.wallSegments[segmentKey].isDocked) { toast.warn("Нельзя удалить стыковочную стену этим способом."); return obj;}
              if (isPerimeter) { toast.warn("Периметральные стены не могут быть удалены."); return obj; }
              if (newModule.wallSegments[segmentKey].elements && newModule.wallSegments[segmentKey].elements.length > 0) {
                toast.warn("Нельзя удалить стену с элементами. Сначала удалите элементы."); return obj;
              }
              const wallIdToDelete = newModule.wallSegments[segmentKey].id;
              delete newModule.wallSegments[segmentKey];
              if (selectedObjectId === wallIdToDelete) setSelectedObjectId(null);
            } else if (!isPerimeter) {
              newModule.wallSegments[segmentKey] = { id: generateId("wall_"), elements: [], thickness: WALL_THICKNESS_M_RENDER, isDocked: false, renderOffset: 0, isPassageWithPartner: false, isFullyOpenPassage: false, partnerSegmentId: null, partnerModuleId: null, wasPartnerModuleId: null, wasRenderOffset: null };
            }
            return newModule;
          }
          return obj;
        });
        return { ...prevProjectObjects, [currentFloorId]: newFloorObjects };
      });
      closeContextMenu();
    },
    [selectedObjectId, closeContextMenu, currentFloorId]
  );

  const deleteWallSegment = useCallback(
    (moduleId, segmentKey) => {
      setProjectObjects(prevProjectObjects => {
        const currentFloorObjects = prevProjectObjects[currentFloorId] || [];
        const newFloorObjects = currentFloorObjects.map((obj) => {
          if (obj.id === moduleId && obj.type === OBJECT_TYPES.MODULE) {
            const newModule = { ...obj, wallSegments: { ...obj.wallSegments } };
            const segment = newModule.wallSegments[segmentKey];
            if (!segment) return obj;
            if (segment.isDocked) { toast.warn("Нельзя удалить стыковочную стену этим способом. Используйте управление стыком."); return obj;}
            const [coords, orientation] = segmentKey.split("_");
            const cellX = parseInt(coords.split(",")[0]);
            const cellY = parseInt(coords.split(",")[1]);
            let isPerimeter = false;
            if (orientation === "h" && (cellY === 0 || cellY === newModule.cellsLong)) isPerimeter = true;
            if (orientation === "v" && (cellX === 0 || cellX === newModule.cellsWide)) isPerimeter = true;
            if (isPerimeter) { toast.warn("Периметральные стены модуля не могут быть удалены этим способом."); return obj; }
            if (segment.elements && segment.elements.length > 0) { toast.warn("Нельзя удалить стену с элементами. Сначала удалите элементы."); return obj; }
            const wallIdToDelete = segment.id;
            delete newModule.wallSegments[segmentKey];
            if (selectedObjectId === wallIdToDelete) setSelectedObjectId(null);
            return newModule;
          }
          return obj;
        });
        return { ...prevProjectObjects, [currentFloorId]: newFloorObjects };
      });
      closeContextMenu();
    },
    [selectedObjectId, closeContextMenu, currentFloorId]
  );

  const handleElementSelectionFromPanel = useCallback((type) => {
    setElementTypeToPlace(prevType => prevType === type ? null : type);
    setSelectedObjectId(null);
    closeContextMenu();
  }, [closeContextMenu]);

  const addElementToWall = useCallback(
    (elementType, targetModuleId, targetSegmentKey, initialProperties = {}) => {
      setProjectObjects(prevProjectObjects => {
        const currentFloorObjects = prevProjectObjects[currentFloorId] || [];
        const newFloorObjects = currentFloorObjects.map((obj) => {
          if (obj.id === targetModuleId && obj.type === OBJECT_TYPES.MODULE) {
            const newModule = { ...obj, wallSegments: { ...obj.wallSegments } };
            const segment = newModule.wallSegments[targetSegmentKey];
            if (segment) {
              if(segment.isPassageWithPartner && segment.thickness < WALL_THICKNESS_M_RENDER / 2 || segment.isFullyOpenPassage) {
                toast.error("Нельзя добавить элемент в объединенный или полностью открытый проем.");
                return obj;
              }
              if(elementType !== OBJECT_TYPES.DOOR && elementType !== OBJECT_TYPES.WINDOW && elementType !== OBJECT_TYPES.PANORAMIC_WINDOW) {
                  const hasWindowOrDoor = segment.elements?.some(el => el.type === OBJECT_TYPES.DOOR || el.type === OBJECT_TYPES.WINDOW || el.type === OBJECT_TYPES.PANORAMIC_WINDOW);
                  if (hasWindowOrDoor) {
                      toast.error("Нельзя добавить аксессуар на стену с окном или дверью.");
                      return obj;
                  }
              }

              const elementDefaults = defaultObjectSizes[elementType];
              let elementWidth = initialProperties.width || elementDefaults.width;
              let positionOnSegment = initialProperties.positionOnSegment || 0.5;

              const isFullSegmentWidthElementType = (elementType === OBJECT_TYPES.DOOR || elementType === OBJECT_TYPES.WINDOW);
              if (isFullSegmentWidthElementType) {
                elementWidth = GRID_CELL_SIZE_M; 
                positionOnSegment = 0.5;
              }
              
              let isPlaceable = elementDefaults && elementWidth <= GRID_CELL_SIZE_M + EPSILON;
              if (elementType === OBJECT_TYPES.DOOR || elementType === OBJECT_TYPES.WINDOW || elementType === OBJECT_TYPES.PANORAMIC_WINDOW) {
                isPlaceable = isPlaceable && (!segment.elements || segment.elements.filter(el =>
                  el.type === OBJECT_TYPES.DOOR || el.type === OBJECT_TYPES.WINDOW || el.type === OBJECT_TYPES.PANORAMIC_WINDOW).length === 0);
              }
              if (!isPlaceable) {
                toast.error("Невозможно разместить элемент на этом сегменте стены.");
                return obj;
              }
              const newElement = {
                id: generateId(`${elementType}_`), type: elementType,
                positionOnSegment: positionOnSegment,
                width: elementWidth,
                ...(elementType === OBJECT_TYPES.DOOR && { hingeSide: "left" }), // isOpen и openingAngle убраны, т.к. дверь всегда открыта
                ...(elementType === OBJECT_TYPES.WINDOW && { height: elementDefaults.height }),
                ...(elementType === OBJECT_TYPES.PANORAMIC_WINDOW && { height: elementDefaults.height }),
                ...(elementType === OBJECT_TYPES.RADIATOR && { height: elementDefaults.height }),
                ...(elementType === OBJECT_TYPES.KITCHEN_ELEMENT && { height: elementDefaults.height, depth: elementDefaults.depth }),
                ...initialProperties,
                width: elementWidth, 
                positionOnSegment: positionOnSegment,
              };
              if (!segment.elements) segment.elements = [];
              segment.elements.push(newElement);
              newModule.wallSegments[targetSegmentKey] = segment;
              setSelectedObjectId(newElement.id);
              return newModule;
            }
          }
          return obj;
        });
        return { ...prevProjectObjects, [currentFloorId]: newFloorObjects };
      });
      setElementTypeToPlace(null);
      closeContextMenu();
    },
    [closeContextMenu, currentFloorId, GRID_CELL_SIZE_M, EPSILON]
  );

  const handleWallSegmentClickForPlacement = useCallback((segmentId) => {
    if (!elementTypeToPlace) return;
    const segmentObject = getObjectById(segmentId);
    if (segmentObject && segmentObject.type === OBJECT_TYPES.WALL_SEGMENT) {
      if ((segmentObject.isPassageWithPartner && segmentObject.thickness < WALL_THICKNESS_M_RENDER / 2) || segmentObject.isFullyOpenPassage){
         toast.error("Нельзя разместить элемент в объединенном или полностью открытом проеме.");
         setElementTypeToPlace(null);
         return;
      }
      if(elementTypeToPlace !== OBJECT_TYPES.DOOR && elementTypeToPlace !== OBJECT_TYPES.WINDOW && elementTypeToPlace !== OBJECT_TYPES.PANORAMIC_WINDOW) {
          const hasWindowOrDoor = segmentObject.elements?.some(el => el.type === OBJECT_TYPES.DOOR || el.type === OBJECT_TYPES.WINDOW || el.type === OBJECT_TYPES.PANORAMIC_WINDOW);
          if (hasWindowOrDoor) {
              toast.error("Нельзя добавить аксессуар на стену с окном или дверью.");
              setElementTypeToPlace(null);
              return;
          }
      }
      const { parentModule, segmentKey } = segmentObject;
      addElementToWall(elementTypeToPlace, parentModule.id, segmentKey);
    } else {
      setElementTypeToPlace(null);
    }
  }, [elementTypeToPlace, getObjectById, addElementToWall]);

  const updateSelectedObjectProperty = useCallback(
    (key, value) => {
      if (!selectedObjectId || !primarySelectedObject) return;
      setElementTypeToPlace(null);
      const numericProps = ["x", "y", "width", "height", "rotation", "openingAngle", "positionOnSegment", "thickness", "renderOffset", "depth"];
      let processedValue = value;
      if (numericProps.includes(key)) {
        processedValue = parseFloat(value);
        if (isNaN(processedValue)) {
          if (value === "" && (key === "x" || key === "y" || key === "rotation" || key === "thickness" || key === "renderOffset" || key === "depth")) processedValue = 0;
          else return;
        }
      } else if (typeof value === "string" && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        processedValue = value.toLowerCase() === "true";
      }
      
      if (
          (primarySelectedObject.type === OBJECT_TYPES.DOOR || primarySelectedObject.type === OBJECT_TYPES.WINDOW) &&
          (key === "width" || key === "positionOnSegment")
         ) {
          toast.info(`Свойство '${key}' для этого типа элемента управляется автоматически.`);
          return;
      }

      setProjectObjects(prevProjectObjects => {
        const currentFloorObjects = prevProjectObjects[currentFloorId] || [];
        const newFloorObjects = currentFloorObjects.map((obj) => {
          if (obj.id === selectedObjectId && obj.type === OBJECT_TYPES.MODULE) {
            if (key === "label") return { ...obj, [key]: processedValue };
            if (key === "rotation") {
              processedValue = (Math.round(processedValue / 90) * 90) % 360;
              if (processedValue < 0) processedValue += 360;
            }
            return { ...obj, [key]: processedValue };
          }
          if (primarySelectedObject.parentModule?.id && obj.id === primarySelectedObject.parentModule.id && obj.type === OBJECT_TYPES.MODULE) {
            const newModule = { ...obj, wallSegments: { ...obj.wallSegments } };
            let changed = false;
            if (primarySelectedObject.segmentKey && newModule.wallSegments[primarySelectedObject.segmentKey]) {
              const segment = newModule.wallSegments[primarySelectedObject.segmentKey];
              if (primarySelectedObject.type === OBJECT_TYPES.WALL_SEGMENT && segment.id === selectedObjectId) {
                 if ((key === "thickness" || key === "renderOffset") && !segment.isFullyOpenPassage && !segment.isDocked) {
                  changed = true;
                  newModule.wallSegments[primarySelectedObject.segmentKey] = { ...segment, [key]: processedValue };
                }
              } else {
                const newElements = (segment.elements || []).map((el) => {
                  if (el.id === selectedObjectId) {
                    changed = true; return { ...el, [key]: processedValue };
                  }
                  return el;
                });
                if (changed) newModule.wallSegments[primarySelectedObject.segmentKey] = { ...segment, elements: newElements };
              }
            }
            return changed ? newModule : obj;
          }
          return obj;
        });
        return { ...prevProjectObjects, [currentFloorId]: newFloorObjects };
      });
    },
    [selectedObjectId, primarySelectedObject, currentFloorId]
  );

  const updateModulePosition = useCallback((moduleId, newX, newY) => {
    setProjectObjects(prev => ({
      ...prev,
      [currentFloorId]: (prev[currentFloorId] || []).map(obj =>
        obj.id === moduleId && obj.type === OBJECT_TYPES.MODULE ? { ...obj, x: newX, y: newY } : obj
      )
    }));
  }, [currentFloorId]);

  const snapAndFinalizeModulePosition = useCallback(
    (moduleId, originalModuleX, originalModuleY, originalModuleRotation) => {
      setProjectObjects(prevProjectObjects => {
        let currentFloorObjects = [...(prevProjectObjects[currentFloorId] || [])];
        const moduleToFinalizeIndex = currentFloorObjects.findIndex(obj => obj.id === moduleId && obj.type === OBJECT_TYPES.MODULE);
        if (moduleToFinalizeIndex === -1) return prevProjectObjects;

        let moduleToFinalize = currentFloorObjects[moduleToFinalizeIndex];

        const snappedX = GRID_CELL_SIZE_M > 0 ? Math.round(moduleToFinalize.x / GRID_CELL_SIZE_M) * GRID_CELL_SIZE_M : moduleToFinalize.x;
        const snappedY = GRID_CELL_SIZE_M > 0 ? Math.round(moduleToFinalize.y / GRID_CELL_SIZE_M) * GRID_CELL_SIZE_M : moduleToFinalize.y;

        const potentialMovedModuleState = {
          ...moduleToFinalize,
          x: snappedX,
          y: snappedY,
        };

        const otherModules = currentFloorObjects.filter(
          obj => obj.id !== moduleId && obj.type === OBJECT_TYPES.MODULE
        );

        let isOverlapping = false;
        for (const otherModule of otherModules) {
          if (checkOverlapWithRotation(potentialMovedModuleState, otherModule)) {
            isOverlapping = true;
            break;
          }
        }

        let finalX, finalY, finalRotation;
        let hasMovedSignificantly = false;

        if (isOverlapping) {
          toast.warn("Перемещение невозможно: модули пересекаются. Модуль возвращен и выровнен.");
          finalX = originalModuleX;
          finalY = originalModuleY;
          finalRotation = originalModuleRotation;
        } else {
          finalX = snappedX;
          finalY = snappedY;
          finalRotation = moduleToFinalize.rotation || 0;
          if (Math.abs(finalX - originalModuleX) > EPSILON ||
              Math.abs(finalY - originalModuleY) > EPSILON ||
              Math.abs(finalRotation - originalModuleRotation) > EPSILON ) {
            hasMovedSignificantly = true;
          }
        }

        moduleToFinalize = { ...moduleToFinalize, x: finalX, y: finalY, rotation: finalRotation };
        currentFloorObjects[moduleToFinalizeIndex] = moduleToFinalize;

        if (hasMovedSignificantly || isOverlapping) {
            const modulesPreviouslyDockedWithMoved = [];
            (prevProjectObjects[currentFloorId] || []).forEach(prevModule => {
                if (prevModule.type === OBJECT_TYPES.MODULE && prevModule.id !== moduleId) {
                    for (const segKey in prevModule.wallSegments) {
                        if (prevModule.wallSegments[segKey].partnerModuleId === moduleId) {
                            modulesPreviouslyDockedWithMoved.push(prevModule.id);
                            break;
                        }
                    }
                }
            });

            const allModulesToResetDocking = [moduleId, ...modulesPreviouslyDockedWithMoved];
            allModulesToResetDocking.forEach(modIdToReset => {
                const moduleInstanceIndex = currentFloorObjects.findIndex(m => m.id === modIdToReset);
                if (moduleInstanceIndex !== -1) {
                    const moduleInstance = currentFloorObjects[moduleInstanceIndex];
                    const newWallSegments = { ...moduleInstance.wallSegments };
                    let changed = false;
                    for (const segmentKey in newWallSegments) {
                        const segment = newWallSegments[segmentKey];
                        if (segment.isDocked || segment.isPassageWithPartner) {
                            newWallSegments[segmentKey] = {
                                ...segment,
                                thickness: WALL_THICKNESS_M_RENDER,
                                renderOffset: 0,
                                isDocked: false,
                                isPassageWithPartner: false,
                                partnerModuleId: null,
                                partnerSegmentId: null,
                                wasPartnerModuleId: segment.isFullyOpenPassage ? segment.wasPartnerModuleId : null,
                                wasRenderOffset: segment.isFullyOpenPassage ? segment.wasRenderOffset : null,
                            };
                            if (hasMovedSignificantly && segment.isFullyOpenPassage && segment.wasPartnerModuleId === (modIdToReset === moduleId ? modulesPreviouslyDockedWithMoved[0] : moduleId) ){
                                newWallSegments[segmentKey].isFullyOpenPassage = false;
                            }
                            changed = true;
                        }
                    }
                    if (changed) {
                        currentFloorObjects[moduleInstanceIndex] = { ...moduleInstance, wallSegments: newWallSegments };
                    }
                }
            });
        }

        let movedModuleAfterReset = currentFloorObjects.find(obj => obj.id === moduleId && obj.type === OBJECT_TYPES.MODULE);
        if (!movedModuleAfterReset) return prevProjectObjects;

        const updateWallSegmentInCurrentObjects = (targetModuleId, segmentKey, updates) => {
            const targetModuleIndex = currentFloorObjects.findIndex(m => m.id === targetModuleId);
            if (targetModuleIndex !== -1 && currentFloorObjects[targetModuleIndex].wallSegments[segmentKey]) {
                const targetModule = currentFloorObjects[targetModuleIndex];
                const updatedWallSegments = {
                    ...targetModule.wallSegments,
                    [segmentKey]: {
                        ...targetModule.wallSegments[segmentKey],
                        ...updates,
                    }
                };
                if(updates.isDocked && updatedWallSegments[segmentKey].isFullyOpenPassage){
                    updatedWallSegments[segmentKey].isFullyOpenPassage = false;
                    updatedWallSegments[segmentKey].wasPartnerModuleId = null;
                    updatedWallSegments[segmentKey].wasRenderOffset = null;
                }
                currentFloorObjects[targetModuleIndex] = { ...targetModule, wallSegments: updatedWallSegments };
            }
        };

        const otherModulesForDocking = currentFloorObjects.filter(
          obj => obj.id !== moduleId && obj.type === OBJECT_TYPES.MODULE
        );

        const checkAndApplyDockingBetweenFaces = (
            mModule, oModule,
            mFaceDef, oFaceDef
        ) => {
            const vertsM = getModuleVertices(mModule);
            const vertsO = getModuleVertices(oModule);
            const mP1 = vertsM[mFaceDef.indices[0]];
            const mP2 = vertsM[mFaceDef.indices[1]];
            const oP1 = vertsO[oFaceDef.indices[0]];
            const oP2 = vertsO[oFaceDef.indices[1]];
            const dirM = normalizeVector(subtractVectors(mP2, mP1));
            const dirO = normalizeVector(subtractVectors(oP2, oP1));
            if (Math.abs(dotProduct(dirM, dirO)) < 0.99) return; 
            if (dotProduct(dirM, dirO) > -0.99) return; 
            const normalToLineM = { x: -dirM.y, y: dirM.x };
            const distO1ToLineM = Math.abs(dotProduct(subtractVectors(oP1, mP1), normalToLineM));
            if (distO1ToLineM > EPSILON * 10) return; 
            const val_m1_proj = 0;
            const val_m2_proj = distance(mP1, mP2);
            const val_o1_proj = dotProduct(subtractVectors(oP1, mP1), dirM);
            const val_o2_proj = dotProduct(subtractVectors(oP2, mP1), dirM);
            const overlap_start_proj = Math.max(Math.min(val_m1_proj, val_m2_proj), Math.min(val_o1_proj, val_o2_proj));
            const overlap_end_proj = Math.min(Math.max(val_m1_proj, val_m2_proj), Math.max(val_o1_proj, val_o2_proj));
            let overlapLength = overlap_end_proj - overlap_start_proj;
            if (overlapLength < GRID_CELL_SIZE_M - EPSILON) return; 
            const numOverlappingCellsStrict = Math.floor((overlapLength + EPSILON) / GRID_CELL_SIZE_M);
            const perfectlyAlignedOverlapLength = numOverlappingCellsStrict * GRID_CELL_SIZE_M;
            if (Math.abs(overlapLength - perfectlyAlignedOverlapLength) > GRID_CELL_SIZE_M * 0.1 || numOverlappingCellsStrict === 0) return;
            overlapLength = perfectlyAlignedOverlapLength;
            const world_overlap_start_point = { x: mP1.x + dirM.x * overlap_start_proj, y: mP1.y + dirM.y * overlap_start_proj };
            const mFaceExtentDimCells = mFaceDef.getExtent(mModule);
            const oFaceExtentDimCells = oFaceDef.getExtent(oModule);
            const dist_mP1_to_overlap_start = dotProduct(subtractVectors(world_overlap_start_point, mP1), dirM);
            let firstCellIndexM = Math.round(dist_mP1_to_overlap_start / GRID_CELL_SIZE_M);
            firstCellIndexM = Math.max(0, Math.min(firstCellIndexM, mFaceExtentDimCells - numOverlappingCellsStrict));
            const dist_oP1_to_overlap_start = dotProduct(subtractVectors(world_overlap_start_point, oP1), dirO); 
            let firstCellIndexO = Math.round(dist_oP1_to_overlap_start / GRID_CELL_SIZE_M);
            firstCellIndexO = Math.max(0, Math.min(firstCellIndexO, oFaceExtentDimCells - numOverlappingCellsStrict));

            for (let k = 0; k < numOverlappingCellsStrict; k++) {
                let m_iter_idx = firstCellIndexM + k;
                let o_iter_idx = firstCellIndexO + (numOverlappingCellsStrict - 1 - k);
                const actual_m_cell_idx = mFaceDef.mapsKDirectly ? m_iter_idx : (mFaceExtentDimCells - 1 - m_iter_idx);
                const actual_o_cell_idx = oFaceDef.mapsKDirectly ? o_iter_idx : (oFaceExtentDimCells - 1 - o_iter_idx);
                if (actual_m_cell_idx < 0 || actual_m_cell_idx >= mFaceExtentDimCells || actual_o_cell_idx < 0 || actual_o_cell_idx >= oFaceExtentDimCells) continue;
                const currentMovedSegKey = mFaceDef.getSegKey(actual_m_cell_idx, mModule);
                const currentOtherSegKey = oFaceDef.getSegKey(actual_o_cell_idx, oModule);
                const mModuleInstance = currentFloorObjects.find(mod => mod.id === mModule.id);
                const oModuleInstance = currentFloorObjects.find(mod => mod.id === oModule.id);
                if(!mModuleInstance || !oModuleInstance) continue;
                const movedWallSegment = mModuleInstance.wallSegments[currentMovedSegKey];
                const otherWallSegment = oModuleInstance.wallSegments[currentOtherSegKey];
                if (!movedWallSegment || !otherWallSegment) continue;
                if (movedWallSegment.isFullyOpenPassage || otherWallSegment.isFullyOpenPassage) continue;
                const originalMModuleState = (prevProjectObjects[currentFloorId] || []).find(m => m.id === mModule.id);
                const originalOModuleState = (prevProjectObjects[currentFloorId] || []).find(m => m.id === oModule.id);
                if (!originalMModuleState || !originalOModuleState) continue;
                const originalMovedWall = originalMModuleState.wallSegments[currentMovedSegKey];
                const originalOtherWall = originalOModuleState.wallSegments[currentOtherSegKey];
                const passageStateToPreserve = originalMovedWall && originalMovedWall.isPassageWithPartner && originalOtherWall && originalOtherWall.isPassageWithPartner && !originalMovedWall.isFullyOpenPassage && !originalOtherWall.isFullyOpenPassage && originalMovedWall.partnerModuleId === oModule.id && originalOtherWall.partnerModuleId === mModule.id && originalMovedWall.partnerSegmentId === (originalOtherWall ? originalOtherWall.id : null) && originalOtherWall.partnerSegmentId === (originalMovedWall ? originalMovedWall.id : null) && !isOverlapping;
                updateWallSegmentInCurrentObjects(mModule.id, currentMovedSegKey, { thickness: passageStateToPreserve ? WALL_THICKNESS_M_RENDER : DOCKED_SPLIT_WALL_THICKNESS_M, renderOffset: passageStateToPreserve ? 0 : mFaceDef.getOffsetSign() * DOCKED_SPLIT_WALL_OFFSET_M, isDocked: true, isPassageWithPartner: passageStateToPreserve, partnerModuleId: oModule.id, partnerSegmentId: otherWallSegment.id });
                const potentiallyUpdatedMovedWallSegment = currentFloorObjects.find(mod => mod.id === mModule.id)?.wallSegments[currentMovedSegKey];
                if(!potentiallyUpdatedMovedWallSegment) continue;
                updateWallSegmentInCurrentObjects(oModule.id, currentOtherSegKey, { thickness: passageStateToPreserve ? WALL_THICKNESS_M_RENDER : DOCKED_SPLIT_WALL_THICKNESS_M, renderOffset: passageStateToPreserve ? 0 : oFaceDef.getOffsetSign() * DOCKED_SPLIT_WALL_OFFSET_M, isDocked: true, isPassageWithPartner: passageStateToPreserve, partnerModuleId: mModule.id, partnerSegmentId: potentiallyUpdatedMovedWallSegment.id });
            }
        };

        for (const otherModule of otherModulesForDocking) {
            let currentMovedModule = currentFloorObjects.find(m => m.id === moduleId);
            if (!currentMovedModule) break; 
            let currentOtherModule = currentFloorObjects.find(m => m.id === otherModule.id);
            if (!currentOtherModule) continue;
            for (const mFaceDef of faceDefinitions) {
                if (!currentMovedModule) break;
                for (const oFaceDef of faceDefinitions) {
                    if (!currentMovedModule || !currentOtherModule) break; 
                    checkAndApplyDockingBetweenFaces( currentMovedModule, currentOtherModule, mFaceDef, oFaceDef );
                    currentMovedModule = currentFloorObjects.find(m => m.id === moduleId);
                    if (!currentMovedModule) break;
                    currentOtherModule = currentFloorObjects.find(m => m.id === otherModule.id); 
                    if (!currentOtherModule) break;
                }
                if (!currentMovedModule || !currentOtherModule) break;
            }
            if (!currentMovedModule) break;
        }
        return { ...prevProjectObjects, [currentFloorId]: currentFloorObjects };
      });
    },
    [currentFloorId, GRID_CELL_SIZE_M, WALL_THICKNESS_M_RENDER, DOCKED_SPLIT_WALL_THICKNESS_M, DOCKED_SPLIT_WALL_OFFSET_M, EPSILON]
  );

  const setDockedLinePassageState = useCallback((clickedSegmentObject, makePassage) => {
    if (!clickedSegmentObject || !clickedSegmentObject.isDocked || !clickedSegmentObject.parentModule) return;
    const { parentModule, segmentKey: clickedSegmentKey } = clickedSegmentObject;
    const [coords, orientation] = clickedSegmentObject.segmentKey.split("_");
    setProjectObjects(prev => {
        let processedObjects = [...(prev[currentFloorId] || [])];
        const updateWallProperties = (moduleId, segKey, passageState) => {
            processedObjects = processedObjects.map(m => {
                if (m.id === moduleId && m.wallSegments[segKey]) {
                    const segment = m.wallSegments[segKey];
                    let newThickness = passageState ? WALL_THICKNESS_M_RENDER : DOCKED_SPLIT_WALL_THICKNESS_M;
                    let newRenderOffset = 0;
                    if (!passageState) {
                        const thisModule = processedObjects.find(mod => mod.id === moduleId);
                        if (thisModule) {
                            const [cellIndicesStr, wallOrientation] = segKey.split("_");
                            const [cellXStr, cellYStr] = cellIndicesStr.split(",");
                            const cellX = parseInt(cellXStr); const cellY = parseInt(cellYStr);
                            let relevantFaceDef = null;
                            if (wallOrientation === 'h') { if (cellY === 0) relevantFaceDef = faceDefinitions.find(fd => fd.name === "Top"); else if (cellY === thisModule.cellsLong) relevantFaceDef = faceDefinitions.find(fd => fd.name === "Bottom");
                            } else { if (cellX === 0) relevantFaceDef = faceDefinitions.find(fd => fd.name === "Left"); else if (cellX === thisModule.cellsWide) relevantFaceDef = faceDefinitions.find(fd => fd.name === "Right"); }
                            if(relevantFaceDef) newRenderOffset = relevantFaceDef.getOffsetSign() * DOCKED_SPLIT_WALL_OFFSET_M;
                            else newRenderOffset = segment.wasRenderOffset !== null ? segment.wasRenderOffset : DOCKED_SPLIT_WALL_OFFSET_M;
                        } else newRenderOffset = segment.wasRenderOffset !== null ? segment.wasRenderOffset : DOCKED_SPLIT_WALL_OFFSET_M;
                    }
                    return { ...m, wallSegments: { ...m.wallSegments, [segKey]: { ...segment, isPassageWithPartner: passageState, isFullyOpenPassage: false, elements: passageState ? [] : (segment.elements || []), thickness: newThickness, renderOffset: newRenderOffset, wasRenderOffset: passageState ? segment.renderOffset : segment.wasRenderOffset, } } };
                }
                return m;
            });
        };
        const moduleInstance = processedObjects.find(m => m.id === parentModule.id);
        if(!moduleInstance) return prev;
        const cellsDimension = orientation === 'v' ? moduleInstance.cellsLong : moduleInstance.cellsWide;
        for (let i = 0; i < cellsDimension; i++) {
            const currentSegKey = orientation === 'v' ? `${coords.split(",")[0]},${i}_v` : `${i},${coords.split(",")[1]}_h`;
            const currentSegment = moduleInstance.wallSegments[currentSegKey];
            if (currentSegment && currentSegment.isDocked && currentSegment.partnerModuleId === (clickedSegmentObject.partnerModuleId || clickedSegmentObject.wasPartnerModuleId)) {
                updateWallProperties(moduleInstance.id, currentSegKey, makePassage);
                if(currentSegment.partnerModuleId && currentSegment.partnerSegmentId){
                    const partnerModule = processedObjects.find(pM => pM.id === currentSegment.partnerModuleId);
                    if (partnerModule) {
                        const partnerSegData = Object.entries(partnerModule.wallSegments).find(([,seg]) => seg.id === currentSegment.partnerSegmentId);
                        if (partnerSegData) { const partnerSegKey = partnerSegData[0]; updateWallProperties(currentSegment.partnerModuleId, partnerSegKey, makePassage); }
                    }
                }
            }
        }
        return { ...prev, [currentFloorId]: processedObjects };
    });
    closeContextMenu();
  }, [currentFloorId, closeContextMenu, WALL_THICKNESS_M_RENDER, DOCKED_SPLIT_WALL_THICKNESS_M]);

  const setDockedWallsDeletedState = useCallback((clickedSegmentObject, makeOpenPassage) => {
    if (!clickedSegmentObject || !clickedSegmentObject.isDocked || !clickedSegmentObject.parentModule) return;
    const { parentModule, segmentKey: clickedSegmentKey } = clickedSegmentObject;
    const [coords, orientation] = clickedSegmentObject.segmentKey.split("_");
    setProjectObjects(prev => {
        let processedObjects = [...(prev[currentFloorId] || [])];
        const updateWallPropertiesForOpenPassage = (moduleId, segKey, isOpen) => {
            processedObjects = processedObjects.map(m => {
                if (m.id === moduleId && m.wallSegments[segKey]) {
                    const segment = m.wallSegments[segKey];
                    let newThickness, newRenderOffset, newIsPassagePartner, currentPartnerId = segment.partnerModuleId, currentWasPartnerId = segment.wasPartnerModuleId, newWasRenderOffset = segment.wasRenderOffset;
                    if (isOpen) { newThickness = 0.001; newRenderOffset = 0; newIsPassagePartner = false; currentWasPartnerId = segment.partnerModuleId; newWasRenderOffset = (segment.isDocked && !segment.isPassageWithPartner && !segment.isFullyOpenPassage) ? segment.renderOffset : null;
                    } else {
                        newThickness = DOCKED_SPLIT_WALL_THICKNESS_M; newIsPassagePartner = false; currentPartnerId = segment.wasPartnerModuleId;
                        const thisModule = processedObjects.find(mod => mod.id === moduleId);
                        if (thisModule) {
                            const [cellIndicesStr, wallOrientation] = segKey.split("_"); const [cellXStr, cellYStr] = cellIndicesStr.split(","); const cellX = parseInt(cellXStr); const cellY = parseInt(cellYStr);
                            let relevantFaceDef = null;
                            if (wallOrientation === 'h') { if (cellY === 0) relevantFaceDef = faceDefinitions.find(fd => fd.name === "Top"); else if (cellY === thisModule.cellsLong) relevantFaceDef = faceDefinitions.find(fd => fd.name === "Bottom");
                            } else { if (cellX === 0) relevantFaceDef = faceDefinitions.find(fd => fd.name === "Left"); else if (cellX === thisModule.cellsWide) relevantFaceDef = faceDefinitions.find(fd => fd.name === "Right"); }
                            if(relevantFaceDef) newRenderOffset = relevantFaceDef.getOffsetSign() * DOCKED_SPLIT_WALL_OFFSET_M;
                            else newRenderOffset = segment.wasRenderOffset !== null ? segment.wasRenderOffset : DOCKED_SPLIT_WALL_OFFSET_M;
                        } else newRenderOffset = segment.wasRenderOffset !== null ? segment.wasRenderOffset : DOCKED_SPLIT_WALL_OFFSET_M;
                        currentWasPartnerId = null; newWasRenderOffset = null;
                    }
                    return { ...m, wallSegments: { ...m.wallSegments, [segKey]: { ...segment, isFullyOpenPassage: isOpen, isPassageWithPartner: newIsPassagePartner, elements: [], thickness: newThickness, renderOffset: newRenderOffset, partnerModuleId: currentPartnerId, wasPartnerModuleId: currentWasPartnerId, wasRenderOffset: newWasRenderOffset, } } };
                }
                return m;
            });
        };
        const moduleInstance = processedObjects.find(m => m.id === parentModule.id);
        if(!moduleInstance) return prev;
        const cellsDimension = orientation === 'v' ? moduleInstance.cellsLong : moduleInstance.cellsWide;
        for (let i = 0; i < cellsDimension; i++) {
            const currentSegKey = orientation === 'v' ? `${coords.split(",")[0]},${i}_v` : `${i},${coords.split(",")[1]}_h`;
            const currentSegment = moduleInstance.wallSegments[currentSegKey];
            if (currentSegment && currentSegment.isDocked && currentSegment.partnerModuleId === (clickedSegmentObject.partnerModuleId || clickedSegmentObject.wasPartnerModuleId)) {
                const partnerIdToUpdate = makeOpenPassage ? currentSegment.partnerModuleId : currentSegment.wasPartnerModuleId;
                updateWallPropertiesForOpenPassage(moduleInstance.id, currentSegKey, makeOpenPassage);
                if(partnerIdToUpdate && currentSegment.partnerSegmentId){
                    const partnerModule = processedObjects.find(pM => pM.id === partnerIdToUpdate);
                    if (partnerModule) {
                        const partnerSegData = Object.entries(partnerModule.wallSegments).find(([,seg]) => seg.id === currentSegment.partnerSegmentId);
                        if (partnerSegData) { const partnerSegKey = partnerSegData[0]; updateWallPropertiesForOpenPassage(partnerIdToUpdate, partnerSegKey, makeOpenPassage); }
                    }
                }
            }
        }
        if (!makeOpenPassage) setSelectedObjectId(null); else setSelectedObjectId(clickedSegmentObject.id);
        return { ...prev, [currentFloorId]: processedObjects };
    });
    closeContextMenu();
    if (makeOpenPassage) toast.info("Стены на стыке удалены (создан проем)."); else toast.info("Стены на стыке восстановлены.");
  }, [currentFloorId, closeContextMenu, DOCKED_SPLIT_WALL_THICKNESS_M]);

  const undockModuleCompletely = useCallback((moduleIdToUndock, floorObjects) => {
    let updatedFloorObjects = [...floorObjects];
    const moduleToUndockIndex = updatedFloorObjects.findIndex(m => m.id === moduleIdToUndock);
    if (moduleToUndockIndex === -1) return floorObjects;
    const moduleToUndock = updatedFloorObjects[moduleToUndockIndex];
    const newModuleWallSegments = { ...moduleToUndock.wallSegments };
    let moduleChanged = false;
    for (const segKey in newModuleWallSegments) {
        const segment = newModuleWallSegments[segKey];
        if (segment.isDocked || segment.isPassageWithPartner || segment.isFullyOpenPassage) {
            const partnerModuleId = segment.partnerModuleId || segment.wasPartnerModuleId;
            const partnerSegmentId = segment.partnerSegmentId;
            newModuleWallSegments[segKey] = { ...segment, thickness: WALL_THICKNESS_M_RENDER, renderOffset: 0, isDocked: false, isPassageWithPartner: false, isFullyOpenPassage: false, partnerModuleId: null, partnerSegmentId: null, wasPartnerModuleId: null, wasRenderOffset: null, };
            moduleChanged = true;
            if (partnerModuleId) {
                const partnerModuleIndex = updatedFloorObjects.findIndex(m => m.id === partnerModuleId);
                if (partnerModuleIndex !== -1) {
                    const partnerModule = { ...updatedFloorObjects[partnerModuleIndex] };
                    const newPartnerWallSegments = { ...partnerModule.wallSegments };
                    let partnerChanged = false;
                    for (const pSegKey in newPartnerWallSegments) {
                        if (newPartnerWallSegments[pSegKey].partnerModuleId === moduleIdToUndock || (newPartnerWallSegments[pSegKey].id === partnerSegmentId && (newPartnerWallSegments[pSegKey].partnerModuleId === moduleIdToUndock || newPartnerWallSegments[pSegKey].wasPartnerModuleId === moduleIdToUndock))) {
                             newPartnerWallSegments[pSegKey] = { ...newPartnerWallSegments[pSegKey], thickness: WALL_THICKNESS_M_RENDER, renderOffset: 0, isDocked: false, isPassageWithPartner: false, isFullyOpenPassage: false, partnerModuleId: null, partnerSegmentId: null, wasPartnerModuleId: null, wasRenderOffset: null, };
                            partnerChanged = true;
                        }
                    }
                    if (partnerChanged) updatedFloorObjects[partnerModuleIndex] = { ...partnerModule, wallSegments: newPartnerWallSegments };
                }
            }
        }
    }
    if (moduleChanged) updatedFloorObjects[moduleToUndockIndex] = { ...moduleToUndock, wallSegments: newModuleWallSegments };
    return updatedFloorObjects;
  }, []);

  const handleMirrorModule = useCallback((moduleId, axis = 'horizontal') => {
      setProjectObjects(prev => {
          let currentFloorObjects = [...(prev[currentFloorId] || [])];
          const targetModuleIndex = currentFloorObjects.findIndex(obj => obj.id === moduleId && obj.type === OBJECT_TYPES.MODULE);
          if (targetModuleIndex === -1) return prev;
          currentFloorObjects = undockModuleCompletely(moduleId, currentFloorObjects);
          const moduleToMirror = { ...currentFloorObjects.find(m => m.id === moduleId) };
          const { cellsWide, cellsLong, wallSegments: oldWallSegments } = moduleToMirror;
          const newWallSegments = {};
          if (axis === 'horizontal') {
              moduleToMirror.mirroredX = !moduleToMirror.mirroredX;
              for (const oldKey in oldWallSegments) {
                  const segment = { ...oldWallSegments[oldKey], elements: [] };
                  const [coords, orientation] = oldKey.split("_");
                  let [x, y] = coords.split(",").map(Number);
                  let newKey;
                  if (orientation === 'h') { x = cellsWide - 1 - x; newKey = `${x},${y}_${orientation}`; } 
                  else { x = cellsWide - x; newKey = `${x},${y}_${orientation}`; }
                  oldWallSegments[oldKey].elements.forEach(el => {
                      const newEl = { ...el, positionOnSegment: 1 - el.positionOnSegment };
                      if (el.type === OBJECT_TYPES.DOOR) newEl.hingeSide = el.hingeSide === 'left' ? 'right' : 'left';
                      segment.elements.push(newEl);
                  });
                  newWallSegments[newKey] = segment;
              }
              moduleToMirror.wallSegments = newWallSegments;
          }
          currentFloorObjects[targetModuleIndex] = moduleToMirror;
          return { ...prev, [currentFloorId]: currentFloorObjects };
      });
      closeContextMenu();
      toast.info("Модуль отзеркален. Стыковки сброшены.");
  }, [currentFloorId, undockModuleCompletely, closeContextMenu]);

  const handleRotateModule = useCallback((moduleId) => {
    let moduleBeforeRotationData = null;
    let rotationHappenedSuccess = false;
    setProjectObjects(prev => {
        let currentFloorObjects = [...(prev[currentFloorId] || [])];
        const targetModuleIndex = currentFloorObjects.findIndex(obj => obj.id === moduleId && obj.type === OBJECT_TYPES.MODULE);
        if (targetModuleIndex === -1) return prev;
        const targetModuleOriginal = currentFloorObjects[targetModuleIndex];
        moduleBeforeRotationData = { x: targetModuleOriginal.x, y: targetModuleOriginal.y, rotation: targetModuleOriginal.rotation || 0 };
        currentFloorObjects = undockModuleCompletely(moduleId, currentFloorObjects);
        const targetModule = { ...currentFloorObjects.find(m => m.id === moduleId) };
        const currentRotation = targetModule.rotation || 0;
        const newRotation = (currentRotation + 90) % 360;
        const newRotationSanitized = newRotation < 0 ? newRotation + 360 : newRotation;
        const rotatedModuleAttempt = { ...targetModule, rotation: newRotationSanitized };
        const otherModulesOnFloor = currentFloorObjects.filter(other => other.id !== moduleId && other.type === OBJECT_TYPES.MODULE);
        let canRotate = true;
        for(const other of otherModulesOnFloor) { if (checkOverlapWithRotation(rotatedModuleAttempt, other)) { canRotate = false; break; } }
        if (canRotate) {
            rotationHappenedSuccess = true;
            const finalTargetModuleIndex = currentFloorObjects.findIndex(m => m.id === moduleId);
            currentFloorObjects[finalTargetModuleIndex] = rotatedModuleAttempt;
            return { ...prev, [currentFloorId]: currentFloorObjects };
        } else {
            toast.error("Поворот невозможен: модуль будет пересекаться с другим.");
            return { ...prev, [currentFloorId]: currentFloorObjects }; // Return currentFloorObjects even if rotation failed, as undocking happened
        }
    });
    if (rotationHappenedSuccess && moduleBeforeRotationData) {
        snapAndFinalizeModulePosition(moduleId, moduleBeforeRotationData.x, moduleBeforeRotationData.y, moduleBeforeRotationData.rotation );
    }
    closeContextMenu();
  }, [currentFloorId, snapAndFinalizeModulePosition, undockModuleCompletely, closeContextMenu]);

  const deleteSelectedObject = useCallback(() => {
    if (!selectedObjectId || !primarySelectedObject) return;
    const objectToDelete = primarySelectedObject;
    setProjectObjects(prevProjectObjects => {
      let currentFloorObjects = [...(prevProjectObjects[currentFloorId] || [])];
      if (objectToDelete.type === OBJECT_TYPES.MODULE) {
        currentFloorObjects = undockModuleCompletely(objectToDelete.id, currentFloorObjects);
        currentFloorObjects = currentFloorObjects.filter((obj) => obj.id !== objectToDelete.id);
      } else {
        const { parentModule, segmentKey } = objectToDelete;
        if (parentModule) {
          if (objectToDelete.type === OBJECT_TYPES.WALL_SEGMENT) {
            toast.warn("Для удаления сегмента стены используйте контекстное меню на стене.");
            return prevProjectObjects;
          } else {
            currentFloorObjects = currentFloorObjects.map((obj) => {
              if (obj.id === parentModule.id && obj.type === OBJECT_TYPES.MODULE) {
                const newModule = { ...obj, wallSegments: { ...obj.wallSegments } };
                if (segmentKey && newModule.wallSegments[segmentKey]) {
                  const segment = newModule.wallSegments[segmentKey];
                  const newElements = (segment.elements || []).filter((el) => el.id !== objectToDelete.id);
                  newModule.wallSegments[segmentKey] = { ...segment, elements: newElements, };
                  return newModule;
                }
              }
              return obj;
            });
          }
        }
      }
      return { ...prevProjectObjects, [currentFloorId]: currentFloorObjects };
    });
    setSelectedObjectId(null);
    setElementTypeToPlace(null);
    closeContextMenu();
  }, [selectedObjectId, primarySelectedObject, closeContextMenu, currentFloorId, undockModuleCompletely]);

  const handleContextMenuAction = useCallback(
    (event, objectId, objectType, meta) => {
      event.preventDefault();
      mainContainerRef.current?.focus();
      setElementTypeToPlace(null);
      const tempSelectedObject = objectId ? getObjectById(objectId) : (objectType === "canvas" ? null : primarySelectedObject);
      if (objectId && (!primarySelectedObject || objectId !== primarySelectedObject.id)) {
         setSelectedObjectId(objectId);
      } else if (!objectId && objectType === 'canvas') {
         setSelectedObjectId(null);
      }
      const targetObjectForMenu = tempSelectedObject || primarySelectedObject;
      let options = [];
      if (targetObjectForMenu) {
        const obj = targetObjectForMenu;
        options.push({ label: `Свойства (${obj.type.replace("_", " ")})`, onClick: () => setSelectedObjectId(obj.id), });
        options.push({ isSeparator: true });
        if (obj.type === OBJECT_TYPES.WALL_SEGMENT) {
            const segment = obj;
            if (!segment.isDocked) {
                const [coords, orientation] = segment.segmentKey.split("_");
                const cellX = parseInt(coords.split(",")[0]); const cellY = parseInt(coords.split(",")[1]);
                let isPerimeter = false;
                if (segment.parentModule) { if (orientation === "h" && (cellY === 0 || cellY === segment.parentModule.cellsLong)) isPerimeter = true; if (orientation === "v" && (cellX === 0 || cellX === segment.parentModule.cellsWide)) isPerimeter = true; }
                if (!isPerimeter && (!segment.elements || segment.elements.length === 0)) { options.push({ label: "Удалить стену", onClick: () => deleteWallSegment(segment.parentModule.id, segment.segmentKey) });
                } else if (isPerimeter) { options.push({ label: "Периметральная стена", disabled: true });
                } else if (segment.elements && segment.elements.length > 0) { options.push({ label: "Стена с элементами", disabled: true }); }
            } else {
                if (obj.isFullyOpenPassage) options.push({ label: "Восстановить стены на стыке", onClick: () => setDockedWallsDeletedState(obj, false)});
                else { options.push({ label: obj.isPassageWithPartner ? "Разделить на две стены" : "Объединить в одну стену", onClick: () => setDockedLinePassageState(obj, !obj.isPassageWithPartner) }); options.push({label: "Удалить стены (создать проем)", onClick: () => setDockedWallsDeletedState(obj, true)}); }
                 options.push({ isSeparator: true }); options.push({ label: "Стыковочная стена", disabled: true });
            }
        } else if (obj.type === OBJECT_TYPES.MODULE) {
          options.push({ label: "Повернуть модуль на 90°", onClick: () => handleRotateModule(obj.id) });
          options.push({ label: "Отзеркалить модуль (горизонтально)", onClick: () => handleMirrorModule(obj.id, 'horizontal') });
          options.push({ isSeparator: true });
          options.push({ label: "Удалить модуль", onClick: () => { if (selectedObjectId !== obj.id) setSelectedObjectId(obj.id); deleteSelectedObject(); }, });
        } else { options.push({ label: `Удалить (${obj.type.replace("_", " ")})`, onClick: () => { if (selectedObjectId !== obj.id) setSelectedObjectId(obj.id); deleteSelectedObject(); }, }); }
      } else if (objectType === "canvas" && meta?.worldX !== undefined) {
        if (activeMode === MODES.MODULAR) options.push({ label: "Добавить модуль здесь", onClick: () => addNewModuleViaContextMenu(meta.worldX, meta.worldY) });
      }
      if (options.length > 0) setContextMenu({ x: event.clientX, y: event.clientY, options });
      else setContextMenu(null);
    },
    [selectedObjectId, primarySelectedObject, getObjectById, deleteSelectedObject, deleteWallSegment, addNewModuleViaContextMenu, handleRotateModule, handleMirrorModule, activeMode, setDockedLinePassageState, setDockedWallsDeletedState]
  );

  useKeyboardShortcuts({
    mainContainerRef,
    deleteSelectedObject: primarySelectedObject && (primarySelectedObject.type === OBJECT_TYPES.MODULE || (primarySelectedObject.type !== OBJECT_TYPES.WALL_SEGMENT)) ? deleteSelectedObject : null,
    deselectAll: () => { setSelectedObjectId(null); setElementTypeToPlace(null); closeContextMenu(); },
  });

  useEffect(() => { mainContainerRef.current?.focus(); }, []);

  const mouseInteractions = useMouseInteractions({
    viewTransform, modifierKeys, mainContainerRef, svgRef, setViewTransform, activeMode,
    setSelectedObjectId, screenToWorld, updateModulePosition, snapAndFinalizeModulePosition,
    isDraggingElement: false, onWallSegmentClick: handleWallSegmentClickForPlacement, elementTypeToPlace: elementTypeToPlace,
  });

  const panelVariants = {
    hidden: (isRightPanel = false) => ({ opacity: 0, x: isRightPanel ? 50 : -50, }),
    visible: { opacity: 1, x: 0, transition: { type: "spring", stiffness: 300, damping: 30, duration: 0.2 } },
    exit: (isRightPanel = false) => ({ opacity: 0, x: isRightPanel ? 50 : -50, transition: { duration: 0.15 } }),
  };

  const addFloor = () => {
    const newFloorNumber = floors.length + 1; const newFloorId = generateId("floor_"); const newFloor = { id: newFloorId, name: `Этаж ${newFloorNumber}` };
    setFloors(prev => [...prev, newFloor]); setProjectObjects(prev => ({ ...prev, [newFloorId]: [] })); setCurrentFloorId(newFloorId); setSelectedObjectId(null); setElementTypeToPlace(null);
  };
  const deleteFloor = (floorIdToDelete) => {
    if (floors.length <= 1) { toast.warn("Нельзя удалить единственный этаж."); return; }
    if (!window.confirm(`Вы уверены, что хотите удалить этаж "${floors.find(f => f.id === floorIdToDelete)?.name}" и все его содержимое?`)) return;
    const floorName = floors.find(f => f.id === floorIdToDelete)?.name;
    setFloors(prev => prev.filter(f => f.id !== floorIdToDelete));
    setProjectObjects(prev => { const updated = { ...prev }; delete updated[floorIdToDelete]; return updated; });
    if (currentFloorId === floorIdToDelete) { setCurrentFloorId(floors.find(f => f.id !== floorIdToDelete)?.id || ""); setSelectedObjectId(null); setElementTypeToPlace(null); }
     toast.success(`Этаж "${floorName}" удален.`);
  };
  const switchToFloor = (floorId) => { if (floors.find(f => f.id === floorId)) { setCurrentFloorId(floorId); setSelectedObjectId(null); setElementTypeToPlace(null); } };
  const handleSaveProject = () => { try { const projectData = { version: "1.0", floors, projectObjects, currentFloorId, activeMode, viewTransform }; const jsonString = JSON.stringify(projectData, null, 2); const blob = new Blob([jsonString], { type: "application/json" }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = `configurator_project_${new Date().toISOString().slice(0,10)}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); toast.success("Проект успешно сохранен!"); } catch (error) { console.error("Error saving project:", error); toast.error("Ошибка сохранения проекта."); } };
  const handleLoadProject = (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { try { const projectData = JSON.parse(e.target.result); if (projectData.version === "1.0" && projectData.floors && projectData.projectObjects && projectData.currentFloorId) { setFloors(projectData.floors); setProjectObjects(projectData.projectObjects); setCurrentFloorId(projectData.currentFloorId); setActiveMode(projectData.activeMode || MODES.MODULAR); if (projectData.viewTransform) setViewTransform(projectData.viewTransform); setSelectedObjectId(null); setElementTypeToPlace(null); toast.success("Проект успешно загружен!"); } else { toast.error("Ошибка: Некорректный формат файла проекта."); } } catch (error) { console.error("Error loading project:", error); toast.error("Ошибка загрузки проекта. Файл поврежден или имеет неверный формат."); } }; reader.readAsText(file); event.target.value = null; } };
  const triggerLoadFile = () => { loadFileInputRef.current?.click(); };

  return (
    <div ref={mainContainerRef} className="w-full h-full flex flex-col select-none outline-none bg-dark-bg" tabIndex={-1}
      onClick={(e) => { if (elementTypeToPlace) { if (svgRef.current && svgRef.current.contains(e.target)) { if (e.target === svgRef.current || e.target.id === "grid" || e.target.closest("g#grid")) { setElementTypeToPlace(null); } } else if (!e.target.closest('#element-selection-panel') && !e.target.closest('#properties-panel') && !e.target.closest('#module-template-selection-panel')) { setElementTypeToPlace(null); } } }} >
      <input type="file" ref={loadFileInputRef} onChange={handleLoadProject} accept=".json" style={{ display: 'none' }} />
      <ConfiguratorToolbar activeMode={activeMode} setActiveMode={setActiveMode} onAddModuleFromToolbar={addModuleFromToolbar} floors={floors} currentFloorId={currentFloorId} addFloor={addFloor} deleteFloor={deleteFloor} switchToFloor={switchToFloor} onSaveProject={handleSaveProject} onLoadProject={triggerLoadFile} onAiGenerateModules={handleAiGeneratedModules} />
      <div className="flex flex-grow overflow-hidden">
        {activeMode === MODES.MODULAR && (
          <>
            <AnimatePresence custom={false}> {isTemplatePanelOpen && ( <motion.div key="template-panel" custom={false} variants={panelVariants} initial="hidden" animate="visible" exit="exit" className="flex-shrink-0"> <ModuleTemplateSelectionPanel templates={MODULE_TEMPLATES} onSelectTemplate={addModuleFromTemplate} onClose={() => { setIsTemplatePanelOpen(false); setModulePlacementCoords(null); }} /> </motion.div> )} </AnimatePresence>
            <AnimatePresence custom={false}> {!isTemplatePanelOpen && !canShowInitialModuleButton && ( <motion.div key="element-panel" custom={false} variants={panelVariants} initial="hidden" animate="visible" exit="exit" className="flex-shrink-0"> <ElementSelectionPanel onSelectElementType={handleElementSelectionFromPanel} selectedElementType={elementTypeToPlace} /> </motion.div> )} </AnimatePresence>
          </>
        )}
        <div className="flex-grow flex items-center justify-center p-1 sm:p-2 md:p-4 bg-dark-bg relative">
          <div className="relative bg-card-bg shadow-2xl w-full h-full max-w-[1920px] max-h-[1080px] aspect-[16/9] overflow-hidden rounded-md border border-gray-700">
            <SvgCanvas svgRef={svgRef} viewTransform={viewTransform} modifierKeys={modifierKeys} isPanningWithSpace={mouseInteractions.isPanningWithSpace} isDraggingModule={mouseInteractions.isDraggingModule} handleMouseMove={mouseInteractions.handleMouseMove} handleMouseUp={mouseInteractions.handleMouseUp} handleMouseLeave={mouseInteractions.handleMouseLeave} handleMouseDownOnCanvas={mouseInteractions.handleMouseDownOnCanvas} onContextMenu={handleContextMenuAction} objects={objectsOnCurrentFloor} activeMode={activeMode} selectedObjectId={selectedObjectId} setSelectedObjectId={setSelectedObjectId} scale={viewTransform.scale} canAddInitialModule={canShowInitialModuleButton} onAddModule={() => openTemplateSelectionPanel({ worldX: 0, worldY: 0 })} onToggleWallSegment={handleToggleWallSegment} primarySelectedObject={primarySelectedObject} elementTypeToPlace={elementTypeToPlace} onWallSegmentClick={handleWallSegmentClickForPlacement} />
          </div>
        </div>
        {activeMode === MODES.MODULAR && ( <AnimatePresence custom={true}> {primarySelectedObject && !elementTypeToPlace && !isTemplatePanelOpen && ( <motion.div key="properties-panel" custom={true} variants={panelVariants} initial="hidden" animate="visible" exit="exit" className="flex-shrink-0"> <PropertiesPanel primarySelectedObject={primarySelectedObject} lockedObjectIds={[]} modifierKeys={modifierKeys} updateSelectedObjectProperty={updateSelectedObjectProperty} deleteSelectedObject={deleteSelectedObject} onSetDockedLinePassage={setDockedLinePassageState} onSetDockedWallsDeleted={setDockedWallsDeletedState} /> </motion.div> )} </AnimatePresence> )}
      </div>
      <AnimatePresence> {contextMenu && ( <ContextMenu x={contextMenu.x} y={contextMenu.y} options={contextMenu.options} onClose={closeContextMenu} /> )} </AnimatePresence>
      <StatusBar zoomLevel={viewTransform.scale / INITIAL_PPM} selectedObjectName={ elementTypeToPlace ? `Размещение: ${elementTypeToPlace.replace("_", " ")}` : (primarySelectedObject?.label || primarySelectedObject?.type?.replace("_", " ") || "") } selectedObjectId={elementTypeToPlace ? '' : selectedObjectId} currentFloorName={floors.find(f => f.id === currentFloorId)?.name || ""} />
    </div>
  );
};
export default Configurator;

==== src\components\Configurator\configuratorConstants.js ====
import { generateId } from './configuratorUtils';

export const INITIAL_PPM = 50;
export const GRID_CELL_SIZE_M = 1.2;
export const GRID_LINE_COLOR = "rgba(100, 116, 139, 0.2)";
export const GRID_BOLD_LINE_COLOR = "rgba(100, 116, 139, 0.4)";
export const ORIGIN_POINT_COLOR = "transparent";
export const MIN_ZOOM_SCALE = 0.1 * INITIAL_PPM;
export const MAX_ZOOM_SCALE = 5 * INITIAL_PPM;
export const MODES = {
  MODULAR: "modular",
  FRAME: "frame",
  FRAMELESS: "frameless",
};

export const OBJECT_TYPES = {
  MODULE: "module",
  WALL_SEGMENT: "wall_segment",
  DOOR: "door",
  WINDOW: "window",
  PANORAMIC_WINDOW: "panoramic_window",
  OUTLET: "outlet", // Розетка (одинарная)
  LIGHT_CEILING: "light_ceiling",
  LIGHT_WALL: "light_wall",
  SWITCH: "switch", // Выключатель (одинарный)
  SWITCH_DOUBLE: "switch_double", // Выключатель (двойной)
  // Убраны RADIATOR и KITCHEN_ELEMENT из основных типов для размещения через панель
  RADIATOR: "radiator", // Оставляем тип для совместимости, но убираем из панели выбора
  KITCHEN_ELEMENT: "kitchen_element", // Оставляем тип, но убираем из панели выбора

  PLACEMENT_TYPE_WALL: "wall",
  PLACEMENT_TYPE_FLOOR: "floor",
  PLACEMENT_TYPE_CEILING: "ceiling",
};

export const DEFAULT_MODULE_CELLS_WIDE = 2;
export const DEFAULT_MODULE_CELLS_LONG = 5;

export const MODULE_DEFAULT_WIDTH =
DEFAULT_MODULE_CELLS_WIDE * GRID_CELL_SIZE_M;
export const MODULE_DEFAULT_LENGTH =
DEFAULT_MODULE_CELLS_LONG * GRID_CELL_SIZE_M;

export const defaultObjectSizes = {
  [OBJECT_TYPES.DOOR]: { width: 0.9, height: 2.1, depth: 0.15, actualDoorThickness: 0.04 },
  [OBJECT_TYPES.WINDOW]: { width: GRID_CELL_SIZE_M, height: 1.0, depth: 0.15 },
  [OBJECT_TYPES.PANORAMIC_WINDOW]: { width: GRID_CELL_SIZE_M * 1.8, height: 1.8, depth: 0.15 },
  [OBJECT_TYPES.OUTLET]: { width: 0.08, height: 0.08, depth: 0.025 }, // глубина розетки
  [OBJECT_TYPES.LIGHT_CEILING]: { width: 0.6, height: 0.1, depth: 0.05 }, // Ширина и "длина" на потолке для LED панели
  [OBJECT_TYPES.LIGHT_WALL]: { width: 0.6, height: 0.1, depth: 0.05 }, // Ширина и высота настенного LED
  [OBJECT_TYPES.SWITCH]: { width: 0.08, height: 0.08, depth: 0.025 },
  [OBJECT_TYPES.SWITCH_DOUBLE]: { width: 0.15, height: 0.08, depth: 0.025 }, // Двойной чуть шире
  // Размеры для убранных элементов (для обратной совместимости, если они есть в сохраненных проектах)
  [OBJECT_TYPES.RADIATOR]: { width: 0.8, height: 0.5, depth: 0.1 },
  [OBJECT_TYPES.KITCHEN_ELEMENT]: { width: GRID_CELL_SIZE_M, height: 0.8, depth: 0.6 },
};

// Имена файлов SVG как они есть в Assets (после удаления пробелов если были)
const SVG_ICON_NAMES = {
    DOOR: "DoorSvg", // Имя для сопоставления с импортированным компонентом
    WINDOW: "WindowSvg",
    OUTLET: "SocketX1Svg",
    LED_LIGHT: "LedSvg",
    SWITCH_X1: "SwitchX1Svg",
    SWITCH_X2: "SwitchX2Svg",
};


export const OBJECT_ELEMENT_CATEGORIES = [
  {
    title: "Двери и Окна",
    items: [
      { type: OBJECT_TYPES.DOOR, label: "Дверь", placement: OBJECT_TYPES.PLACEMENT_TYPE_WALL, icon: SVG_ICON_NAMES.DOOR },
      { type: OBJECT_TYPES.WINDOW, label: "Окно (1.2м)", placement: OBJECT_TYPES.PLACEMENT_TYPE_WALL, icon: SVG_ICON_NAMES.WINDOW },
      { type: OBJECT_TYPES.PANORAMIC_WINDOW, label: "Окно панорамное", placement: OBJECT_TYPES.PLACEMENT_TYPE_WALL, icon: SVG_ICON_NAMES.WINDOW },
    ],
  },
  {
    title: "Электрика",
    items: [
      { type: OBJECT_TYPES.OUTLET, label: "Розетка", placement: OBJECT_TYPES.PLACEMENT_TYPE_WALL, icon: SVG_ICON_NAMES.OUTLET },
      { type: OBJECT_TYPES.SWITCH, label: "Выключатель", placement: OBJECT_TYPES.PLACEMENT_TYPE_WALL, icon: SVG_ICON_NAMES.SWITCH_X1 },
      { type: OBJECT_TYPES.SWITCH_DOUBLE, label: "Выключатель двойной", placement: OBJECT_TYPES.PLACEMENT_TYPE_WALL, icon: SVG_ICON_NAMES.SWITCH_X2 },
      { type: OBJECT_TYPES.LIGHT_WALL, label: "Светильник настенный", placement: OBJECT_TYPES.PLACEMENT_TYPE_WALL, icon: SVG_ICON_NAMES.LED_LIGHT },
      { type: OBJECT_TYPES.LIGHT_CEILING, label: "Светильник потолочный", placement: OBJECT_TYPES.PLACEMENT_TYPE_CEILING, icon: SVG_ICON_NAMES.LED_LIGHT },
    ],
  },
  // Категории "Оборудование и Климат" и "Мебель и Кухня" убраны, так как Radiator и KitchenElement не имеют SVG
];

const TEMPLATE_STANDARD_NAME_SUFFIX = `(${DEFAULT_MODULE_CELLS_LONG * GRID_CELL_SIZE_M}м x ${DEFAULT_MODULE_CELLS_WIDE * GRID_CELL_SIZE_M}м)`;

export const WALL_THICKNESS_M_RENDER = 0.15;
export const DOCKED_SPLIT_WALL_THICKNESS_M = 0.05;
export const DOCKED_SPLIT_WALL_OFFSET_M = 0.03;

export const MODULE_TEMPLATES = [
  {
    category: "Базовые и служебные",
    id: "empty_module_2x5",
    name: `Пустой модуль ${TEMPLATE_STANDARD_NAME_SUFFIX}`,
    cellsWide: DEFAULT_MODULE_CELLS_WIDE,
    cellsLong: DEFAULT_MODULE_CELLS_LONG,
    label: `Пустой`,
    internalWallSegments: {},
    predefinedElements: [],
    freeElements: [],
  },
  {
    category: "Базовые и служебные",
    id: "corridor_passage_2x5",
    name: `Коридор проходной ${TEMPLATE_STANDARD_NAME_SUFFIX}`,
    cellsWide: DEFAULT_MODULE_CELLS_WIDE,
    cellsLong: DEFAULT_MODULE_CELLS_LONG,
    label: "Коридор (проход)",
    internalWallSegments: {},
    predefinedElements: [],
    freeElements: [
      { id: generateId("light_"), type: OBJECT_TYPES.LIGHT_CEILING, x: GRID_CELL_SIZE_M * 0.5, y: GRID_CELL_SIZE_M * 1.5 },
      { id: generateId("light_"), type: OBJECT_TYPES.LIGHT_CEILING, x: GRID_CELL_SIZE_M * 0.5, y: GRID_CELL_SIZE_M * 3.5 },
    ]
  },
  {
    category: "Готовые планировки (одиночные)",
    id: "guest_house_studio_2x5",
    name: `Мини-студия (гостевая) ${TEMPLATE_STANDARD_NAME_SUFFIX}`,
    cellsWide: DEFAULT_MODULE_CELLS_WIDE,
    cellsLong: DEFAULT_MODULE_CELLS_LONG,
    label: "Мини-студия",
    internalWallSegments: {
      "1,0_v": { thickness: WALL_THICKNESS_M_RENDER },
      "1,1_v": { thickness: WALL_THICKNESS_M_RENDER },
      "0,2_h": { thickness: WALL_THICKNESS_M_RENDER },
    },
    predefinedElements: [
      { type: OBJECT_TYPES.DOOR, segmentKey: `0,0_v`, properties: { positionOnSegment: 0.5, width: 0.9, openingDirection: "inward", hingeSide: "right" } },
      { type: OBJECT_TYPES.DOOR, segmentKey: `1,1_v`, properties: { positionOnSegment: 0.5, width: 0.7, openingDirection: "inward", hingeSide: "left" } },
      { type: OBJECT_TYPES.WINDOW, segmentKey: `1,0_h`, properties: { positionOnSegment: 0.5, width: GRID_CELL_SIZE_M*0.6, height: 0.6 } },
      { type: OBJECT_TYPES.PANORAMIC_WINDOW, segmentKey: `0,${DEFAULT_MODULE_CELLS_LONG-1}_h`, properties: { positionOnSegment: 0.5, width: GRID_CELL_SIZE_M * 1.8 } },
      { type: OBJECT_TYPES.OUTLET, segmentKey: `0,2_v`, properties: { positionOnSegment: 0.7 } },
      { type: OBJECT_TYPES.LIGHT_WALL, segmentKey: `0,3_v`, properties: { positionOnSegment: 0.3 }}
    ],
    freeElements: [
      { id: generateId("light_"), type: OBJECT_TYPES.LIGHT_CEILING, x: GRID_CELL_SIZE_M * 0.5, y: GRID_CELL_SIZE_M * 3.5 },
      { id: generateId("light_"), type: OBJECT_TYPES.LIGHT_CEILING, x: GRID_CELL_SIZE_M * 1.5, y: GRID_CELL_SIZE_M * 0.5 },
    ]
  },
];

export const DRAWING_WALL_FILL_COLOR = "#F5F5F5";
export const DRAWING_WALL_STROKE_COLOR = "#333333";
export const DRAWING_WALL_STROKE_WIDTH = 1;

export const DRAWING_PORTAL_JAMB_FILL_COLOR = "#E0E0E0";
export const DRAWING_PORTAL_JAMB_STROKE_COLOR = "#666666";

export const DRAWING_DOOR_FILL_COLOR = "#000000";
export const DRAWING_DOOR_STROKE_COLOR = "#222222";
export const DRAWING_DOOR_JAMB_FILL_COLOR = "#DCDCDC";
export const DRAWING_DOOR_SWING_COLOR = "#555555";
export const DRAWING_DOOR_STROKE_WIDTH = 1;

export const DRAWING_WINDOW_FRAME_COLOR = "#444444";
export const DRAWING_WINDOW_GLASS_LINE_COLOR = "#777777";
export const DRAWING_WINDOW_STROKE_WIDTH = 0.75;
export const DRAWING_PANORAMIC_WINDOW_FILL_COLOR = "rgba(173, 216, 230, 0.3)";

export const DRAWING_OUTLET_FILL_COLOR = "#E0E0E0";
export const DRAWING_OUTLET_STROKE_COLOR = "#757575";
export const DRAWING_LIGHT_FILL_COLOR = "#FFF9C4";
export const DRAWING_LIGHT_STROKE_COLOR = "#FBC02D";
export const DRAWING_RADIATOR_FILL_COLOR = "#CFD8DC";
export const DRAWING_RADIATOR_STROKE_COLOR = "#78909C";
export const DRAWING_KITCHEN_ELEMENT_FILL_COLOR = "#BCAAA4";
export const DRAWING_KITCHEN_ELEMENT_STROKE_COLOR = "#5D4037";

export const SELECTED_ELEMENT_COLOR = "#007BFF";
export const PLACEMENT_HIGHLIGHT_FILL_COLOR = "rgba(0, 255, 0, 0.3)";
export const PLACEMENT_NOT_ALLOWED_FILL_COLOR = "rgba(255, 0, 0, 0.3)";
export const PLACEMENT_GENERAL_HIGHLIGHT_FILL_COLOR = "rgba(255, 223, 0, 0.25)";

export const POTENTIAL_WALL_SLOT_COLOR = "rgba(0, 123, 255, 0.3)";

export const EPSILON = 0.01;

export const SELECTED_WALL_SEGMENT_COLOR = "#007BFF";
export const ELEMENT_STROKE_COLOR = "#333333";

==== src\components\Configurator\configuratorUtils.js ====
// ==== src\components\Configurator\configuratorUtils.js ====
// src/components/Configurator/configuratorUtils.js

// Добавляем generateId сюда
export const generateId = (prefix = "id_") =>
    `${prefix}${Date.now().toString(36)}${Math.random().toString(36).substring(2, 7)}`;
  
  export function dotProduct(v1, v2) { return v1.x * v2.x + v1.y * v2.y; }
  export function subtractVectors(v1, v2) { return { x: v1.x - v2.x, y: v1.y - v2.y }; }
  export function normalizeVector(v) { 
      const len = Math.sqrt(v.x*v.x + v.y*v.y); 
      if (len === 0) return {x: 0, y: 0};
      return {x: v.x/len, y: v.y/len}; 
  }
  export function perpendicularVector(v) { return {x: -v.y, y: v.x }; }
  
  export function getModuleVertices(module) {
      const w = module.width;
      const h = module.height;
      const x = module.x;
      const y = module.y;
      const angleRad = (module.rotation || 0) * Math.PI / 180;
      const cos = Math.cos(angleRad);
      const sin = Math.sin(angleRad);
      const centerX = x + w / 2;
      const centerY = y + h / 2;
      const cornersRelativeToOrigin = [
          { x: -w / 2, y: -h / 2 }, // Top-Left
          { x:  w / 2, y: -h / 2 }, // Top-Right
          { x:  w / 2, y:  h / 2 }, // Bottom-Right
          { x: -w / 2, y:  h / 2 }  // Bottom-Left
      ];
      return cornersRelativeToOrigin.map(corner => {
          const rotatedX = corner.x * cos - corner.y * sin;
          const rotatedY = corner.x * sin + corner.y * cos;
          return { x: centerX + rotatedX, y: centerY + rotatedY };
      });
  }
  
  export function projectPolygonOntoAxis(axis, vertices) {
      let min = dotProduct(axis, vertices[0]);
      let max = min;
      for (let i = 1; i < vertices.length; i++) {
          const p = dotProduct(axis, vertices[i]);
          if (p < min) {
              min = p;
          } else if (p > max) {
              max = p;
          }
      }
      return { min, max };
  }
  
  export function checkOverlapWithRotation(moduleA, moduleB) {
      if (!moduleA || !moduleB || moduleA.id === moduleB.id) return false;
      const rotationA = moduleA.rotation || 0;
      const rotationB = moduleB.rotation || 0;
      if (rotationA % 360 === 0 && rotationB % 360 === 0) {
        const ax1 = moduleA.x;
        const ay1 = moduleA.y;
        const ax2 = moduleA.x + moduleA.width;
        const ay2 = moduleA.y + moduleA.height;
        const bx1 = moduleB.x;
        const by1 = moduleB.y;
        const bx2 = moduleB.x + moduleB.width;
        const by2 = moduleB.y + moduleB.height;
        if (ax2 <= bx1 || ax1 >= bx2 || ay2 <= by1 || ay1 >= by2) return false;
        return true;
      }
      const verticesA = getModuleVertices(moduleA);
      const verticesB = getModuleVertices(moduleB);
      const axes = [];
      for (let i = 0; i < verticesA.length; i++) {
          const p1 = verticesA[i];
          const p2 = verticesA[(i + 1) % verticesA.length];
          const edge = subtractVectors(p2, p1);
          axes.push(normalizeVector(perpendicularVector(edge)));
      }
      for (let i = 0; i < verticesB.length; i++) {
          const p1 = verticesB[i];
          const p2 = verticesB[(i + 1) % verticesB.length];
          const edge = subtractVectors(p2, p1);
          axes.push(normalizeVector(perpendicularVector(edge)));
      }
      for (const axis of axes) {
          if (axis.x === 0 && axis.y === 0) continue; 
          const projA = projectPolygonOntoAxis(axis, verticesA);
          const projB = projectPolygonOntoAxis(axis, verticesB);
          if (projA.max < projB.min || projB.max < projA.min) {
              return false; 
          }
      }
      return true; 
  }
  
  export function distance(p1, p2) {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  
  export function rotatePoint(point, center, angleDegrees) {
      const angleRad = angleDegrees * Math.PI / 180;
      const cos = Math.cos(angleRad);
      const sin = Math.sin(angleRad);
      const translatedX = point.x - center.x;
      const translatedY = point.y - center.y;
      const rotatedX = translatedX * cos - translatedY * sin;
      const rotatedY = translatedX * sin + translatedY * cos;
      return {
          x: rotatedX + center.x,
          y: rotatedY + center.y,
      };
  }
  
  export function getLocalCoordinates(worldX, worldY, module) {
      const moduleCenterX = module.x + module.width / 2;
      const moduleCenterY = module.y + module.height / 2;
      const translatedWorldX = worldX - moduleCenterX;
      const translatedWorldY = worldY - moduleCenterY;
      const angleRad = -(module.rotation || 0) * Math.PI / 180;
      const cos = Math.cos(angleRad);
      const sin = Math.sin(angleRad);
      const unrotatedX = translatedWorldX * cos - translatedWorldY * sin;
      const unrotatedY = translatedWorldX * sin + translatedWorldY * cos;
      const localX = unrotatedX + module.width / 2;
      const localY = unrotatedY + module.height / 2;
      return { x: localX, y: localY };
  }

==== src\components\Configurator\hooks\useKeyboardShortcuts.js ====
// ==== src\components\Configurator\hooks\useKeyboardShortcuts.js ====
import { useEffect } from "react";

const useKeyboardShortcuts = ({
  mainContainerRef,
  deleteSelectedObject,
  deselectAll,
}) => {
  useEffect(() => {
    const mainEl = mainContainerRef.current;
    if (!mainEl) return;

    const handleKeyDown = (e) => {
      const activeEl = document.activeElement;
      const isInputFocused =
        activeEl && ["INPUT", "TEXTAREA", "SELECT"].includes(activeEl.tagName);

      if (e.key === "Escape") {
        e.preventDefault();
        if (isInputFocused && activeEl instanceof HTMLElement) {
          activeEl.blur();
        } else if (deselectAll) {
          deselectAll();
        } else {
          mainContainerRef.current?.focus();
        }
      }

      if (e.key === "Delete" || e.key === "Backspace") {
        if (!isInputFocused && deleteSelectedObject) {
          e.preventDefault();
          deleteSelectedObject();
        }
      }
    };

    mainEl.addEventListener("keydown", handleKeyDown);
    return () => {
      mainEl.removeEventListener("keydown", handleKeyDown);
    };
  }, [mainContainerRef, deleteSelectedObject, deselectAll]);
};

export default useKeyboardShortcuts;

==== src\components\Configurator\hooks\useModifierKeys.js ====
import { useState, useEffect, useCallback } from "react";

const useModifierKeys = (mainContainerRef, svgRef) => {
  const [modifierKeys, setModifierKeys] = useState({
    ctrl: false,
    alt: false,
    meta: false,
    shift: false,
    spacebar: false,
  });

  const handleKeyDown = useCallback(
    (e) => {
      setModifierKeys((prev) => ({
        ...prev,
        ctrl: e.ctrlKey,
        alt: e.altKey,
        meta: e.metaKey,
        shift: e.shiftKey,
        spacebar: e.code === "Space" ? true : prev.spacebar,
      }));

      if (
        e.code === "Space" &&
        mainContainerRef.current &&
        svgRef.current &&
        (document.activeElement === mainContainerRef.current ||
          svgRef.current.contains(document.activeElement) ||
          document.activeElement === document.body) // Allow space pan if body focused
      ) {
        e.preventDefault(); // Prevent page scroll when space is pressed for panning
      }
    },
    [mainContainerRef, svgRef],
  );

  const handleKeyUp = useCallback((e) => {
    setModifierKeys((prev) => ({
      ...prev,
      ctrl: e.ctrlKey,
      alt: e.altKey,
      meta: e.metaKey,
      shift: e.shiftKey,
      spacebar: e.code === "Space" ? false : prev.spacebar,
    }));
  }, []);

  useEffect(() => {
    const mainEl = mainContainerRef.current;
    if (!mainEl) return;

    // Attach to main container for focused interaction
    mainEl.addEventListener("keydown", handleKeyDown);
    mainEl.addEventListener("keyup", handleKeyUp);

    // Attach to window for global modifier key detection, especially keyup
    // This helps catch keyup events if focus is lost from mainEl during a key press
    window.addEventListener("keydown", handleKeyDown); // To catch spacebar if focus isn't on mainEl
    window.addEventListener("keyup", handleKeyUp);

    return () => {
      mainEl.removeEventListener("keydown", handleKeyDown);
      mainEl.removeEventListener("keyup", handleKeyUp);
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [mainContainerRef, handleKeyDown, handleKeyUp]);

  return modifierKeys;
};

export default useModifierKeys;


==== src\components\Configurator\hooks\useMouseInteractions.js ====
// src/components/Configurator/hooks/useMouseInteractions.js
import { useState, useCallback, useRef } from "react";
import { MODES, OBJECT_TYPES } from "../configuratorConstants";

const useMouseInteractions = ({
  viewTransform,
  modifierKeys,
  mainContainerRef,
  svgRef,
  setViewTransform,
  activeMode,
  setSelectedObjectId,
  screenToWorld,
  updateModulePosition,
  snapAndFinalizeModulePosition,
  isDraggingElement, 
  onWallSegmentClick, 
  elementTypeToPlace, 
}) => {
  const [draggingState, setDraggingState] = useState(null);
  const [isPanningWithSpace, setIsPanningWithSpace] = useState(false);
  const mouseDownStartPosRef = useRef(null);

  const handleMouseDownOnCanvas = useCallback(
    (e) => {
      mainContainerRef.current?.focus();
      if (e.button !== 0 && e.button !== 2) return;
      const worldCoords = screenToWorld(e.clientX, e.clientY);
      if (elementTypeToPlace && e.button === 0) {
        const clickedSegmentElement = e.target.closest('[data-object-type="wall_segment"]');
        if (clickedSegmentElement) {
          const segmentId = clickedSegmentElement.getAttribute("data-object-id");
          if (segmentId && onWallSegmentClick) {
            e.stopPropagation(); 
            onWallSegmentClick(segmentId);
            return; 
          }
        }
      }
      if (modifierKeys.spacebar || e.button === 1) { 
        setIsPanningWithSpace(true);
        setDraggingState({
          isPanning: true,
          startScreenX: e.clientX,
          startScreenY: e.clientY,
          initialViewX: viewTransform.x,
          initialViewY: viewTransform.y,
        });
        mouseDownStartPosRef.current = { x: e.clientX, y: e.clientY };
        e.preventDefault();
        return;
      }
      if (e.button === 0 && activeMode === MODES.MODULAR && !elementTypeToPlace) {
        const clickedModuleElement = e.target.closest('[data-object-type="module"]');
        if (clickedModuleElement) {
          const moduleId = clickedModuleElement.getAttribute("data-object-id");
          const moduleInitialX = parseFloat(
            clickedModuleElement.getAttribute("data-module-x") || "0",
          );
          const moduleInitialY = parseFloat(
            clickedModuleElement.getAttribute("data-module-y") || "0",
          );
          const moduleInitialRotation = parseFloat(
            clickedModuleElement.getAttribute("data-module-rotation") || "0" 
          );
          if (moduleId) {
            setSelectedObjectId(moduleId); 
            setDraggingState({
              isDraggingModule: true,
              moduleId: moduleId,
              dragStartWorldX: worldCoords.x,
              dragStartWorldY: worldCoords.y,
              initialModuleX: moduleInitialX,
              initialModuleY: moduleInitialY,
              initialModuleRotation: moduleInitialRotation,
            });
            e.stopPropagation();
            return;
          }
        }
        const clickedObjectElement = e.target.closest('[data-object-id]');
        if (clickedObjectElement && !clickedModuleElement) { 
            const objectId = clickedObjectElement.getAttribute('data-object-id');
            const objectType = clickedObjectElement.getAttribute('data-object-type');
            if (objectId && objectType !== OBJECT_TYPES.MODULE && setSelectedObjectId) {
                setSelectedObjectId(objectId);
                e.stopPropagation();
                return;
            }
        }
      }
      if (e.button === 0 && !elementTypeToPlace) {
        if (
          e.target === svgRef.current ||
          e.target.id === "grid" ||
          e.target.closest("g#grid")
        ) {
          setSelectedObjectId(null);
        }
      }
    },
    [
      modifierKeys,
      viewTransform.x,
      viewTransform.y,
      mainContainerRef,
      activeMode,
      setSelectedObjectId,
      screenToWorld,
      svgRef,
      elementTypeToPlace, 
      onWallSegmentClick, 
    ],
  );

  const handleMouseMove = useCallback(
    (e) => {
      if (draggingState?.isPanning) {
        if (!mouseDownStartPosRef.current) return;
        const dxScreen = e.clientX - mouseDownStartPosRef.current.x;
        const dyScreen = e.clientY - mouseDownStartPosRef.current.y;
        setViewTransform((prev) => ({
          ...prev,
          x: draggingState.initialViewX + dxScreen,
          y: draggingState.initialViewY + dyScreen,
        }));
      } else if (draggingState?.isDraggingModule) {
        const {
          moduleId,
          dragStartWorldX,
          dragStartWorldY,
          initialModuleX,
          initialModuleY,
        } = draggingState;
        const currentMouseWorld = screenToWorld(e.clientX, e.clientY);
        const deltaWorldX = currentMouseWorld.x - dragStartWorldX;
        const deltaWorldY = currentMouseWorld.y - dragStartWorldY;
        const newModuleX = initialModuleX + deltaWorldX;
        const newModuleY = initialModuleY + deltaWorldY;
        updateModulePosition(moduleId, newModuleX, newModuleY);
      }
    },
    [draggingState, setViewTransform, screenToWorld, updateModulePosition],
  );

  const handleMouseUp = useCallback(
    (_e) => {
      if (isPanningWithSpace) {
        setIsPanningWithSpace(false);
      }
      if (draggingState?.isDraggingModule) {
        snapAndFinalizeModulePosition(
          draggingState.moduleId,
          draggingState.initialModuleX, 
          draggingState.initialModuleY,
          draggingState.initialModuleRotation
        );
      }
      setDraggingState(null);
      mouseDownStartPosRef.current = null;
    },
    [isPanningWithSpace, draggingState, snapAndFinalizeModulePosition], 
  );

  const handleMouseLeave = useCallback(() => {
    if (isPanningWithSpace || draggingState?.isDraggingModule) {
      if (draggingState?.isDraggingModule) {
        snapAndFinalizeModulePosition(
          draggingState.moduleId,
          draggingState.initialModuleX,
          draggingState.initialModuleY,
          draggingState.initialModuleRotation
        );
      }
      setIsPanningWithSpace(false);
      setDraggingState(null);
      mouseDownStartPosRef.current = null;
    }
  }, [isPanningWithSpace, draggingState, snapAndFinalizeModulePosition]); 

  return {
    isPanningWithSpace,
    isDraggingModule: !!draggingState?.isDraggingModule,
    handleMouseDownOnCanvas,
    handleMouseMove,
    handleMouseUp,
    handleMouseLeave,
  };
};

export default useMouseInteractions;

==== src\components\Configurator\hooks\useViewTransform.js ====
import { useState, useCallback, useEffect } from "react";
import {
  INITIAL_PPM,
  MIN_ZOOM_SCALE,
  MAX_ZOOM_SCALE,
} from "../configuratorConstants";

const useViewTransform = (svgRef) => {
  const [viewTransform, setViewTransform] = useState({
    x: 0, 
    y: 0, 
    scale: INITIAL_PPM * 0.6,
  });
  const [initialized, setInitialized] = useState(false);

  useEffect(() => {
    if (initialized || !svgRef.current) return;

    const svg = svgRef.current;
    const rect = svg.getBoundingClientRect();

    if (rect.width > 0 && rect.height > 0) {
      setViewTransform((prev) => ({
        ...prev, 
        x: rect.width / 2,
        y: rect.height / 2,
      }));
      setInitialized(true);
    }
  }, [svgRef, initialized]);

  const screenToWorld = useCallback(
    (screenX, screenY) => {
      if (!svgRef.current) return { x: 0, y: 0 };
      const svgRect = svgRef.current.getBoundingClientRect();
      return {
        x: (screenX - svgRect.left - viewTransform.x) / viewTransform.scale,
        y: (screenY - svgRect.top - viewTransform.y) / viewTransform.scale,
      };
    },
    [viewTransform, svgRef],
  );

  const worldToScreen = useCallback(
    (worldX, worldY) => {
        if (!svgRef.current) return { x: 0, y: 0 };
        const svgRect = svgRef.current.getBoundingClientRect();
        return {
            x: worldX * viewTransform.scale + viewTransform.x + svgRect.left,
            y: worldY * viewTransform.scale + viewTransform.y + svgRect.top,
        };
    },
    [viewTransform, svgRef],
  );


  useEffect(() => {
    const currentSvgElement = svgRef.current;
    if (!currentSvgElement) return;

    const wheelHandler = (e) => {
      e.preventDefault();
      const scaleAmount = 1.1;
      const newScaleFactor = e.deltaY > 0 ? 1 / scaleAmount : scaleAmount;

      const svgRect = currentSvgElement.getBoundingClientRect();
      const mouseX = e.clientX - svgRect.left; 
      const mouseY = e.clientY - svgRect.top;

      setViewTransform((prevTransform) => {
        const worldBeforeZoomX =
          (mouseX - prevTransform.x) / prevTransform.scale;
        const worldBeforeZoomY =
          (mouseY - prevTransform.y) / prevTransform.scale;

        let newScale = prevTransform.scale * newScaleFactor;
        newScale = Math.max(MIN_ZOOM_SCALE, Math.min(newScale, MAX_ZOOM_SCALE));

        const newViewX = mouseX - worldBeforeZoomX * newScale;
        const newViewY = mouseY - worldBeforeZoomY * newScale;

        return { x: newViewX, y: newViewY, scale: newScale };
      });
    };

    currentSvgElement.addEventListener("wheel", wheelHandler, {
      passive: false, 
    });
    return () => {
      currentSvgElement.removeEventListener("wheel", wheelHandler);
    };
  }, [svgRef]); 

  return {
    viewTransform,
    setViewTransform,
    screenToWorld,
    worldToScreen, // Exported
  };
};

export default useViewTransform;

==== src\components\Configurator\renderers\AddModuleButtonRenderer.jsx ====
import React from "react";
import {
  MODULE_DEFAULT_WIDTH,
  MODULE_DEFAULT_LENGTH,
} from "../configuratorConstants";

const AddModuleButtonRenderer = ({ scale, onClick, hasModules }) => {
  const buttonWidth = MODULE_DEFAULT_WIDTH * scale;
  const buttonHeight = MODULE_DEFAULT_LENGTH * scale;
  const fontSize = Math.max(14, Math.min(28, 0.35 * scale));
  const x = -buttonWidth / 2;
  const y = -buttonHeight / 2;

  const buttonText = hasModules
    ? "+ Еще модуль"
    : `+ Добавить модуль`;
  return (
    <g onClick={onClick} className="cursor-pointer group">
      <rect
        x={x}
        y={y}
        width={buttonWidth}
        height={buttonHeight}
        fill="rgba(0, 123, 255, 0.15)"
        stroke="rgba(0, 123, 255, 0.6)"
        strokeWidth={Math.max(1, 0.02 * scale)}
        rx={Math.max(4, 0.08 * scale)}
        className="group-hover:fill-rgba(0, 123, 255, 0.25) group-hover:stroke-rgba(0,123,255,0.8) transition-all duration-150"
      />
      <text
        x={0}
        y={0}
        fill="rgba(230, 230, 250, 0.9)"
        fontSize={fontSize}
        fontWeight="500"
        textAnchor="middle"
        dominantBaseline="middle"
        pointerEvents="none"
        className="select-none group-hover:fill-rgba(255, 255, 255, 1)"
      >
        {buttonText}
      </text>
    </g>
  );
};

export default React.memo(AddModuleButtonRenderer);

==== src\components\Configurator\renderers\DoorRenderer.jsx ====
// src/components/Configurator/renderers/DoorRenderer.jsx
import React from "react";
import { SELECTED_ELEMENT_COLOR } from "../configuratorConstants";
import { ReactComponent as DoorSvg } from '../../Assets/door.svg';

const DoorRenderer = ({
  element,
  scale,
  isSelected,
}) => {
  const {
    width: doorOpeningWidthM, // Ширина проема, она же длина косяка
    hingeSide = "left",
  } = element;

  const jambLengthPx = doorOpeningWidthM * scale; // Длина косяка на экране
  // Предположим, что ширина дуги открывания примерно равна длине косяка для квадратного символа
  const openingArcWidthPx = doorOpeningWidthM * scale;


  // (0,0) DoorRenderer - это ЦЕНТР сегмента стены на его осевой линии.
  // Локальная X DoorRenderer идет ВДОЛЬ стены.
  // Локальная Y DoorRenderer идет ПЕРПЕНДИКУЛЯРНО стене ("в комнату").

  let gTransform = "";

  // 1. Поворот SVG на -90 градусов.
  // Теперь:
  // - Бывшая Y-ось SVG (косяк) идет вдоль НОВОЙ X-оси группы. Длина косяка = jambLengthPx.
  // - Бывшая X-ось SVG (открывание) идет вдоль НОВОЙ -Y-оси группы. Ширина дуги = openingArcWidthPx.
  // - (0,0) SVG (бывший верх петли) теперь в (0,0) группы. Косяк от (0,0) до (jambLengthPx, 0).
  gTransform += "rotate(-90) ";

  // 2. Позиционирование повернутого SVG.
  // (0,0) группы DoorRenderer - это центр сегмента стены.
  // Мы хотим, чтобы СЕРЕДИНА косяка (который теперь лежит вдоль новой X-оси группы)
  // совпала с X=0 группы (т.е. с центром сегмента стены по его длине).
  // Косяк имеет длину jambLengthPx и начинается в X=0 группы. Сдвигаем на -jambLengthPx / 2.
  gTransform += `translate(${-jambLengthPx / 2}, 0) `;

  // 3. Отражение для правой двери.
  // Косяк теперь отцентрирован по X=0 группы. Дуга идет по -Y группы.
  if (hingeSide === "right") {
    // Отражаем по оси X группы (вдоль которой лежит косяк), чтобы дуга поменяла направление.
    gTransform += `scale(1, -1) `;
  }


  const svgStyle = {
    fill: isSelected ? "rgba(0, 123, 255, 0.15)" : "rgba(220, 220, 225, 0.85)",
    stroke: isSelected ? SELECTED_ELEMENT_COLOR : "rgba(60, 70, 80, 0.95)",
    strokeWidth: isSelected ? 1.0 / Math.max(1, scale / 70) : 0.5 / Math.max(1, scale / 70),
  };

  return (
    <g transform={gTransform}>
      <DoorSvg
        // (0,0) SVG (верх косяка) теперь рисуется в (0,0) группы <g>,
        // которая уже повернута и смещена.
        x={0}
        y={0}
        // width и height для <DoorSvg> устанавливают размер "холста" для SVG.
        // preserveAspectRatio="xMidYMid meet" впишет содержимое viewBox в этот холст.
        // Если viewBox SVG: высота (косяк) VBH, ширина (дуга) VBW.
        // После rotate(-90): бывшая VBH становится "шириной" на новой X, бывшая VBW "высотой" на новой Y.
        // Мы хотим, чтобы длина косяка (бывшая VBH) была jambLengthPx.
        // И ширина дуги (бывшая VBW) была openingArcWidthPx.
        width={openingArcWidthPx} // Размер вдоль новой Y-оси группы (направление открывания)
        height={jambLengthPx}    // Размер вдоль новой X-оси группы (длина косяка)
        preserveAspectRatio="xMidYMid meet" // Это важно!
        style={svgStyle}
      />
      {/* Диагностика: (0,0) группы G (красный круг) должен быть на осевой линии стены, в центре длины сегмента.
          Красная линия - новая X группы (вдоль косяка). Зеленая - новая Y (вдоль дуги).
      <circle cx="0" cy="0" r="3" fill="red" />
      <line x1="0" y1="0" x2="30" y2="0" stroke="red" strokeWidth="0.5"/>
      <line x1="0" y1="0" x2="0" y2="30" stroke="green" strokeWidth="0.5"/>
      */}
    </g>
  );
};

export default React.memo(DoorRenderer);

==== src\components\Configurator\renderers\ModuleRenderer.jsx ====
// src/components/Configurator/renderers/ModuleRenderer.jsx
import React from "react";
import WallSegmentRenderer from "./WallSegmentRenderer";
import {
  GRID_CELL_SIZE_M,
  POTENTIAL_WALL_SLOT_COLOR,
  OBJECT_TYPES,
  defaultObjectSizes,
  EPSILON,
} from "../configuratorConstants";

const ModuleRenderer = ({
  module,
  scale,
  selectedObjectId,
  setSelectedObjectId,
  onToggleWallSegment,
  primarySelectedObject,
  onContextMenu,
  elementTypeToPlace,
  onWallSegmentClick,
}) => {
  const {
    x, y, cellsWide, cellsLong, rotation, wallSegments, label, id: moduleId,
  } = module;

  const moduleTransform = `translate(${x * scale}, ${y * scale}) rotate(${rotation || 0})`;
  const cellSizePx = GRID_CELL_SIZE_M * scale;

  const handleSlotClick = (cellX, cellY, orientation) => {
    let isPerimeter = false;
    if (orientation === "h" && (cellY === 0 || cellY === cellsLong)) isPerimeter = true;
    if (orientation === "v" && (cellX === 0 || cellX === cellsWide)) isPerimeter = true;
    if (!isPerimeter) {
       const segmentKey = `${cellX},${cellY}_${orientation}`;
       const segment = wallSegments[segmentKey];
       onToggleWallSegment(moduleId, cellX, cellY, orientation, segment ? segment.id : null);
    }
  };

  const handleModuleContextMenu = (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (onContextMenu) {
      onContextMenu(e, moduleId, OBJECT_TYPES.MODULE);
    }
  };

  const isSegmentSuitableForPlacement = (segmentData, currentElementTypeToPlace) => {
    if (!currentElementTypeToPlace || !segmentData) return false;
    const elementDefaults = defaultObjectSizes[currentElementTypeToPlace];
    let isPlaceable = elementDefaults && elementDefaults.width <= GRID_CELL_SIZE_M + EPSILON;
    if (currentElementTypeToPlace === OBJECT_TYPES.DOOR || currentElementTypeToPlace === OBJECT_TYPES.WINDOW || currentElementTypeToPlace === OBJECT_TYPES.PANORAMIC_WINDOW) {
        isPlaceable = isPlaceable && (!segmentData.elements || segmentData.elements.filter(el =>
            el.type === OBJECT_TYPES.DOOR || el.type === OBJECT_TYPES.WINDOW || el.type === OBJECT_TYPES.PANORAMIC_WINDOW
        ).length === 0);
    }
    return isPlaceable;
  };

  const potentialWallSlots = [];
  const showSlotsThreshold = 15;
  if (cellSizePx > showSlotsThreshold && !elementTypeToPlace) {
    for (let cy = 1; cy < cellsLong; cy++) {
      for (let cx = 0; cx < cellsWide; cx++) {
        const segmentKey = `${cx},${cy}_h`;
        const isExistingWall = !!wallSegments[segmentKey];
        potentialWallSlots.push(
          <line
            key={`slot-h-${cx}-${cy}`}
            x1={cx * cellSizePx} y1={cy * cellSizePx}
            x2={(cx + 1) * cellSizePx} y2={cy * cellSizePx}
            stroke={isExistingWall ? "transparent" : POTENTIAL_WALL_SLOT_COLOR}
            strokeWidth={Math.max(1, cellSizePx * 0.05)}
            onClick={() => handleSlotClick(cx, cy, "h")}
            className={!isExistingWall ? "cursor-pointer hover:stroke-blue-500" : "cursor-default"}
            strokeDasharray={isExistingWall ? "" : "2,2"}
            pointerEvents={!isExistingWall ? "all" : "none"}
          />,
        );
      }
    }
    for (let cx = 1; cx < cellsWide; cx++) {
      for (let cy = 0; cy < cellsLong; cy++) {
        const segmentKey = `${cx},${cy}_v`;
        const isExistingWall = !!wallSegments[segmentKey];
        potentialWallSlots.push(
          <line
            key={`slot-v-${cx}-${cy}`}
            x1={cx * cellSizePx} y1={cy * cellSizePx}
            x2={cx * cellSizePx} y2={(cy + 1) * cellSizePx}
            stroke={isExistingWall ? "transparent" : POTENTIAL_WALL_SLOT_COLOR}
            strokeWidth={Math.max(1, cellSizePx * 0.05)}
            onClick={() => handleSlotClick(cx, cy, "v")}
            className={!isExistingWall ? "cursor-pointer hover:stroke-blue-500" : "cursor-default"}
            strokeDasharray={isExistingWall ? "" : "2,2"}
            pointerEvents={!isExistingWall ? "all" : "none"}
          />,
        );
      }
    }
  }

  return (
    <g
      transform={moduleTransform}
      onContextMenu={handleModuleContextMenu}
      data-object-id={moduleId}
      data-object-type={OBJECT_TYPES.MODULE}
      data-module-x={x}
      data-module-y={y}
      data-module-rotation={rotation || 0}
      className={selectedObjectId === moduleId ? "cursor-move" : "cursor-pointer"}
    >
      <rect
        x={0} y={0}
        width={cellsWide * cellSizePx} height={cellsLong * cellSizePx}
        fill={selectedObjectId === moduleId ? "rgba(0, 123, 255, 0.1)" : "rgba(60,70,80,0.1)"}
        stroke={selectedObjectId === moduleId ? "rgba(0, 123, 255, 0.7)" : "rgba(100,100,120,0.3)"}
        strokeWidth={selectedObjectId === moduleId ? 1.5 : 1}
        pointerEvents="all"
      />
      {potentialWallSlots}
      {Object.entries(wallSegments).map(([segmentKey, segmentData]) => {
        const [coords, orientation] = segmentKey.split("_");
        const [cxStr, cyStr] = coords.split(",");
        const cellX = parseInt(cxStr, 10);
        const cellY = parseInt(cyStr, 10);
        let selectedElementIdOnThisWall = null;
        if (primarySelectedObject && primarySelectedObject.parentWallSegment && primarySelectedObject.parentWallSegment.id === segmentData.id) {
           if (primarySelectedObject.type !== OBJECT_TYPES.WALL_SEGMENT) {
               selectedElementIdOnThisWall = primarySelectedObject.id;
           }
        }
        const shouldHighlightForPlacement = elementTypeToPlace ? isSegmentSuitableForPlacement(segmentData, elementTypeToPlace) : false;
        return (
          <WallSegmentRenderer
            key={segmentData.id}
            segmentData={segmentData}
            cellX={cellX} cellY={cellY} orientation={orientation} scale={scale}
            isSelected={selectedObjectId === segmentData.id}
            selectedElementId={selectedElementIdOnThisWall}
            onSelectWallSegment={(id) => {
                if (elementTypeToPlace) { onWallSegmentClick(id); }
                else { setSelectedObjectId(id); }
            }}
            onSelectElement={setSelectedObjectId}
            onContextMenu={onContextMenu}
            highlightForPlacement={shouldHighlightForPlacement}
            isInPlacementMode={!!elementTypeToPlace}
          />
        );
      })}
      {label && cellSizePx * Math.min(cellsWide, cellsLong) > 40 && (
        <text
          x={(cellsWide * cellSizePx) / 2} y={(cellsLong * cellSizePx) / 2}
          fill="#E0E0E0" fontSize={Math.max(8, Math.min(20, 0.2 * scale))}
          textAnchor="middle" dominantBaseline="middle" pointerEvents="none" className="select-none"
        >
          {label}
        </text>
      )}
    </g>
  );
};
export default React.memo(ModuleRenderer);

==== src\components\Configurator\renderers\WallSegmentRenderer.jsx ====
import React from "react";
import DoorRenderer from "./DoorRenderer";
import WindowRenderer from "./WindowRenderer";
import PanoramicWindowRenderer from "./PanoramicWindowRenderer";
import OutletRenderer from "./OutletRenderer";
import WallMountedLightRenderer from "./WallMountedLightRenderer";
import RadiatorRenderer from "./RadiatorRenderer"; // Оставляем для совместимости
import KitchenElementRenderer from "./KitchenElementRenderer"; // Оставляем для совместимости
import SwitchRenderer from "./SwitchRenderer"; // Новый
import SwitchDoubleRenderer from "./SwitchDoubleRenderer"; // Новый
import {
  OBJECT_TYPES,
  GRID_CELL_SIZE_M,
  SELECTED_ELEMENT_COLOR,
  PLACEMENT_HIGHLIGHT_FILL_COLOR,
  PLACEMENT_NOT_ALLOWED_FILL_COLOR,
  INITIAL_PPM,
  WALL_THICKNESS_M_RENDER,
  EPSILON,
  defaultObjectSizes // <--- ДОБАВЛЕН ИМПОРТ
} from "../configuratorConstants";

const WallSegmentRenderer = ({
  segmentData,
  cellX,
  cellY,
  orientation,
  scale,
  isSelected,
  selectedElementId,
  onSelectWallSegment,
  onSelectElement,
  onContextMenu,
  highlightForPlacement,
  isInPlacementMode,
}) => {
  const {
    id: segmentId,
    elements,
    thickness = WALL_THICKNESS_M_RENDER,
    renderOffset = 0,
    isFullyOpenPassage,
    isDocked,
    isPassageWithPartner
  } = segmentData;

  const currentElements = Array.isArray(elements) ? elements : [];
  const cellSizePx = GRID_CELL_SIZE_M * scale;
  const visualThicknessPx = isFullyOpenPassage ? Math.max(1, 0.005 * scale) : thickness * scale;

  const effectiveWallThicknessForElements = (isDocked && isPassageWithPartner && !isFullyOpenPassage)
    ? WALL_THICKNESS_M_RENDER
    : thickness;

  const baseStrokeWidth = 0.5 / (scale > INITIAL_PPM ? Math.sqrt(scale / INITIAL_PPM) : 1);
  const offsetPx = renderOffset * scale;

  let rectX, rectY, rectWidth, rectHeight;
  let elementsContainerTransform;

  if (orientation === "h") {
    rectX = cellX * cellSizePx;
    rectY = (cellY * cellSizePx + offsetPx) - visualThicknessPx / 2;
    rectWidth = cellSizePx;
    rectHeight = visualThicknessPx;
    elementsContainerTransform = `translate(${cellX * cellSizePx}, ${cellY * cellSizePx + offsetPx})`;
  } else {
    rectX = (cellX * cellSizePx + offsetPx) - visualThicknessPx / 2;
    rectY = cellY * cellSizePx;
    rectWidth = visualThicknessPx;
    rectHeight = cellSizePx;
    const translateX = cellX * cellSizePx + offsetPx;
    const translateY = cellY * cellSizePx;
    elementsContainerTransform = `translate(${translateX}, ${translateY}) rotate(90)`;
  }

  let currentWallFill = "rgba(75, 85, 99, 0.3)";
  let currentWallStroke = "rgba(156, 163, 175, 0.7)";
  let currentFinalStrokeWidth = baseStrokeWidth;

  if (isInPlacementMode) {
    if (highlightForPlacement) {
      currentWallFill = PLACEMENT_HIGHLIGHT_FILL_COLOR;
      currentWallStroke = "rgba(52, 211, 153, 0.9)";
      currentFinalStrokeWidth = baseStrokeWidth * 1.5;
    } else if (!isFullyOpenPassage) {
      currentWallFill = PLACEMENT_NOT_ALLOWED_FILL_COLOR;
      currentWallStroke = "rgba(239, 68, 68, 0.7)";
      currentFinalStrokeWidth = baseStrokeWidth * 1.3;
    } else {
      currentWallFill = "rgba(100, 116, 139, 0.05)";
      currentWallStroke = "rgba(100, 116, 139, 0.15)";
      currentFinalStrokeWidth = Math.max(0.3, baseStrokeWidth * 0.5);
    }
  } else {
    if (isFullyOpenPassage) {
      currentWallFill = "rgba(59, 130, 246, 0.05)";
      currentWallStroke = "rgba(59, 130, 246, 0.2)";
      currentFinalStrokeWidth = Math.max(0.3, baseStrokeWidth * 0.5);
      if (isSelected) {
          currentWallFill = "rgba(59, 130, 246, 0.15)";
          currentWallStroke = SELECTED_ELEMENT_COLOR;
      }
    } else if (isSelected) {
      currentWallFill = "rgba(59, 130, 246, 0.3)";
      currentWallStroke = SELECTED_ELEMENT_COLOR;
      currentFinalStrokeWidth = baseStrokeWidth * 2;
    }
  }

  const handleWallContextMenu = (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (onContextMenu) {
      onContextMenu(e, segmentId, OBJECT_TYPES.WALL_SEGMENT, {});
    }
  };

  const renderElements = () => {
    if (!currentElements || currentElements.length === 0) return null;
    return (
      <>
        <g transform={elementsContainerTransform}>
          {currentElements.map((element) => {
            if(!element || !element.type) return null;
            let elementRenderWidthM = element.width || GRID_CELL_SIZE_M;
            let currentPositionOnSegment = element.positionOnSegment || 0.5;

            // Для дверей и стандартных окон ширина и позиция фиксированы по сегменту
            if (element.type === OBJECT_TYPES.DOOR || element.type === OBJECT_TYPES.WINDOW) {
              elementRenderWidthM = GRID_CELL_SIZE_M;
              currentPositionOnSegment = 0.5;
            } else { // Для остальных элементов используем их сохраненную ширину
                 const defaultSize = defaultObjectSizes[element.type];
                 elementRenderWidthM = element.width || (defaultSize ? defaultSize.width : GRID_CELL_SIZE_M) ;
            }

            const elementRenderWidthPx = elementRenderWidthM * scale;
            const elementOffsetXPx = cellSizePx * currentPositionOnSegment - (elementRenderWidthPx / 2);

            const handleElementContextMenu = (eInner) => {
              eInner.preventDefault(); eInner.stopPropagation();
              if (onContextMenu) onContextMenu(eInner, element.id, element.type, {});
            };
            return (
              <g
                key={element.id}
                transform={`translate(${elementOffsetXPx}, 0)`}
                onContextMenu={handleElementContextMenu}
                onClick={(eInner) => { eInner.stopPropagation(); onSelectElement(element.id); }}
                className="cursor-pointer"
                data-object-id={element.id}
                data-object-type={element.type}
              >
                {element.type === OBJECT_TYPES.DOOR && <DoorRenderer element={{...element, width: elementRenderWidthM}} scale={scale} wallThickness={effectiveWallThicknessForElements} isSelected={selectedElementId === element.id} />}
                {element.type === OBJECT_TYPES.WINDOW && <WindowRenderer element={{...element, width: elementRenderWidthM}} scale={scale} wallThickness={effectiveWallThicknessForElements} isSelected={selectedElementId === element.id} />}
                {element.type === OBJECT_TYPES.PANORAMIC_WINDOW && <PanoramicWindowRenderer element={{...element, width: elementRenderWidthM}} scale={scale} wallThickness={effectiveWallThicknessForElements} isSelected={selectedElementId === element.id} />}
                {element.type === OBJECT_TYPES.OUTLET && <OutletRenderer element={{...element, width: elementRenderWidthM}} scale={scale} isSelected={selectedElementId === element.id} wallThickness={effectiveWallThicknessForElements}/>}
                {element.type === OBJECT_TYPES.LIGHT_WALL && <WallMountedLightRenderer element={{...element, width: elementRenderWidthM}} scale={scale} isSelected={selectedElementId === element.id} wallThickness={effectiveWallThicknessForElements}/>}
                {element.type === OBJECT_TYPES.SWITCH && <SwitchRenderer element={{...element, width: elementRenderWidthM}} scale={scale} isSelected={selectedElementId === element.id} wallThickness={effectiveWallThicknessForElements}/>}
                {element.type === OBJECT_TYPES.SWITCH_DOUBLE && <SwitchDoubleRenderer element={{...element, width: elementRenderWidthM}} scale={scale} isSelected={selectedElementId === element.id} wallThickness={effectiveWallThicknessForElements}/>}

                {/* Рендереры для убранных из панели элементов, если они есть в данных проекта */}
                {element.type === OBJECT_TYPES.RADIATOR && <RadiatorRenderer element={{...element, width: elementRenderWidthM}} scale={scale} isSelected={selectedElementId === element.id} wallThickness={effectiveWallThicknessForElements}/>}
                {element.type === OBJECT_TYPES.KITCHEN_ELEMENT && <KitchenElementRenderer element={{...element, width: elementRenderWidthM}} scale={scale} isSelected={selectedElementId === element.id} wallThickness={effectiveWallThicknessForElements}/>}
              </g>
            );
          })}
        </g>
      </>
    );
  };

  const shouldRenderElements = !(isFullyOpenPassage);

  return (
    <g onContextMenu={handleWallContextMenu} data-segment-id={segmentId}>
      <rect
        x={rectX}
        y={rectY}
        width={rectWidth}
        height={rectHeight}
        fill={currentWallFill}
        stroke={currentWallStroke}
        strokeWidth={currentFinalStrokeWidth}
        onClick={(e) => { e.stopPropagation(); onSelectWallSegment(segmentId); }}
        style={{
          cursor: isInPlacementMode && !isFullyOpenPassage
              ? (highlightForPlacement ? 'copy' : 'not-allowed')
              : (isSelected && !isInPlacementMode ? 'move' : 'pointer')
        }}
        data-object-id={segmentId}
        data-object-type={OBJECT_TYPES.WALL_SEGMENT}
        pointerEvents="all"
      />
      {shouldRenderElements && renderElements()}
    </g>
  );
};

export default React.memo(WallSegmentRenderer);

==== src\components\Configurator\renderers\WindowRenderer.jsx ====
import React from "react";
import { SELECTED_ELEMENT_COLOR } from "../configuratorConstants";
import { ReactComponent as WindowSvg } from '../../Assets/window.svg';
// FrameSvg может не понадобиться, если window.svg уже включает раму.
// import { ReactComponent as FrameSvg } from '../../Assets/frame.svg';

const WindowRenderer = ({
  element,
  scale,
  wallThickness,
  isSelected,
}) => {
  const { width: windowElementWidthM } = element;

  const windowElementWidthPx = windowElementWidthM * scale;
  const wallThicknessPx = wallThickness * scale; // Глубина стены, в которой окно

  // Предполагаем, что window.svg уже содержит раму и стекло.
  // viewBox window.svg нужен для корректного масштабирования.
  // Пример: если window.svg имеет viewBox="0 0 120 80"
  const SVG_VIEWBOX_WIDTH = 120; // Замените на актуальную ширину viewBox вашего window.svg
  const SVG_VIEWBOX_HEIGHT = 80;  // Замените на актуальную высоту viewBox вашего window.svg

  // Масштабируем "глубину" SVG (его высоту в данном контексте) пропорционально толщине стены.
  // Ширина SVG будет равна windowElementWidthPx.
  // Это простой подход; возможно, понадобится более сложная логика для идеального вида.
  // Либо, window.svg должен быть спроектирован так, чтобы его высота (в SVG координатах) соответствовала "глубине".
  // Здесь мы растянем SVG по глубине стены.
  const svgRenderHeightPx = wallThicknessPx;

  // Стиль для SVG
  const svgStyle = {
    fill: isSelected ? "rgba(0, 123, 255, 0.2)" : "rgba(173, 216, 230, 0.5)", // Голубоватая полупрозрачная заливка для стекла
    stroke: isSelected ? SELECTED_ELEMENT_COLOR : "rgba(100, 100, 100, 0.7)", // Темная обводка для рамы
    strokeWidth: isSelected ? 1.5 / (scale / 50) : 1 / (scale / 50),
    transition: "fill 0.15s ease-in-out, stroke 0.15s ease-in-out",
  };

  return (
    <g transform={`translate(0, ${-svgRenderHeightPx / 2})`}>
      <WindowSvg
        width={windowElementWidthPx}
        height={svgRenderHeightPx} // Окно занимает всю "глубину" стены
        preserveAspectRatio="none" // Позволяет растягивать, если нужно
        // preserveAspectRatio="xMidYMid meet" // Если SVG должен сохранять пропорции
        style={svgStyle}
      />
    </g>
  );
};

export default React.memo(WindowRenderer);

==== src\components\Configurator\sidebar\ElementPlacementPanel.jsx ====
Ошибка чтения файла

==== src\components\Configurator\sidebar\PropertiesPanel.jsx ====
import React from "react";
import PropertyInput from "../common/PropertyInput";
import { TrashIcon, ArrowsRightLeftIcon, EyeSlashIcon, EyeIcon } from "@heroicons/react/24/outline"; 
import { OBJECT_TYPES, GRID_CELL_SIZE_M, defaultObjectSizes } from "../configuratorConstants";

const PropertiesPanel = ({
  primarySelectedObject,
  lockedObjectIds = [],
  modifierKeys,
  updateSelectedObjectProperty,
  deleteSelectedObject,
  onSetDockedLinePassage,
  onSetDockedWallsDeleted,
}) => {
  if (!primarySelectedObject || typeof primarySelectedObject.id === "undefined") {
    return (
      <div id="properties-panel" className="w-64 bg-card-bg border-l border-gray-700 p-4 overflow-y-auto flex-shrink-0 text-gray-400">
        <h2 className="text-md font-semibold mb-3 border-b border-gray-700 pb-2 text-gray-200">Свойства</h2>
        <p className="text-sm">Ничего не выбрано.</p>
      </div>
    );
  }

  const isLocked = lockedObjectIds.includes(primarySelectedObject.id);
  const isEditingAllowed = !isLocked || (modifierKeys && modifierKeys.shift);
  const objType = primarySelectedObject.type || "unknown";
  const objectData = primarySelectedObject;

  const commonProperties = (
    <>
      <PropertyInput label="ID:" value={objectData.id.substring(0, 15) + (objectData.id.length > 15 ? "..." : "")} disabled />
      <PropertyInput label="Тип:" value={objType.replace("_", " ")} disabled />
    </>
  );

  let typeSpecificProperties = null;
  let dockManagementUI = null; 
  let showDeleteButton = true;
  let deleteButtonText = "Удалить элемент";
  let deleteButtonDisabled = !isEditingAllowed;

  if (objType === OBJECT_TYPES.MODULE) {
    deleteButtonText = "Удалить модуль";
    typeSpecificProperties = (
      <>
        <PropertyInput label="Label:" value={objectData.label || ""} onChange={(e) => updateSelectedObjectProperty("label", e.target.value)} disabled={!isEditingAllowed} />
        <PropertyInput label="Ячеек в ширину:" value={objectData.cellsWide || 0} disabled />
        <PropertyInput label="Ячеек в длину:" value={objectData.cellsLong || 0} disabled />
        <PropertyInput label="Размер (м):" value={`${(objectData.width || 0).toFixed(2)} x ${(objectData.height || 0).toFixed(2)}`} disabled />
        <PropertyInput label="Позиция X (м):" type="number" step="0.01" value={(objectData.x || 0).toFixed(2)} onChange={(e) => updateSelectedObjectProperty("x", e.target.value)} disabled={!isEditingAllowed} />
        <PropertyInput label="Позиция Y (м):" type="number" step="0.01" value={(objectData.y || 0).toFixed(2)} onChange={(e) => updateSelectedObjectProperty("y", e.target.value)} disabled={!isEditingAllowed} />
        <PropertyInput label="Поворот (°):" type="number" step="1" value={objectData.rotation || 0} onChange={(e) => updateSelectedObjectProperty("rotation", e.target.value)} disabled={!isEditingAllowed} />
        <PropertyInput label="Отзеркален (X):" value={objectData.mirroredX ? "Да" : "Нет"} disabled />
      </>
    );
  } else if (objType === OBJECT_TYPES.WALL_SEGMENT) {
    const isPerimeter = (() => {
        if (!objectData.parentModule || !objectData.segmentKey) return false;
        const [coords, orientation] = objectData.segmentKey.split("_");
        const cellX = parseInt(coords.split(",")[0]);
        const cellY = parseInt(coords.split(",")[1]);
        if (orientation === "h" && (cellY === 0 || cellY === objectData.parentModule.cellsLong)) return true;
        if (orientation === "v" && (cellX === 0 || cellX === objectData.parentModule.cellsWide)) return true;
        return false;
    })();
    const hasElements = objectData.elements && objectData.elements.length > 0;

    if (objectData.isDocked) {
        deleteButtonText = "Стыковочная стена";
        deleteButtonDisabled = true; 
        showDeleteButton = false; 
        dockManagementUI = (
            <div className="mt-4 pt-3 border-t border-gray-600">
                <h3 className="text-sm font-semibold text-gray-300 mb-2">Управление стыком</h3>
                {objectData.isFullyOpenPassage ? (
                     <button
                        onClick={() => onSetDockedWallsDeleted(objectData, false)}
                        className="w-full text-white text-sm py-2 px-3 rounded flex items-center justify-center bg-blue-600 hover:bg-blue-500 transition-colors mb-2"
                        title="Восстановить разделенные стены на линии стыка"
                    >
                        <EyeIcon className="w-4 h-4 mr-2" />
                        Восстановить стены
                    </button>
                ) : (
                    <>
                        {objectData.isPassageWithPartner ? (
                            <button
                                onClick={() => onSetDockedLinePassage(objectData, false)} 
                                className="w-full text-white text-sm py-2 px-3 rounded flex items-center justify-center bg-orange-600 hover:bg-orange-500 transition-colors mb-2"
                                title="Разделить на две тонкие стены на линии стыка"
                            >
                                <ArrowsRightLeftIcon className="w-4 h-4 mr-2 transform rotate-90" /> 
                                Разделить стены
                            </button>
                        ) : ( 
                            <button
                                onClick={() => onSetDockedLinePassage(objectData, true)} 
                                className="w-full text-white text-sm py-2 px-3 rounded flex items-center justify-center bg-green-600 hover:bg-green-500 transition-colors mb-2"
                                title="Объединить в одну стандартную стену на линии стыка"
                            >
                                <ArrowsRightLeftIcon className="w-4 h-4 mr-2" />
                                Объединить стены
                            </button>
                        )}
                        <button
                            onClick={() => onSetDockedWallsDeleted(objectData, true)}
                            className="w-full text-white text-sm py-2 px-3 rounded flex items-center justify-center bg-red-600 hover:bg-red-500 transition-colors"
                            title="Полностью удалить стены на линии стыка (создать проем)"
                        >
                           <EyeSlashIcon className="w-4 h-4 mr-2" />
                           Удалить стены (проем)
                        </button>
                    </>
                )}
            </div>
        );

    } else { 
        deleteButtonText = "Удалить стену (меню)";
        if (isPerimeter) {
            deleteButtonDisabled = true; deleteButtonText = "Периметр (нельзя удалить)";
        } else if (hasElements) {
            deleteButtonDisabled = true; deleteButtonText = "Есть элементы (см. меню)";
        }
    }
    
    let wallTypeDisplay = "Обычная стена";
    if (objectData.isDocked) {
        if(objectData.isFullyOpenPassage){
            wallTypeDisplay = "Стыковочная (проем)";
        } else if (objectData.isPassageWithPartner) {
            wallTypeDisplay = "Стыковочная (объединенная)";
        } else {
            wallTypeDisplay = "Стыковочная (разделенная)";
        }
    }

    typeSpecificProperties = (
      <>
        <PropertyInput label="Ключ сегмента:" value={objectData.segmentKey} disabled />
        <PropertyInput label="Тип стены:" value={wallTypeDisplay} disabled />
        <PropertyInput
          label="Толщина (м):" type="number" value={(objectData.thickness || 0).toFixed(3)} step="0.001"
          onChange={(e) => updateSelectedObjectProperty("thickness", e.target.value)}
          disabled={!isEditingAllowed || objectData.isDocked || objectData.isFullyOpenPassage} 
        />
         <PropertyInput
          label="Смещение (м):" type="number" value={(objectData.renderOffset || 0).toFixed(3)} step="0.001"
          onChange={(e) => updateSelectedObjectProperty("renderOffset", e.target.value)}
          disabled={!isEditingAllowed || objectData.isDocked || objectData.isFullyOpenPassage} 
        />
        {objectData.parentModule && (
          <PropertyInput label="Родительский модуль:" value={objectData.parentModule.label || objectData.parentModule.id.substring(0, 10) + "..."} disabled />
        )}
        {objectData.isDocked && (objectData.partnerModuleId || objectData.wasPartnerModuleId) && (
             <PropertyInput label="Партнерский модуль:" value={(objectData.partnerModuleId || objectData.wasPartnerModuleId).substring(0,10)+"..."} disabled />
        )}
      </>
    );
  } else if (objType === OBJECT_TYPES.DOOR) {
    deleteButtonText = "Удалить дверь";
    typeSpecificProperties = (
      <>
        <PropertyInput
          label="Ширина двери (м):" value={(objectData.width || GRID_CELL_SIZE_M).toFixed(3)} 
          disabled title="Ширина двери равна ширине сегмента стены."
        />
        <PropertyInput
          label="Позиция на сегменте (0-1):" value={(objectData.positionOnSegment || 0.5).toFixed(2)} 
          disabled title="Дверь всегда размещается по центру сегмента."
        />
        <PropertyInput label="Петли:">
          <select value={objectData.hingeSide || "left"} onChange={(e) => updateSelectedObjectProperty("hingeSide", e.target.value)}
            className={`w-full p-1.5 border border-gray-600 rounded text-sm bg-gray-700 text-gray-200 ${(!isEditingAllowed) ? "bg-gray-800 cursor-not-allowed" : ""}`} disabled={!isEditingAllowed}
          >
            <option value="left">Слева (Петли слева)</option>
            <option value="right">Справа (Петли справа)</option>
          </select>
        </PropertyInput>
        {/* isOpen, openingAngle, openingDirection - убраны, так как SVG двери всегда открыт */}
      </>
    );
  } else if (objType === OBJECT_TYPES.WINDOW || objType === OBJECT_TYPES.PANORAMIC_WINDOW) {
    deleteButtonText = `Удалить ${objType === OBJECT_TYPES.WINDOW ? "окно" : "панорамное окно"}`;
    const isStandardWindow = objType === OBJECT_TYPES.WINDOW;
    typeSpecificProperties = (
      <>
        <PropertyInput 
            label="Ширина окна (м):" 
            type="number"
            value={(objectData.width || (isStandardWindow ? GRID_CELL_SIZE_M : defaultObjectSizes[objType].width)).toFixed(3)} 
            step="0.01"
            min={isStandardWindow ? GRID_CELL_SIZE_M.toFixed(3) : "0.1"}
            max={isStandardWindow ? GRID_CELL_SIZE_M.toFixed(3) : (GRID_CELL_SIZE_M * (objectData.parentModule?.cellsWide || 3)).toFixed(3) } // Примерный макс для панорамного
            onChange={(e) => updateSelectedObjectProperty("width", e.target.value)}
            disabled={!isEditingAllowed || isStandardWindow} 
            title={isStandardWindow ? "Ширина окна равна ширине сегмента стены." : "Укажите ширину панорамного окна"} 
        />
        <PropertyInput 
            label="Позиция на сегменте (0-1):" 
            type="number" value={(objectData.positionOnSegment || 0.5).toFixed(2)} 
            step="0.01" min="0" max="1"
            onChange={(e) => updateSelectedObjectProperty("positionOnSegment", e.target.value)}
            disabled={!isEditingAllowed || isStandardWindow} 
            title={isStandardWindow ? "Окно всегда размещается по центру сегмента." : "Укажите позицию центра панорамного окна"}
        />
        <PropertyInput
          label="Высота окна (м):" type="number" value={(objectData.height || defaultObjectSizes[objType].height).toFixed(2)} step="0.05" min="0.3"
          onChange={(e) => updateSelectedObjectProperty("height", e.target.value)} disabled={!isEditingAllowed}
        />
      </>
    );
  } else if (objType === OBJECT_TYPES.RADIATOR) {
    deleteButtonText = "Удалить радиатор";
    typeSpecificProperties = (
      <>
        <PropertyInput
            label="Ширина радиатора (м):" type="number" value={(objectData.width || defaultObjectSizes[OBJECT_TYPES.RADIATOR].width).toFixed(2)} step="0.1" min="0.3" max="2.0"
            onChange={(e) => updateSelectedObjectProperty("width", e.target.value)} disabled={!isEditingAllowed}
        />
         <PropertyInput
          label="Позиция на сегменте (0-1):" type="number" value={(objectData.positionOnSegment || 0.5).toFixed(2)} step="0.01" min="0" max="1"
          onChange={(e) => updateSelectedObjectProperty("positionOnSegment", e.target.value)} disabled={!isEditingAllowed}
        />
      </>
    );
  } else if (objType === OBJECT_TYPES.OUTLET || objType === OBJECT_TYPES.LIGHT_WALL) { // LIGHT_LED заменено на LIGHT_WALL
    deleteButtonText = `Удалить ${objType === OBJECT_TYPES.OUTLET ? "розетку" : "настенный светильник"}`;
     typeSpecificProperties = (
      <>
         <PropertyInput
          label="Позиция на сегменте (0-1):" type="number" value={(objectData.positionOnSegment || 0.5).toFixed(2)} step="0.01" min="0" max="1"
          onChange={(e) => updateSelectedObjectProperty("positionOnSegment", e.target.value)} disabled={!isEditingAllowed}
        />
      </>
    );
  } else if (objType === OBJECT_TYPES.KITCHEN_ELEMENT) {
    deleteButtonText = "Удалить кух. элемент";
    typeSpecificProperties = (
      <>
        <PropertyInput
            label="Ширина (м):" type="number" value={(objectData.width || defaultObjectSizes[OBJECT_TYPES.KITCHEN_ELEMENT].width).toFixed(2)} step="0.1" min="0.3" max="3.0"
            onChange={(e) => updateSelectedObjectProperty("width", e.target.value)} disabled={!isEditingAllowed}
        />
         <PropertyInput
          label="Позиция на сегменте (0-1):" type="number" value={(objectData.positionOnSegment || 0.5).toFixed(2)} step="0.01" min="0" max="1"
          onChange={(e) => updateSelectedObjectProperty("positionOnSegment", e.target.value)} disabled={!isEditingAllowed}
        />
        <PropertyInput
          label="Глубина (м):" type="number" value={(objectData.depth || defaultObjectSizes[OBJECT_TYPES.KITCHEN_ELEMENT].depth).toFixed(2)} step="0.05" min="0.3" max="1.0"
          onChange={(e) => updateSelectedObjectProperty("depth", e.target.value)} disabled={!isEditingAllowed}
        />
      </>
    );
  }

  return (
    <div id="properties-panel" className="w-64 bg-card-bg border-l border-gray-700 p-4 overflow-y-auto flex-shrink-0 text-gray-300">
      <div className="flex justify-between items-center mb-3 border-b border-gray-700 pb-2">
        <h2 className="text-md font-semibold text-gray-200">Свойства</h2>
      </div>
      <div>
        <p className="text-sm font-medium mb-4 capitalize text-gray-200">
          {objType.replace("_", " ")}
          {isLocked && <span className="ml-2 text-orange-400 text-xs font-normal">(Заблокирован)</span>}
        </p>
        {commonProperties}
        {typeSpecificProperties}
        {dockManagementUI}
        {showDeleteButton && deleteSelectedObject && (
          <button
            onClick={() => {
                if (objType === OBJECT_TYPES.WALL_SEGMENT && (objectData.isDocked || isPerimeter || hasElements)) {
                    return; 
                }
                deleteSelectedObject();
            }}
            className={`mt-6 w-full text-white text-sm py-2 px-4 rounded flex items-center justify-center transition-colors ${deleteButtonDisabled ? "bg-red-700/50 cursor-not-allowed" : "bg-red-600 hover:bg-red-500"}`}
            disabled={deleteButtonDisabled}
            title={deleteButtonDisabled ? (objectData.isDocked ? "Управляйте через 'Управление стыком' или контекстное меню" : "Это действие недоступно или используйте контекстное меню") : ""}
          >
            <TrashIcon className="w-4 h-4 mr-2" />
            {deleteButtonText}
          </button>
        )}
      </div>
    </div>
  );
};
export default PropertiesPanel;

==== src\components\Configurator\statusbar\StatusBar.jsx ====
import React from "react";
import PropTypes from "prop-types";

const StatusBar = ({ zoomLevel, selectedObjectName, selectedObjectId, currentFloorName }) => {
  const formattedZoom = zoomLevel ? (zoomLevel * 100).toFixed(0) : "N/A";
  return (
    <div className="p-2 bg-gray-900 border-t border-gray-700 text-sm text-gray-400 flex justify-between items-center px-4 flex-shrink-0">
      <span className="truncate max-w-[50%] min-w-[100px]">
        {selectedObjectId
          ? `Выбрано: ${selectedObjectName || "Элемент"}`
          : (currentFloorName ? `${currentFloorName} | Готов` : "Готов")}
      </span>
      <span className="whitespace-nowrap ml-2">
        {currentFloorName && <span className="mr-3 pr-3 border-r border-gray-600 hidden sm:inline">Этаж: {currentFloorName}</span>}
        <span className="hidden sm:inline">Масштаб: </span>{formattedZoom}%
      </span>
    </div>
  );
};

StatusBar.propTypes = {
  zoomLevel: PropTypes.number,
  selectedObjectName: PropTypes.string,
  selectedObjectId: PropTypes.string,
  currentFloorName: PropTypes.string,
};

export default StatusBar;

==== src\components\Configurator\toolbar\ConfiguratorToolbar.jsx ====
import React, { useState, useContext } from "react";
import AuthContext from "../../contexts/AuthContext";
import { MODES } from "../configuratorConstants";
import {
  PlusCircleIcon, ChevronDownIcon, ChevronUpIcon, DocumentArrowDownIcon,
  DocumentArrowUpIcon, TrashIcon, PlusIcon, UserCircleIcon,
  ArrowLeftStartOnRectangleIcon, SparklesIcon, PaperAirplaneIcon, XMarkIcon
} from "@heroicons/react/24/outline";
import aiService from "../../api/aiService";
import { toast } from 'react-toastify';
import { motion, AnimatePresence } from "framer-motion"; // Для анимаций

const ConfiguratorToolbar = ({
  activeMode,
  setActiveMode,
  onAddModuleFromToolbar,
  floors,
  currentFloorId,
  addFloor,
  deleteFloor,
  switchToFloor,
  onSaveProject,
  onLoadProject,
  onAiGenerateModules,
}) => {
  const { user, logout } = useContext(AuthContext);
  const modsArray = [
    { key: MODES.MODULAR, label: "Модульный" },
  ];
  const [isFloorDropdownOpen, setIsFloorDropdownOpen] = useState(false);
  const currentFloor = floors.find(f => f.id === currentFloorId);
  const [showAiInput, setShowAiInput] = useState(false);
  const [aiQuery, setAiQuery] = useState("");
  const [isAiLoading, setIsAiLoading] = useState(false);

  const handleLogout = () => {
    logout();
  };

  const handleAiSubmit = async () => {
    if (!aiQuery.trim()) {
      toast.warn("Пожалуйста, введите запрос для ИИ.");
      return;
    }
    setIsAiLoading(true);
    try {
      const response = await aiService.generateModuleConfig(aiQuery);
      if (response.data && response.data.modules) {
        onAiGenerateModules(response.data.modules, response.data.notes);
        toast.success(response.data.notes || "Конфигурация сгенерирована ИИ!");
        setAiQuery("");
        // setShowAiInput(false); // Не скрываем автоматически, пусть пользователь сам закроет
      } else {
        toast.error("ИИ вернул неожиданный формат данных. Проверьте консоль для деталей.");
        console.error("Unexpected AI response format:", response.data);
      }
    } catch (error) {
      console.error("AI Generation Error:", error.response || error);
      const errorMsg = error.response?.data?.message || error.response?.data?.errorDetails?.message || "Ошибка генерации ИИ.";
      toast.error(errorMsg);
    } finally {
      setIsAiLoading(false);
    }
  };

  return (
    <div className="p-2.5 bg-gray-900 text-gray-200 border-b border-gray-700/80 flex justify-between items-center flex-shrink-0 shadow-lg h-16 relative z-10">
      {/* Левая часть: Название и режимы */}
      <div className="flex items-center flex-shrink-0">
        <h1 className="text-xl font-bold tracking-tighter mr-3 sm:mr-5">
          Grid<span className="text-primary-blue">Space</span>
        </h1>
        <div className="flex items-center space-x-1 bg-gray-800 p-0.5 rounded-md">
          {modsArray.map((mode) => (
            <button
              key={mode.key}
              onClick={() => setActiveMode(mode.key)}
              className={`px-2.5 py-1.5 sm:px-3 sm:py-1.5 text-xs sm:text-sm rounded-md font-medium transition-colors duration-150
                ${activeMode === mode.key ? "bg-primary-blue text-white shadow-sm" : "text-gray-300 hover:bg-gray-700 hover:text-gray-100"}`}
              title={`Переключить в режим "${mode.label}"`}
            >
              {mode.label}
            </button>
          ))}
        </div>
      </div>

      {/* Центральная часть: Этажи и добавление модуля */}
      <div className="hidden sm:flex flex-grow justify-center items-center space-x-1 sm:space-x-2 mx-4">
        <div className="relative">
          <button
            onClick={() => setIsFloorDropdownOpen(!isFloorDropdownOpen)}
            className="flex items-center px-3 py-1.5 sm:px-4 sm:py-2 bg-gray-700 hover:bg-gray-600 text-gray-100 text-xs sm:text-sm rounded-md font-medium transition-colors duration-150"
          >
            {currentFloor?.name || "Этажи"}
            {isFloorDropdownOpen ? <ChevronUpIcon className="w-3 h-3 sm:w-4 sm:h-4 ml-1 sm:ml-1.5" /> : <ChevronDownIcon className="w-3 h-3 sm:w-4 sm:h-4 ml-1 sm:ml-1.5" />}
          </button>
          {isFloorDropdownOpen && (
            <div className="absolute top-full mt-1.5 left-0 w-56 bg-gray-800 border border-gray-700 rounded-lg shadow-xl z-20 py-1.5">
              {floors.map((floor) => (
                <div key={floor.id} className="flex items-center justify-between mx-1.5 rounded-md hover:bg-gray-700/70 transition-colors duration-100">
                  <button
                    onClick={() => { switchToFloor(floor.id); setIsFloorDropdownOpen(false); }}
                    className={`text-left w-full px-3 py-2 text-xs sm:text-sm ${floor.id === currentFloorId ? "text-primary-blue font-semibold" : "text-gray-200"}`}
                  >
                    {floor.name}
                  </button>
                  {floors.length > 1 && (
                    <button onClick={() => deleteFloor(floor.id)} title={`Удалить ${floor.name}`} className="ml-2 mr-2 p-1 text-red-500 hover:text-red-400 rounded-md hover:bg-red-500/10">
                      <TrashIcon className="w-4 h-4 sm:w-4 sm:h-4"/>
                    </button>
                  )}
                </div>
              ))}
              <div className="border-t border-gray-700/70 my-1.5 mx-1.5"></div>
              <button
                onClick={() => { addFloor(); setIsFloorDropdownOpen(false); }}
                className="w-[calc(100%-0.75rem)] mx-1.5 flex items-center text-left px-3 py-2 text-green-400 hover:bg-green-500/10 hover:text-green-300 text-xs sm:text-sm rounded-md transition-colors duration-100"
              >
                <PlusIcon className="w-4 h-4 sm:w-4 sm:h-4 mr-2"/> Добавить этаж
              </button>
            </div>
          )}
        </div>
        {activeMode === MODES.MODULAR && (
          <button
            onClick={onAddModuleFromToolbar}
            className="flex items-center px-3 py-1.5 sm:px-4 sm:py-2 bg-green-600 hover:bg-green-500 text-white text-xs sm:text-sm rounded-md font-medium transition-colors duration-150 shadow-sm"
            title="Добавить новый модуль вручную"
          >
            <PlusCircleIcon className="w-4 h-4 sm:w-5 sm:h-5 mr-1 sm:mr-1.5" />
            Модуль
          </button>
        )}
      </div>

      {/* Правая часть: ИИ, Сохранение, Загрузка, Пользователь */}
      <div className="flex items-center space-x-1 sm:space-x-2 flex-shrink-0">
        <AnimatePresence mode="wait">
          {showAiInput ? (
            <motion.div
              key="ai-input-panel"
              initial={{ width: 0, opacity: 0, x: 50 }}
              animate={{ width: "auto", opacity: 1, x: 0 }}
              exit={{ width: 0, opacity: 0, x: 50 }}
              transition={{ duration: 0.3, ease: "easeInOut" }}
              className="flex items-center space-x-2 bg-gray-800 p-1.5 rounded-lg shadow-md"
              // style={{ minWidth: '300px' }} // Минимальная ширина для инпута
            >
              <input
                type="text"
                value={aiQuery}
                onChange={(e) => setAiQuery(e.target.value)}
                placeholder="Запрос для ИИ..."
                className="w-48 sm:w-64 px-3 py-1.5 border border-gray-600 rounded-md text-sm bg-gray-700 text-gray-100 focus:ring-1 focus:ring-primary-blue focus:border-primary-blue outline-none transition-colors placeholder-gray-400"
                disabled={isAiLoading}
                onKeyPress={(e) => e.key === 'Enter' && !isAiLoading && handleAiSubmit()}
                autoFocus
              />
              <button
                onClick={handleAiSubmit}
                disabled={isAiLoading}
                className="p-2 bg-primary-blue hover:bg-hover-blue text-white rounded-md transition-colors duration-150 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center h-9 w-9"
                title="Отправить запрос ИИ"
              >
                {isAiLoading ? (
                  <svg className="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                ) : (
                  <PaperAirplaneIcon className="w-5 h-5" />
                )}
              </button>
              <button
                onClick={() => setShowAiInput(false)}
                className="p-2 bg-gray-600 hover:bg-gray-500 text-white rounded-md transition-colors duration-150 h-9 w-9 flex items-center justify-center"
                title="Закрыть панель ИИ"
              >
                <XMarkIcon className="w-5 h-5" />
              </button>
            </motion.div>
          ) : (
            <motion.div
              key="default-controls"
              initial={{ opacity: 0, x: -50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: -50 }}
              transition={{ duration: 0.3, ease: "easeInOut" }}
              className="flex items-center space-x-1 sm:space-x-2"
            >
              <button
                onClick={() => setShowAiInput(true)}
                className="p-2 sm:p-2.5 bg-purple-600 hover:bg-purple-500 text-white rounded-md transition-colors duration-150"
                title="Открыть панель ИИ-генерации"
              >
                <SparklesIcon className="w-4 h-4 sm:w-5 sm:h-5" />
              </button>
              <button
                onClick={onLoadProject}
                className="p-2 sm:p-2.5 bg-gray-700 hover:bg-gray-600 text-gray-300 rounded-md transition-colors duration-150"
                title="Загрузить проект"
              >
                <DocumentArrowUpIcon className="w-4 h-4 sm:w-5 sm:h-5" />
              </button>
              <button
                onClick={onSaveProject}
                className="p-2 sm:p-2.5 bg-primary-blue hover:bg-hover-blue text-white rounded-md transition-colors duration-150 shadow-sm"
                title="Сохранить проект"
              >
                <DocumentArrowDownIcon className="w-4 h-4 sm:w-5 sm:h-5" />
              </button>
              {user && (
                <div className="flex items-center ml-1 sm:ml-2">
                  <UserCircleIcon className="w-5 h-5 sm:w-6 sm:h-6 text-gray-400 mr-1" title={user.email}/>
                  <button
                    onClick={handleLogout}
                    className="p-1.5 sm:p-2 ml-1 bg-red-600 hover:bg-red-500 text-white rounded-md transition-colors duration-150"
                    title="Выйти"
                  >
                    <ArrowLeftStartOnRectangleIcon className="w-4 h-4 sm:w-5 sm:h-5" />
                  </button>
                </div>
              )}
            </motion.div>
          )}
        </AnimatePresence>
      </div>

        {/* Кнопки для мобильных, которые всегда видны или появляются в другом месте */}
        <div className="sm:hidden flex w-full justify-center items-center space-x-2 mt-2 border-t border-gray-700/50 pt-2">
            {/* Дублируем кнопки управления этажами и модулем для мобильной версии */}
            <div className="relative">
            <button
                onClick={() => setIsFloorDropdownOpen(!isFloorDropdownOpen)}
                className="flex items-center px-3 py-1.5 bg-gray-700 hover:bg-gray-600 text-gray-100 text-xs rounded-md font-medium"
            >
                {currentFloor?.name || "Этажи"}
                {isFloorDropdownOpen ? <ChevronUpIcon className="w-3 h-3 ml-1" /> : <ChevronDownIcon className="w-3 h-3 ml-1" />}
            </button>
            {isFloorDropdownOpen && ( <div className="absolute top-full mt-1.5 left-0 w-56 bg-gray-800 border border-gray-700 rounded-lg shadow-xl z-20 py-1.5">
              {floors.map((floor) => (
                <div key={floor.id} className="flex items-center justify-between mx-1.5 rounded-md hover:bg-gray-700/70 transition-colors duration-100">
                  <button
                    onClick={() => { switchToFloor(floor.id); setIsFloorDropdownOpen(false); }}
                    className={`text-left w-full px-3 py-2 text-xs sm:text-sm ${floor.id === currentFloorId ? "text-primary-blue font-semibold" : "text-gray-200"}`}
                  >
                    {floor.name}
                  </button>
                  {floors.length > 1 && (
                    <button onClick={() => deleteFloor(floor.id)} title={`Удалить ${floor.name}`} className="ml-2 mr-2 p-1 text-red-500 hover:text-red-400 rounded-md hover:bg-red-500/10">
                      <TrashIcon className="w-4 h-4 sm:w-4 sm:h-4"/>
                    </button>
                  )}
                </div>
              ))}
              <div className="border-t border-gray-700/70 my-1.5 mx-1.5"></div>
              <button
                onClick={() => { addFloor(); setIsFloorDropdownOpen(false); }}
                className="w-[calc(100%-0.75rem)] mx-1.5 flex items-center text-left px-3 py-2 text-green-400 hover:bg-green-500/10 hover:text-green-300 text-xs sm:text-sm rounded-md transition-colors duration-100"
              >
                <PlusIcon className="w-4 h-4 sm:w-4 sm:h-4 mr-2"/> Добавить этаж
              </button>
            </div>)}
            </div>
            {activeMode === MODES.MODULAR && (
            <button
                onClick={onAddModuleFromToolbar}
                className="flex items-center px-3 py-1.5 bg-green-600 hover:bg-green-500 text-white text-xs rounded-md font-medium"
            >
                <PlusCircleIcon className="w-4 h-4 mr-1" />
                Модуль
            </button>
            )}
            <button
                onClick={onLoadProject}
                className="p-2 bg-gray-700 hover:bg-gray-600 text-gray-300 rounded-md"
            >
                <DocumentArrowUpIcon className="w-4 h-4" />
            </button>
            <button
                onClick={onSaveProject}
                className="p-2 bg-primary-blue hover:bg-hover-blue text-white rounded-md"
            >
                <DocumentArrowDownIcon className="w-4 h-4" />
            </button>
        </div>


    </div>
  );
};

export default ConfiguratorToolbar;

==== src\index.css ====
/* src/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Add any global styles below */
body {
  margin: 0;
  font-family:
    "Inter",
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    "Roboto",
    "Oxygen",
    "Ubuntu",
    "Cantarell",
    "Fira Sans",
    "Droid Sans",
    "Helvetica Neue",
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #121212; /* Match dark-bg from Tailwind for body */
}

code {
  font-family:
    source-code-pro, Menlo, Monaco, Consolas, "Courier New", monospace;
}


==== src\index.js ====
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";
import reportWebVitals from "./reportWebVitals";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);


==== src\reportWebVitals.js ====
// src/reportWebVitals.js
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals; 

==== tailwind.config.js ====
// ========================================================================
// FILE: tailwind.config.js
// ========================================================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./public/index.html",
    "./src/**/*.{js,jsx,ts,tsx}", // Сканируем все JS/JSX/TS/TSX файлы в src
  ],
  theme: {
    extend: {
      // Основная палитра
      colors: {
        "dark-bg": "#121212", // Еще темнее фон для контраста
        "card-bg": "#1E1E1E", // Фон карточек и элементов UI
        "primary-blue": "#007BFF", // Основной акцентный синий
        "gradient-blue": "#00C4FF", // Вторичный синий для градиентов
        "hover-blue": "#0056b3", // Синий для hover эффектов
        // Расширение стандартных цветов Tailwind
        gray: {
          900: "#111827", // Используется для фона, если dark-bg не задан
          800: "#1F2937", // Темно-серый для элементов UI
          700: "#374151", // Серый для границ, фона инпутов
          600: "#4B5563", // Серый для текста, границ
          500: "#6B7280", // Серый для второстепенного текста, иконок
          400: "#9CA3AF", // Светло-серый для текста
          300: "#D1D5DB", // Еще светлее
          200: "#E5E7EB", // Почти белый
          100: "#F3F4F6", // Очень светлый
        },
        // Можно добавить другие акцентные цвета
        // 'accent-green': '#10B981',
        // 'accent-red': '#EF4444',
        // 'accent-yellow': '#F59E0B',
      },
      // Шрифты
      fontFamily: {
        sans: [
          "Inter",
          "system-ui",
          "-apple-system",
          "BlinkMacSystemFont",
          '"Segoe UI"',
          "Roboto",
          '"Helvetica Neue"',
          "Arial",
          '"Noto Sans"',
          "sans-serif",
          '"Apple Color Emoji"',
          '"Segoe UI Emoji"',
          '"Segoe UI Symbol"',
          '"Noto Color Emoji"',
        ],
        // Можно добавить моноширинный шрифт
        mono: [
          "ui-monospace",
          "SFMono-Regular",
          "Menlo",
          "Monaco",
          "Consolas",
          '"Liberation Mono"',
          '"Courier New"',
          "monospace",
        ],
      },
      // Анимации
      animation: {
        // spin уже есть по умолчанию в Tailwind v3+
        "fade-in": "fadeIn 0.5s ease-out forwards",
        "slide-up": "slideUp 0.5s ease-out forwards",
      },
      keyframes: {
        fadeIn: {
          "0%": { opacity: "0" },
          "100%": { opacity: "1" },
        },
        slideUp: {
          "0%": { opacity: "0", transform: "translateY(10px)" },
          "100%": { opacity: "1", transform: "translateY(0)" },
        },
      },
      // Тени
      boxShadow: {
        md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
        lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
        xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
        "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
        "inner-md": "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
        "blue-glow-sm":
          "0 1px 3px 0 rgba(0, 123, 255, 0.1), 0 1px 2px -1px rgba(0, 123, 255, 0.1)",
        "blue-glow-md":
          "0 4px 6px -1px rgba(0, 123, 255, 0.1), 0 2px 4px -2px rgba(0, 123, 255, 0.1)",
        "blue-glow-lg":
          "0 10px 15px -3px rgba(0, 123, 255, 0.1), 0 4px 6px -4px rgba(0, 123, 255, 0.1)",
      },
    },
  },
  plugins: [
    // Официальные плагины Tailwind
    require("@tailwindcss/forms"), // Стили для элементов форм по умолчанию
    require("@tailwindcss/typography"), // Стили для прозы (например, из Markdown)
    require("@tailwindcss/aspect-ratio"), // Для соотношения сторон
    require("@tailwindcss/line-clamp"), // Для обрезки текста по количеству строк
  ],
  // variants в Tailwind v3+ используются реже, предпочтительнее модификаторы (hover:, focus:, group-hover:)
  // Но если нужны специфичные варианты:
  variants: {
    extend: {
      // Пример:
      backgroundColor: ["active"],
      opacity: ["disabled"],
      cursor: ["disabled"],
    },
  },
};


Структура проекта:
- .eslintrc.js
- package-lock.json
- package.json
- postcss.config.js
+ public
  - index.html
  - manifest.json
- README.md
+ src
  - App.js
  + components
    + Configurator
      - appConstants.js
      + canvas
        - DefaultRectVisual.jsx
        - DoorVisual.jsx
        - ExpansionPlatform.jsx
        - Grid.jsx
        - MarqueeSelection.jsx
        - ObjectRendererGroup.jsx
        - ObjectVisual.jsx
        - OutletVisual.jsx
        - PreviewLine.jsx
        - SelectionExtras.jsx
        - SnapGuides.jsx
        - SvgCanvas.jsx
        - WindowVisual.jsx
      + common
        - PropertyInput.jsx
      - Configurator.jsx
      - configuratorConstants.js
      - configuratorUtils.js
      - ElementRenderer.jsx
      - HelpPanel.jsx
      + hooks
        - useConfiguratorState.js
        - useKeyboardShortcuts.js
        - useModifierKeys.js
        - useMouseInteractions.js
        - useObjectManagement.js
        - useViewTransform.js
      + modes
        - FramelessMode.jsx
        - FrameMode.jsx
        - ModularMode.jsx
      - ProjectInfo.jsx
      + sidebar
        - PropertiesPanel.jsx
      + statusbar
        - StatusBar.jsx
      + toolbar
        - ConfiguratorToolbar.jsx
  - index.css
  - index.js
  - reportWebVitals.js
- tailwind.config.js

Содержимое некоторых файлов:

==== .eslintrc.js ====
/* eslint-disable no-unused-vars */
// ========================================================================
// FILE: .eslintrc.js
// ========================================================================
// Assuming a standard ESLint config for Create React App or similar.
// No changes needed based on the prompt unless specific rules were provided.
module.exports = {
  env: {
    browser: true,
    es2021: true,
    jest: true,
  },
  extends: [
    "eslint:recommended",
    "react-app",
    "react-app/jest",
  ],
  parserOptions: {
    ecmaFeatures: {
      jsx: true,
    },
    ecmaVersion: "latest",
    sourceType: "module",
  },
  rules: {
    "react/react-in-jsx-scope": "off",
    "react/prop-types": "warn",
    "jsx-a11y/anchor-is-valid": "warn",
    "no-unused-vars": ["warn", { argsIgnorePattern: "^_" }],
  },
  settings: {
    react: {
      version: "detect",
    },
  },
  overrides: [
    {
      files: ["**/*.test.js", "**/*.test.jsx"],
      env: {
        jest: true,
      },
    },
  ],
};


==== package.json ====
{
  "name": "bird",
  "version": "0.2.0",
  "private": true,
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@heroicons/react": "^2.2.0",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.2.0",
    "@testing-library/user-event": "^13.5.0",
    "aos": "^2.3.4",
    "axios": "^1.8.4",
    "dotenv": "^16.4.7",
    "framer-motion": "^12.5.0",
    "prop-types": "^15.8.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-icons": "^5.5.0",
    "react-router-dom": "^7.4.0",
    "react-scripts": "^5.0.1",
    "react-select": "^5.10.1",
    "react-slick": "^0.30.3",
    "react-toastify": "^11.0.5",
    "slick-carousel": "^1.8.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@tailwindcss/aspect-ratio": "^0.4.2",
    "@tailwindcss/forms": "^0.5.10",
    "@tailwindcss/line-clamp": "^0.4.4",
    "@tailwindcss/postcss": "^4.0.15",
    "@tailwindcss/typography": "^0.5.16",
    "autoprefixer": "^10.4.21",
    "clsx": "^2.1.1",
    "eslint": "^8.57.1",
    "eslint-plugin-jsx-a11y": "^6.8.0",
    "eslint-plugin-react": "^7.34.1",
    "eslint-plugin-react-hooks": "^4.6.2",
    "husky": "^9.1.7",
    "lint-staged": "^15.5.0",
    "nodemon": "^3.1.9",
    "postcss": "^8.5.3",
    "postcss-flexbugs-fixes": "^5.0.2",
    "postcss-preset-env": "^10.1.5",
    "prettier": "^3.5.3",
    "tailwindcss": "^3.4.3"
  },
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "*.{js,jsx,css,md}": "prettier --write",
    "*.{js,jsx}": "eslint --fix"
  }
}

==== postcss.config.js ====
// ========================================================================
// FILE: postcss.config.js
// ========================================================================
// Adjusted for standard Tailwind v3+ installation
module.exports = {
  plugins: {
    tailwindcss: {}, // Standard Tailwind plugin
    autoprefixer: {},
    // Removed '@tailwindcss/postcss7-compat' as using standard Tailwind now
    // Removed '@tailwindcss/postcss' which seems redundant/incorrect here
    // Removed 'postcss-flexbugs-fixes' and 'postcss-preset-env' as Autoprefixer handles prefixes
  },
};


==== public\index.html ====
<!-- FILE: public/index.html -->
<!-- No changes needed based on the prompt -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!-- Consider adding fonts here if needed, e.g., Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />

    <title>Mission Hire | HRM App</title>
    <!-- Updated Title -->
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>


==== public\manifest.json ====
{
  "short_name": "Mission Hire",
  "name": "Mission Hire - Recruitment Platform",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#007BFF",
  "background_color": "#1A1A1A"
}


==== README.md ====
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)


==== src\App.js ====
import React from "react";
import Configurator from "./components/Configurator/Configurator";
import "./index.css"; // Ensure Tailwind CSS is imported

// Для ModularMode и других режимов может понадобиться ToastContainer, если будете использовать toast
import { ToastContainer } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";

// Если решите вынести ProjectInfo и HelpPanel на уровень App
// import ProjectInfo from './components/Configurator/ProjectInfo';
// import HelpPanel from './components/Configurator/HelpPanel';

// Если будете управлять режимами из App.js
// import { DEFAULT_MODE, MODES } from './components/Configurator/appConstants';
// import FramelessMode from './components/Configurator/modes/FramelessMode';
// import FrameMode from './components/Configurator/modes/FrameMode';
// import ModularMode from './components/Configurator/modes/ModularMode';

function App() {
  // Пример управления состоянием, если вынести его в App.js
  // const [activeMode, setActiveMode] = React.useState(DEFAULT_MODE);
  // const [projectInfoData, setProjectInfoData] = React.useState({ area: 0, cost: 0, elements: [] });

  // const renderModeSpecificUIForApp = (configuratorInterface) => {
  //   switch (activeMode) {
  //     case MODES.FRAMELESS:
  //       return <FramelessMode {...configuratorInterface} />;
  //     case MODES.FRAMED:
  //       return <FrameMode {...configuratorInterface} />;
  //     case MODES.MODULAR:
  //       return <ModularMode {...configuratorInterface} />;
  //     default:
  //       return null;
  //   }
  // };

  return (
    <div className="App h-screen flex flex-col">
      <ToastContainer position="bottom-right" autoClose={3000} newestOnTop />
      <Configurator
      // activeMode={activeMode} // Передаем, если управляем из App
      // setProjectInfoData={setProjectInfoData} // Передаем, если управляем из App
      // renderModeSpecificUI={renderModeSpecificUIForApp} // Передаем, если управляем из App
      />
      {/* <ProjectInfo {...projectInfoData} /> */}
      {/* <HelpPanel /> */}
    </div>
  );
}

export default App;


==== src\components\Configurator\appConstants.js ====
// src/components/Configurator/appConstants.js
export const MODES = {
  MODULAR: "modular",
  FRAMELESS: "frameless",
  FRAMED: "framed",
};

export const DEFAULT_MODE = MODES.MODULAR;

export const DEFAULT_PANEL_WIDTH_M = 1.15;
export const DEFAULT_MODULE_WIDTH_M = 6.0;
export const DEFAULT_MODULE_HEIGHT_M = 2.4;
export const DOOR_WIDTH_M = 0.9;
export const WINDOW_WIDTH_M = 1.2;
export const WALL_THICKNESS_M = 0.15;
export const INTERNAL_ELEMENT_SNAP_GRID_SIZE = 0.05; // Snap grid for internal walls/corridors

==== src\components\Configurator\canvas\DefaultRectVisual.jsx ====
import React from "react";
import {
    ARCH_BLACK,
    ARCH_WHITE,
    ARCH_SELECT_BLUE,
    ARCH_STROKE_MEDIUM, // <-- Импорт
    ARCH_STROKE_THIN,   // <-- Импорт
    ARCH_STROKE_VERY_THIN, // <-- Импорт
} from "../configuratorConstants";

const DefaultRectVisual = ({ obj, scale, commonProps }) => {
  const widthScaled = Math.max(1, obj.width * scale);
  const heightScaled = Math.max(1, obj.height * scale);
  const isSelected = commonProps.stroke === ARCH_SELECT_BLUE;

  let fill = ARCH_WHITE;
  let stroke = ARCH_BLACK;
  // Use defined weights for stroke width based on selection and type
  let strokeWidth = isSelected ? ARCH_STROKE_MEDIUM : ARCH_STROKE_THIN;

  if (obj.type === "wall") {
    fill = ARCH_WHITE; // Keep walls as outlines
    strokeWidth = isSelected ? ARCH_STROKE_MEDIUM : ARCH_STROKE_MEDIUM; // Walls slightly thicker
  } else if (obj.type === 'light_led') {
      fill = ARCH_WHITE;
      strokeWidth = isSelected ? ARCH_STROKE_THIN : ARCH_STROKE_VERY_THIN;
  }

  // Selection color override
  stroke = isSelected ? ARCH_SELECT_BLUE : stroke;

  return (
    <>
      <rect
        x={0}
        y={0}
        width={widthScaled}
        height={heightScaled}
        fill={fill}
        stroke={stroke}
        strokeWidth={strokeWidth} // Use calculated width
        style={commonProps.style}
        data-object-id={commonProps['data-object-id']}
      />
      {/* Text rendering for light_led */}
      {obj.type === 'light_led' && obj.label && (
          <text
            x={widthScaled / 2}
            y={heightScaled / 2}
            fontSize={`${Math.min(12, Math.max(6, heightScaled * 0.6))}px`}
            textAnchor="middle"
            dominantBaseline="central"
            fill={isSelected ? ARCH_SELECT_BLUE : ARCH_BLACK}
            style={{ pointerEvents: "none", fontVariantNumeric: "tabular-nums" }}
            stroke="none"
          >
              {obj.label}
          </text>
      )}
     </>
  );
};

export default React.memo(DefaultRectVisual);

==== src\components\Configurator\canvas\DoorVisual.jsx ====
import React from "react";
import {
  ARCH_BLACK,
  ARCH_MID_GRAY,
  ARCH_WHITE,
  ARCH_STROKE_MEDIUM,
  ARCH_STROKE_THIN,
  ARCH_STROKE_VERY_THIN,
  ARCH_SELECT_BLUE,
  DOOR_LEAF_VISUAL_THICKNESS_M,
} from "../configuratorConstants";

const DoorVisual = ({ obj, scale, commonProps, isSelected }) => {
  const frameW_s = obj.width * scale;
  const frameT_s = obj.height * scale;
  const leafT_m = DOOR_LEAF_VISUAL_THICKNESS_M;
  const leafT_s = Math.max(1, leafT_m * scale);

  const pivotX_s = obj.hingeSide === "left" ? 0 : frameW_s;
  const pivotY_s = frameT_s / 2;

  let finalRotationForSVG = 0;
  if (obj.isOpen && obj.openingAngle !== 0) {
    let angle = obj.openingAngle;
    if (obj.openingDirection === "outward") angle *= -1;
    finalRotationForSVG = (obj.hingeSide === "left" ? angle : -angle);
  }

  const arcRadius = frameW_s;
  const arcAngleRad = finalRotationForSVG * (Math.PI / 180);
  const arcStartX = pivotX_s; 
  const arcStartY = pivotY_s;
  const arcEndX = pivotX_s + (obj.hingeSide === 'left' ? arcRadius * Math.cos(arcAngleRad) : -arcRadius * Math.cos(arcAngleRad));
  const arcEndY = pivotY_s + (obj.hingeSide === 'left' ? arcRadius * Math.sin(arcAngleRad) : -arcRadius * Math.sin(arcAngleRad));
  const arcSweepFlag = finalRotationForSVG >= 0 ? 1 : 0;

  const leafStrokeWidth = isSelected ? ARCH_STROKE_MEDIUM : ARCH_STROKE_THIN;
  const arcStrokeWidth = isSelected ? ARCH_STROKE_THIN : ARCH_STROKE_VERY_THIN;
  const handleStrokeWidth = ARCH_STROKE_VERY_THIN;

  const handleSize = Math.max(3, 0.05 * scale); 
  const handleOffset = handleSize * 0.5; 

  const handleLocalX = (obj.hingeSide === 'left') 
                       ? frameW_s - handleOffset - handleSize/2 
                       : handleOffset + handleSize/2;          
  const handleLocalY = pivotY_s; 

  const handlePath = `M ${handleLocalX - handleSize/2} ${handleLocalY - handleSize/2} L ${handleLocalX + handleSize/2} ${handleLocalY - handleSize/2} L ${handleLocalX + handleSize/2} ${handleLocalY + handleSize/2}`;

  return (
    <>
      <g transform={`rotate(${finalRotationForSVG}, ${pivotX_s}, ${pivotY_s})`}>
        <rect
          x={0} 
          y={pivotY_s - leafT_s / 2} 
          width={frameW_s} 
          height={leafT_s} 
          fill={ARCH_WHITE} 
          stroke={isSelected ? ARCH_SELECT_BLUE : ARCH_BLACK}
          strokeWidth={leafStrokeWidth}
        />
         <path 
             d={handlePath}
             stroke={isSelected ? ARCH_SELECT_BLUE : ARCH_MID_GRAY}
             strokeWidth={handleStrokeWidth}
             fill="none"
         />
      </g>

      {obj.isOpen && obj.openingAngle > 0 && (
        <path
          d={`M ${arcStartX} ${arcStartY} A ${arcRadius} ${arcRadius} 0 0 ${arcSweepFlag} ${arcEndX} ${arcEndY}`}
          fill="none"
          stroke={isSelected ? ARCH_SELECT_BLUE : ARCH_MID_GRAY} 
          strokeWidth={arcStrokeWidth}
          strokeDasharray="4,2" 
          opacity={0.8} 
        />
      )}
    </>
  );
};
export default React.memo(DoorVisual);

==== src\components\Configurator\canvas\Grid.jsx ====
import React from "react";
import {
  GRID_LINE_COLOR,
  GRID_BOLD_LINE_COLOR,
  ORIGIN_POINT_COLOR,
  INITIAL_PPM,
} from "../configuratorConstants";

const Grid = ({ viewTransform, svgWidth, svgHeight }) => {
  if (svgWidth === 0 || svgHeight === 0) return null; 

  const { x: viewX, y: viewY, scale } = viewTransform;
  const finalGridLines = [];

  const majorGridSizeWorld = 1;
  const minorGridDivisions = 10;

  const majorGridSizeScaled = majorGridSizeWorld * scale;
  const minorGridSizeScaled = (majorGridSizeWorld / minorGridDivisions) * scale;

  const majorLineThreshold = 20;
  const minorLineThreshold = 5;

  if (majorGridSizeScaled > majorLineThreshold) {
    const startOffsetX = viewX % majorGridSizeScaled;
    for (let x = startOffsetX; x < svgWidth; x += majorGridSizeScaled) {
      finalGridLines.push(
        <line
          key={`major-gv-${x}`}
          x1={x}
          y1={0}
          x2={x}
          y2={svgHeight}
          stroke={GRID_BOLD_LINE_COLOR}
          strokeWidth={0.5}
        />,
      );
    }
    if (
      minorGridSizeScaled > minorLineThreshold &&
      majorGridSizeScaled / minorGridSizeScaled > 1.5
    ) {
      const minorStartOffsetX = viewX % minorGridSizeScaled;
      for (let x = minorStartOffsetX; x < svgWidth; x += minorGridSizeScaled) {
        if (
          Math.abs(
            (x - (viewX % majorGridSizeScaled) + majorGridSizeScaled) %
              majorGridSizeScaled,
          ) >
          minorGridSizeScaled * 0.1
        ) {
          finalGridLines.push(
            <line
              key={`minor-gv-${x}`}
              x1={x}
              y1={0}
              x2={x}
              y2={svgHeight}
              stroke={GRID_LINE_COLOR}
              strokeWidth={0.25}
            />,
          );
        }
      }
    }
  }

  if (majorGridSizeScaled > majorLineThreshold) {
    const startOffsetY = viewY % majorGridSizeScaled;
    for (let y = startOffsetY; y < svgHeight; y += majorGridSizeScaled) {
      finalGridLines.push(
        <line
          key={`major-gh-${y}`}
          x1={0}
          y1={y}
          x2={svgWidth}
          y2={y}
          stroke={GRID_BOLD_LINE_COLOR}
          strokeWidth={0.5}
        />,
      );
    }
    if (
      minorGridSizeScaled > minorLineThreshold &&
      majorGridSizeScaled / minorGridSizeScaled > 1.5
    ) {
      const minorStartOffsetY = viewY % minorGridSizeScaled;
      for (let y = minorStartOffsetY; y < svgHeight; y += minorGridSizeScaled) {
        if (
          Math.abs(
            (y - (viewY % majorGridSizeScaled) + majorGridSizeScaled) %
              majorGridSizeScaled,
          ) >
          minorGridSizeScaled * 0.1
        ) {
          finalGridLines.push(
            <line
              key={`minor-gh-${y}`}
              x1={0}
              y1={y}
              x2={svgWidth}
              y2={y}
              stroke={GRID_LINE_COLOR}
              strokeWidth={0.25}
            />,
          );
        }
      }
    }
  }

  return <g id="grid">{finalGridLines}</g>;
};

export default React.memo(Grid);

==== src\components\Configurator\canvas\MarqueeSelection.jsx ====
// src/components/Configurator/canvas/MarqueeSelection.jsx
import React from "react";
import {
  MARQUEE_FILL_COLOR,
  MARQUEE_STROKE_COLOR,
} from "../configuratorConstants";

const MarqueeSelection = ({ marqueeRect, svgRef }) => {
  if (!marqueeRect || !marqueeRect.active || !svgRef || !svgRef.current) {
    return null;
  }

  const svgDomRect = svgRef.current.getBoundingClientRect();
  if (svgDomRect.width === 0 || svgDomRect.height === 0) {
    return null;
  }

  const x =
    Math.min(marqueeRect.startScreenX, marqueeRect.currentScreenX) -
    svgDomRect.left;
  const y =
    Math.min(marqueeRect.startScreenY, marqueeRect.currentScreenY) -
    svgDomRect.top;
  const width = Math.abs(marqueeRect.startScreenX - marqueeRect.currentScreenX);
  const height = Math.abs(
    marqueeRect.startScreenY - marqueeRect.currentScreenY,
  );

  return (
    <rect
      x={x}
      y={y}
      width={width}
      height={height}
      fill={MARQUEE_FILL_COLOR}
      stroke={MARQUEE_STROKE_COLOR}
      strokeWidth="1" 
      pointerEvents="none" 
    />
  );
};

export default React.memo(MarqueeSelection);

==== src\components\Configurator\canvas\ObjectRendererGroup.jsx ====
import React from "react";
import ObjectVisual from "./ObjectVisual";

const ObjectRendererGroup = ({
  objects,
  viewTransform,
  selectedObjectIds,
  lockedObjectIds,
  overlappingObjectIds,
  modifierKeys,
  handleMouseDownOnObject,
  handleMouseDownOnResizeHandle,
  draggingState,
  resizingState,
  onAddObject,
  addingCorridorMode,
  onAddCorridor,
  svgRef, 
  onExpansionPlatformClick,
  activeMode,
}) => {
  return (
    <>
      {objects.map((obj) => {
        if (!obj) return null;
        return (
          <ObjectVisual
            key={obj.id}
            obj={obj}
            scale={viewTransform.scale}
            isSelected={selectedObjectIds.includes(obj.id)}
            isLocked={lockedObjectIds.includes(obj.id)}
            isOverlapping={overlappingObjectIds.includes(obj.id)}
            modifierKeys={modifierKeys}
            onMouseDown={handleMouseDownOnObject}
            onResizeHandleMouseDown={handleMouseDownOnResizeHandle}
            draggingState={draggingState}
            resizingState={resizingState}
            onAddObject={onAddObject}
            addingCorridorMode={addingCorridorMode}
            onAddCorridor={onAddCorridor}
            objects={objects}
            viewTransform={viewTransform}
            svgRef={svgRef}
            onExpansionPlatformClick={onExpansionPlatformClick}
            activeMode={activeMode}
          />
        );
      })}
    </>
  );
};
export default React.memo(ObjectRendererGroup);

==== src\components\Configurator\canvas\ObjectVisual.jsx ====
// src/components/Configurator/canvas/ObjectVisual.jsx
import React from "react";
import { toast } from 'react-toastify';
// import SelectionExtras from "./SelectionExtras"; // Disabled for static
import DoorVisual from "./DoorVisual";
import WindowVisual from "./WindowVisual";
import OutletVisual from "./OutletVisual";
import DefaultRectVisual from "./DefaultRectVisual";
// import ExpansionPlatform from "./ExpansionPlatform"; // Disabled for static

import {
  objectColors,
  // OVERLAP_HIGHLIGHT_COLOR, // Disabled for static
  LOCKED_OBJECT_STROKE_COLOR,
  defaultObjectSizes,
  INITIAL_PPM,
  ARCH_BLACK,
  ARCH_DARK_GRAY,
  ARCH_LIGHT_GRAY,
  ARCH_WHITE,
  // ARCH_STROKE_THICK, // Not directly used, but its value might be
  ARCH_STROKE_MEDIUM,
  ARCH_STROKE_THIN,
  ARCH_STROKE_VERY_THIN,
  ARCH_SELECT_BLUE,
  ARCH_CORRIDOR_STROKE,
  WALL_THICKNESS_M,
} from "../configuratorConstants";

import { DEFAULT_PANEL_WIDTH_M } from "../appConstants";

const ObjectVisual = ({
  obj,
  scale,
  isSelected,
  isLocked,
  lockedObjectIds,
  // isOverlapping, // Disabled for static
  modifierKeys,
  onMouseDown,
  // onResizeHandleMouseDown, // Disabled for static
  // draggingState, // Not used for visual style of static objects
  // resizingState, // Not used for visual style of static objects
  onAddObject,
  onAddCorridor,
  objects,
  viewTransform,
  svgRef,
  // onExpansionPlatformClick, // Disabled for static
  // activeMode, // Not directly used for static visuals
}) => {
  const [hoveredCorridor, setHoveredCorridor] = React.useState(null);

  const rotationCenterXScaled = (obj.width * scale) / 2;
  const rotationCenterYScaled = (obj.height * scale) / 2;

  let baseStroke = ARCH_BLACK;
  let baseStrokeWidthUnscaled = ARCH_STROKE_THIN;
  let corridorLineStrokeWidth = 1.5;

  if (obj.type === 'wall' || obj.type === 'module') {
      baseStrokeWidthUnscaled = ARCH_STROKE_MEDIUM;
  } else if (obj.type === 'door' || obj.type === 'window') {
       baseStrokeWidthUnscaled = ARCH_STROKE_THIN;
  } else if (obj.type === 'light_led' || obj.type === 'radiator' || obj.type === 'kitchen_unit') {
        baseStrokeWidthUnscaled = ARCH_STROKE_VERY_THIN;
  } else if (obj.type === 'outlet') {
      baseStrokeWidthUnscaled = ARCH_STROKE_THIN;
      baseStroke = ARCH_BLACK;
  } else if (obj.type === 'corridor') {
      baseStroke = ARCH_CORRIDOR_STROKE;
  } else {
       baseStrokeWidthUnscaled = ARCH_STROKE_MEDIUM;
       baseStroke = objectColors[obj.type] || ARCH_DARK_GRAY;
  }

  const finalStroke = isLocked ? LOCKED_OBJECT_STROKE_COLOR : (isSelected ? ARCH_SELECT_BLUE : baseStroke);

  let finalObjectStrokeWidth;
  if (obj.type === 'corridor') {
    finalObjectStrokeWidth = corridorLineStrokeWidth;
  } else {
    finalObjectStrokeWidth = isSelected
     ? Math.max(0.5, ARCH_STROKE_MEDIUM / (scale / INITIAL_PPM))
     : Math.max(0.15, baseStrokeWidthUnscaled / (scale / INITIAL_PPM));
  }

  const commonProps = {
    stroke: finalStroke,
    strokeWidth: finalObjectStrokeWidth,
    style: {
      cursor: "default", // Always default for static objects
    },
    "data-object-id": obj.id,
  };

  const groupTransform = `translate(${obj.x * scale}, ${obj.y * scale}) rotate(${obj.rotation || 0}, ${rotationCenterXScaled}, ${rotationCenterYScaled})`;

  const localScreenToWorld = (screenX, screenY) => {
      if (!svgRef?.current || !viewTransform) {
          return { x: 0, y: 0 };
      }
      const svgRect = svgRef.current.getBoundingClientRect();
      return {
        x: (screenX - svgRect.left - viewTransform.x) / viewTransform.scale,
        y: (screenY - svgRect.top - viewTransform.y) / viewTransform.scale,
      };
  };

  const handleWallSegmentClick = (e, block, parentObj) => {
        e.stopPropagation();
        if (parentObj.id && lockedObjectIds && lockedObjectIds.includes(parentObj.id) && !modifierKeys.shift) {
            toast.warn(`Родительский объект ${parentObj.label || parentObj.id} заблокирован.`);
            return;
        }
        
        const existingElementInSegment = objects.find(o => o.parentId === parentObj.id && o.side === block.side && o.segmentIndex === block.segmentIndex);

        let segmentOccupiedByDoorWindowOutlet = false;
        if (parentObj.type === 'module') {
            segmentOccupiedByDoorWindowOutlet = objects.some(o => o.parentId === parentObj.id && o.side === block.side && o.segmentIndex === block.segmentIndex && (o.type === 'door' || o.type === 'window' || o.type === 'outlet'));
        } else if (parentObj.type === 'corridor') {
            segmentOccupiedByDoorWindowOutlet = objects.some(o => o.parentId === parentObj.id && o.type === 'door' );
        }
        
        const intendedTypeFromBlock = block.intendedType || null;
        if (segmentOccupiedByDoorWindowOutlet && (intendedTypeFromBlock === 'radiator' || intendedTypeFromBlock === 'kitchen_unit')) {
            toast.info(`Этот участок уже занят дверью/окном/розеткой. Аксессуар добавить нельзя.`);
            return;
        }
        if (existingElementInSegment && (existingElementInSegment.type === 'radiator' || existingElementInSegment.type === 'kitchen_unit') && (intendedTypeFromBlock === 'door' || intendedTypeFromBlock === 'window' || intendedTypeFromBlock === 'outlet')) {
            toast.info(`Этот участок уже занят аксессуаром. Дверь/окно/розетку добавить нельзя.`);
            return;
        }
         if (existingElementInSegment && intendedTypeFromBlock && existingElementInSegment.type !== intendedTypeFromBlock) {
             toast.info(`Этот участок ${parentObj.type === 'module' ? 'стены' : 'коридора'} уже занят другим типом объекта.`);
             return;
        }


        const panel = document.createElement('div');
        panel.className = 'fixed bg-white rounded-lg shadow-lg p-4 z-50';
        panel.style.left = `${e.clientX}px`; panel.style.top = `${e.clientY}px`;
        
        let availableButtons = [];
        if (parentObj.type === 'corridor') {
            availableButtons = [{ type: 'door', label: 'Дверь', icon: '🚪', category: 'opening' }];
        } else {
            availableButtons = [
                { type: 'door', label: 'Дверь', icon: '🚪', category: 'opening' },
                { type: 'window', label: 'Окно', icon: '🪟', category: 'opening' },
                { type: 'outlet', label: 'Розетка', icon: '🔌', category: 'opening' },
                { type: 'radiator', label: 'Радиатор', icon: '♨️', category: 'accessory' },
                { type: 'kitchen_unit', label: 'Кух. блок', icon: '🍳', category: 'accessory' },
            ];
        }

        const segmentHasOpening = objects.some(o => o.parentId === parentObj.id && o.side === block.side && o.segmentIndex === block.segmentIndex && (o.type === 'door' || o.type === 'window' || o.type === 'outlet'));
        const segmentHasAccessory = objects.some(o => o.parentId === parentObj.id && o.side === block.side && o.segmentIndex === block.segmentIndex && (o.type === 'radiator' || o.type === 'kitchen_unit'));

        availableButtons.forEach(btn => {
            if (segmentHasOpening && btn.category === 'accessory') return; 
            if (segmentHasAccessory && btn.category === 'opening') return;
            
            if (existingElementInSegment && existingElementInSegment.type !== btn.type) {
                 if(existingElementInSegment.id) return; 
            }


            const buttonElement = document.createElement('button');
            buttonElement.className = 'flex items-center gap-2 px-3 py-2 rounded hover:bg-gray-100 w-full mb-2 text-sm';
            buttonElement.innerHTML = `${btn.icon} ${btn.label}`;
            buttonElement.onclick = () => {
                if (typeof onAddObject === 'function') {
                    const elementDefaultSize = defaultObjectSizes[btn.type];
                    if (!elementDefaultSize) { console.error(`No default size for type ${btn.type}`); if (panel.parentNode) panel.parentNode.removeChild(panel); return; }
                    let elW = elementDefaultSize.width; let elH = WALL_THICKNESS_M;
                    if (btn.type === 'radiator' || btn.type === 'kitchen_unit') {
                        elH = elementDefaultSize.height; 
                    }

                    let newElementX, newElementY; let elementRotation = 0;
                    const parentWorldX = parentObj.x; const parentWorldY = parentObj.y;
                    if (parentObj.type === 'module') {
                        const blockLocalX = block.x; const blockLocalY = block.y;
                        const blockW = block.width; const blockH = block.height;
                        const blockCenterX = parentWorldX + blockLocalX + blockW / 2;
                        const blockCenterY = parentWorldY + blockLocalY + blockH / 2;
                        
                        if (block.side === 'top') {
                            elementRotation = 0;
                            newElementX = blockCenterX - elW / 2;
                            newElementY = blockCenterY - elH / 2;
                        } else if (block.side === 'bottom') {
                            elementRotation = 180;
                             newElementX = blockCenterX - elW / 2;
                             newElementY = blockCenterY - elH / 2;
                        } else if (block.side === 'left') {
                            elementRotation = -90;
                            let tempW = elW; elW = elH; elH = tempW; 
                            newElementX = blockCenterX - elW / 2;
                            newElementY = blockCenterY - elH / 2;
                        } else if (block.side === 'right') {
                            elementRotation = 90;
                            let tempW = elW; elW = elH; elH = tempW; 
                            newElementX = blockCenterX - elW / 2;
                            newElementY = blockCenterY - elH / 2;
                        }
                    } else if (parentObj.type === 'corridor') {
                        const isVerticalCorridor = parentObj.height > parentObj.width;
                        const doorLength = elW; const doorThickness = WALL_THICKNESS_M;
                        const corridorCenterX = parentWorldX + parentObj.width / 2;
                        const corridorCenterY = parentWorldY + parentObj.height / 2;
                        const clickWorld = localScreenToWorld(e.clientX, e.clientY);
                        if (isVerticalCorridor) { elementRotation = 0; newElementX = corridorCenterX - doorThickness / 2; newElementY = clickWorld.y - doorLength / 2;
                        } else { elementRotation = 90; newElementX = clickWorld.x - doorLength / 2; newElementY = corridorCenterY - doorThickness / 2; }
                        elW = doorLength; elH = doorThickness;
                    } else { if (panel.parentNode) panel.parentNode.removeChild(panel); return; }
                    onAddObject( btn.type, newElementX, newElementY, elW, elH, { rotation: elementRotation, segmentIndex: block.segmentIndex, side: block.side, parentId: parentObj.id, ...(btn.type === 'door' && { isOpen: false, openingAngle: 90, hingeSide: 'left', openingDirection: 'inward' })});
                }
                if (panel.parentNode) panel.parentNode.removeChild(panel);
            };
            panel.appendChild(buttonElement);
        });
        const closeBtn = document.createElement('button'); closeBtn.className = 'absolute top-2 right-2 text-gray-500 hover:text-gray-700'; closeBtn.innerHTML = '✕';
        closeBtn.onclick = () => { if (panel.parentNode) panel.parentNode.removeChild(panel); }; panel.appendChild(closeBtn); document.body.appendChild(panel);
        const closePanel = (ev) => { if (panel.parentNode && !panel.contains(ev.target)) { panel.parentNode.removeChild(panel); document.removeEventListener('click', closePanel); }};
        setTimeout(() => document.addEventListener('click', closePanel), 0);
  };

  let specificVisual;
  if (obj.type === "door") {
    specificVisual = ( <DoorVisual obj={obj} scale={scale} commonProps={commonProps} isSelected={isSelected} /> );
  } else if (obj.type === "window") {
    specificVisual = ( <WindowVisual obj={obj} scale={scale} commonProps={commonProps} isSelected={isSelected} /> );
  } else if (obj.type === "outlet") {
    specificVisual = ( <OutletVisual obj={obj} scale={scale} commonProps={commonProps} rotationCenterXScaled={rotationCenterXScaled} rotationCenterYScaled={rotationCenterYScaled} isSelected={isSelected} /> );
  } else if (obj.type === "corridor") {
    const isVertical = obj.height > obj.width;
    const lengthScaled = isVertical ? obj.height * scale : obj.width * scale;
    let x1, y1, x2, y2;
    const logicalThicknessForClick = Math.max(WALL_THICKNESS_M * scale, 10);

    if (isVertical) {
        x1 = obj.width * scale / 2; y1 = 0;
        x2 = obj.width * scale / 2; y2 = lengthScaled;
    } else {
        x1 = 0; y1 = obj.height * scale / 2;
        x2 = lengthScaled; y2 = obj.height * scale / 2;
    }
    specificVisual = (
        <g onClick={(e) => handleWallSegmentClick(e, { x: 0, y: 0, width: obj.width, height: obj.height, side: isVertical ? 'vertical' : 'horizontal', segmentIndex: 0, intendedType: 'door' }, obj)}
           style={{ cursor: 'pointer' }} // Keep pointer for adding elements to corridor
        >
            <rect
                x={isVertical ? (obj.width * scale / 2) - (logicalThicknessForClick / 2) : 0}
                y={isVertical ? 0 : (obj.height * scale / 2) - (logicalThicknessForClick / 2)}
                width={isVertical ? logicalThicknessForClick : lengthScaled}
                height={isVertical ? lengthScaled : logicalThicknessForClick}
                fill="transparent"
            />
            <line x1={x1} y1={y1} x2={x2} y2={y2} stroke={commonProps.stroke} strokeWidth={commonProps.strokeWidth} />
        </g>
    );

  } else if (obj.type === "module" && !obj.corridor && !obj.bathroom && !obj.shower) {
    const moduleWidth = obj.width * scale;
    const moduleHeight = obj.height * scale;
    const wallThicknessM = 0.08;
    const wallThicknessScaled = wallThicknessM * scale;
    const blockSize = DEFAULT_PANEL_WIDTH_M; 

    const outerPath = `M 0 0 L ${moduleWidth} 0 L ${moduleWidth} ${moduleHeight} L 0 ${moduleHeight} Z`;
    const innerPath = `M ${wallThicknessScaled} ${wallThicknessScaled} L ${moduleWidth - wallThicknessScaled} ${wallThicknessScaled} L ${moduleWidth - wallThicknessScaled} ${moduleHeight - wallThicknessScaled} L ${wallThicknessScaled} ${moduleHeight - wallThicknessScaled} Z`;

    const studLines = [];
    const studInterval = blockSize * scale;
    for (let x = studInterval; x < moduleWidth - wallThicknessScaled; x += studInterval) {
        studLines.push(<line key={`stud-t-${x}`} x1={x} y1={wallThicknessScaled} x2={x} y2={wallThicknessScaled + 5} stroke={ARCH_LIGHT_GRAY} strokeWidth={ARCH_STROKE_VERY_THIN} />);
        studLines.push(<line key={`stud-b-${x}`} x1={x} y1={moduleHeight - wallThicknessScaled} x2={x} y2={moduleHeight - wallThicknessScaled - 5} stroke={ARCH_LIGHT_GRAY} strokeWidth={ARCH_STROKE_VERY_THIN} />);
    }
     for (let y = studInterval + wallThicknessScaled; y < moduleHeight - wallThicknessScaled; y += studInterval) {
        studLines.push(<line key={`stud-l-${y}`} x1={wallThicknessScaled} y1={y} x2={wallThicknessScaled + 5} y2={y} stroke={ARCH_LIGHT_GRAY} strokeWidth={ARCH_STROKE_VERY_THIN} />);
        studLines.push(<line key={`stud-r-${y}`} x1={moduleWidth - wallThicknessScaled} y1={y} x2={moduleWidth - wallThicknessScaled - 5} y2={y} stroke={ARCH_LIGHT_GRAY} strokeWidth={ARCH_STROKE_VERY_THIN} />);
    }

    const interactionBlocks = [];
     for (let x_seg = 0; x_seg < obj.width; x_seg += blockSize) {
        interactionBlocks.push({ x: x_seg * scale, y: 0, width: Math.min(blockSize, obj.width - x_seg) * scale, height: wallThicknessScaled, side: 'top', segmentIndex: Math.floor(x_seg / blockSize), origBlock: {x: x_seg, y: 0, width: Math.min(blockSize, obj.width - x_seg), height: wallThicknessM, side: 'top'} });
        interactionBlocks.push({ x: x_seg * scale, y: moduleHeight - wallThicknessScaled, width: Math.min(blockSize, obj.width - x_seg) * scale, height: wallThicknessScaled, side: 'bottom', segmentIndex: Math.floor(x_seg / blockSize), origBlock: {x: x_seg, y: obj.height - wallThicknessM, width: Math.min(blockSize, obj.width - x_seg), height: wallThicknessM, side: 'bottom'} });
    }
    for (let y_seg = wallThicknessM; y_seg < obj.height - wallThicknessM; y_seg += blockSize) {
       interactionBlocks.push({ x: 0, y: y_seg * scale, width: wallThicknessScaled, height: Math.min(blockSize, obj.height - y_seg - wallThicknessM) * scale, side: 'left', segmentIndex: Math.floor((y_seg - wallThicknessM) / blockSize), origBlock: {x: 0, y: y_seg, width: wallThicknessM, height: Math.min(blockSize, obj.height - y_seg - wallThicknessM), side: 'left'} });
       interactionBlocks.push({ x: moduleWidth - wallThicknessScaled, y: y_seg * scale, width: wallThicknessScaled, height: Math.min(blockSize, obj.height - y_seg - wallThicknessM) * scale, side: 'right', segmentIndex: Math.floor((y_seg - wallThicknessM) / blockSize), origBlock: {x: obj.width - wallThicknessM, y: y_seg, width: wallThicknessM, height: Math.min(blockSize, obj.height - y_seg - wallThicknessM), side: 'right'} });
    }
    
    let corridorPlaceholders = [];
    const existingCorridors = (window.__corridorObjectsCache = window.__corridorObjectsCache || []);
    if (Array.isArray(existingCorridors)) { existingCorridors.length = 0;}
    for (let i = 1; i < obj.width / blockSize; i++) { 
      for (let j = 0; j < (obj.height - 2 * wallThicknessM) / blockSize; j++) { 
         const blockGridX = i * blockSize * scale; 
         const blockGridY = (j * blockSize + wallThicknessM) * scale; 
         const blockGridH = blockSize * scale;     
         const plusX = blockGridX;
         const plusY = blockGridY + blockGridH / 2;
         const isHovered = hoveredCorridor && hoveredCorridor.type === 'vertical' && hoveredCorridor.index === i && hoveredCorridor.blockIndex === j;
         const corridorExists = false; 
         if (!corridorExists) {
           corridorPlaceholders.push(
             <g key={`corridor-vblock-${i}-${j}`}
               onMouseEnter={() => setHoveredCorridor({ type: 'vertical', index: i, blockIndex: j, x: obj.x + i * blockSize, y: obj.y + j * blockSize + wallThicknessM, width: blockSize, height: blockSize, orientation: 'vertical', parentId: obj.id })}
               onMouseLeave={() => setHoveredCorridor(null)}
             >
               <rect x={blockGridX - 8} y={blockGridY} width={16} height={blockGridH} fill="transparent" style={{ cursor: 'pointer' }}/>
               {isHovered && <line x1={blockGridX} y1={blockGridY} x2={blockGridX} y2={blockGridY + blockGridH} stroke="#4f46e5" strokeWidth={2} strokeDasharray="4,4" opacity={0.5} />}
               {isHovered && (<g style={{ cursor: 'pointer' }} onClick={(e) => { e.stopPropagation(); if (typeof onAddCorridor === 'function') { onAddCorridor({ ...hoveredCorridor }); } else { console.warn('onAddCorridor is not a function!'); } }}>
                   <circle cx={plusX} cy={plusY} r={14} fill="#fff" stroke="#4f46e5" strokeWidth={2} opacity={0.9} style={{ filter: 'drop-shadow(0 2px 4px rgba(0,0,0,0.2))', transition: 'all 0.2s ease' }}/>
                   <text x={plusX} y={plusY + 5} textAnchor="middle" fontSize="20" fill="#4f46e5" fontWeight="bold" opacity={0.9} style={{ filter: 'drop-shadow(0 1px 2px rgba(0,0,0,0.1))', transition: 'all 0.2s ease' }}>+</text>
               </g>)}
             </g>
           );}
      }}
    for (let j = 1; j < obj.height / blockSize; j++) { 
      for (let i = 0; i < (obj.width - 2 * wallThicknessM) / blockSize; i++) { 
         const blockGridX = (i * blockSize + wallThicknessM) * scale;
         const blockGridY = j * blockSize * scale;
         const blockGridW = blockSize * scale;
         const plusX = blockGridX + blockGridW / 2;
         const plusY = blockGridY;
         const isHovered = hoveredCorridor && hoveredCorridor.type === 'horizontal' && hoveredCorridor.index === j && hoveredCorridor.blockIndex === i;
         const corridorExists = false; 
          if (!corridorExists) {
           corridorPlaceholders.push(
             <g key={`corridor-hblock-${j}-${i}`}
               onMouseEnter={() => setHoveredCorridor({ type: 'horizontal', index: j, blockIndex: i, x: obj.x + i * blockSize + wallThicknessM, y: obj.y + j * blockSize, width: blockSize, height: blockSize, orientation: 'horizontal', parentId: obj.id })}
               onMouseLeave={() => setHoveredCorridor(null)}
             >
               <rect x={blockGridX} y={blockGridY - 8} width={blockGridW} height={16} fill="transparent" style={{ cursor: 'pointer' }}/>
               {isHovered && <line x1={blockGridX} y1={blockGridY} x2={blockGridX + blockGridW} y2={blockGridY} stroke="#4f46e5" strokeWidth={2} strokeDasharray="4,4" opacity={0.5} />}
               {isHovered && (<g style={{ cursor: 'pointer' }} onClick={(e) => { e.stopPropagation(); if (typeof onAddCorridor === 'function') { onAddCorridor({ ...hoveredCorridor }); } else { console.warn('onAddCorridor is not a function!'); } }}>
                   <circle cx={plusX} cy={plusY} r={14} fill="#fff" stroke="#4f46e5" strokeWidth={2} opacity={0.9} style={{ filter: 'drop-shadow(0 2px 4px rgba(0,0,0,0.2))', transition: 'all 0.2s ease' }} />
                   <text x={plusX} y={plusY + 5} textAnchor="middle" fontSize="20" fill="#4f46e5" fontWeight="bold" opacity={0.9} style={{ filter: 'drop-shadow(0 1px 2px rgba(0,0,0,0.1))', transition: 'all 0.2s ease' }}>+</text>
               </g>)}
             </g>
           );}
      }}

    const occupiedSegments = new Set();
     if (objects && obj.type === 'module') {
      objects.forEach(el => {
        if ((el.type === 'door' || el.type === 'window' || el.type === 'outlet' || el.type === 'radiator' || el.type === 'kitchen_unit') && el.parentId === obj.id && el.side && typeof el.segmentIndex === 'number') {
          occupiedSegments.add(`${el.side}-${el.segmentIndex}`);
        }
      });
    }

    specificVisual = (
      <>
        <path d={outerPath} fill="none" stroke={commonProps.stroke} strokeWidth={commonProps.strokeWidth} />
        <path d={innerPath} fill="none" stroke={commonProps.stroke} strokeWidth={commonProps.strokeWidth * 0.7} opacity={0.8} />
        {studLines}
        {interactionBlocks.map((block, index) => (
          occupiedSegments.has(`${block.origBlock.side}-${block.segmentIndex}`) ? null : (
            <rect key={`int-block-${index}`} x={block.x} y={block.y} width={block.width} height={block.height} fill="transparent" style={{ cursor: 'pointer' }} onClick={(e) => handleWallSegmentClick(e, block.origBlock, obj)} />
          )
        ))}
        {corridorPlaceholders}
      </>
    );
  }
  else if (obj.type === "module") {
    specificVisual = ( <DefaultRectVisual obj={obj} scale={scale} commonProps={commonProps} /> );
  }
  else {
    specificVisual = ( <DefaultRectVisual obj={obj} scale={scale} commonProps={commonProps} /> );
  }

  // const canInteractWithHandles = !isLocked || modifierKeys.shift; // Not used for static
  // const expansionPlatformSize = defaultObjectSizes.panel?.width || 1; // Not used for static

  return (
    <g transform={groupTransform} onMouseDown={(e) => onMouseDown(e, obj.id)}>
      {specificVisual}
      {/* Expansion platforms are removed for static objects */}
      {/* {isSelected && obj.type === 'module' && activeMode === 'modular' && !draggingState && !resizingState && onExpansionPlatformClick && (
        <>
          <ExpansionPlatform x={obj.width} y={(obj.height - expansionPlatformSize) / 2} width={expansionPlatformSize} height={expansionPlatformSize} scale={scale} side="right" onClick={(e) => {e.stopPropagation(); onExpansionPlatformClick(obj.id, 'right', { x: obj.x + obj.width, y: obj.y + (obj.height - expansionPlatformSize)/2 , width: expansionPlatformSize, height: expansionPlatformSize });}} />
          <ExpansionPlatform x={-expansionPlatformSize} y={(obj.height - expansionPlatformSize) / 2} width={expansionPlatformSize} height={expansionPlatformSize} scale={scale} side="left" onClick={(e) => {e.stopPropagation(); onExpansionPlatformClick(obj.id, 'left', { x: obj.x - expansionPlatformSize, y: obj.y + (obj.height - expansionPlatformSize)/2, width: expansionPlatformSize, height: expansionPlatformSize });}} />
          <ExpansionPlatform x={(obj.width - expansionPlatformSize) / 2} y={obj.height} width={expansionPlatformSize} height={expansionPlatformSize} scale={scale} side="bottom" onClick={(e) => {e.stopPropagation(); onExpansionPlatformClick(obj.id, 'bottom', { x: obj.x + (obj.width - expansionPlatformSize)/2, y: obj.y + obj.height, width: expansionPlatformSize, height: expansionPlatformSize });}} />
          <ExpansionPlatform x={(obj.width - expansionPlatformSize) / 2} y={-expansionPlatformSize} width={expansionPlatformSize} height={expansionPlatformSize} scale={scale} side="top" onClick={(e) => {e.stopPropagation(); onExpansionPlatformClick(obj.id, 'top', { x: obj.x + (obj.width - expansionPlatformSize)/2, y: obj.y - expansionPlatformSize, width: expansionPlatformSize, height: expansionPlatformSize });}} />
        </>
      )} */}
      {/* Overlap highlight is removed for static objects */}
      {/* {isOverlapping && !isLocked && (
        <rect x="0" y="0" width={Math.max(1, obj.width * scale)} height={Math.max(1, obj.height * scale)} fill={OVERLAP_HIGHLIGHT_COLOR} stroke="red" strokeWidth={ARCH_STROKE_VERY_THIN} pointerEvents="none" />
      )} */}
      {/* SelectionExtras are removed for static objects */}
      {/* {isSelected && !isLocked && obj.type !== 'module' && obj.type !== 'corridor' && (
        <SelectionExtras obj={obj} scale={scale} canInteractWithHandles={canInteractWithHandles} onResizeHandleMouseDown={onResizeHandleMouseDown} />
      )} */}
       {obj.type === 'module' && obj.label && isSelected && !isLocked && (
        <text x={(obj.width * scale) / 2} y={(obj.height * scale) / 2} fontSize={`${Math.max(10, 14 / (scale / INITIAL_PPM))}px`} textAnchor="middle" dominantBaseline="central" fill={ARCH_DARK_GRAY} style={{ pointerEvents: "none", fontWeight: 500 }} > {obj.label} </text>
      )}
    </g>
  );
};
export default React.memo(ObjectVisual);

==== src\components\Configurator\canvas\OutletVisual.jsx ====
import React from "react";
import {
    ARCH_BLACK,
    ARCH_STROKE_MEDIUM,
    ARCH_STROKE_THIN,
    ARCH_WHITE,
    ARCH_SELECT_BLUE,
    ARCH_OUTLET_FILL,
    ARCH_OUTLET_STROKE,
} from "../configuratorConstants";

const OutletVisual = ({
  obj,
  scale,
  commonProps,
  rotationCenterXScaled,
  rotationCenterYScaled,
  isSelected
}) => {

  const baseSize = Math.max(1, obj.width * scale);
  const baseStroke = ARCH_OUTLET_STROKE || ARCH_BLACK;
  const strokeWidth = isSelected ? ARCH_STROKE_MEDIUM : ARCH_STROKE_THIN;
  const size = Math.max(0.5, baseSize - strokeWidth);

  const x = rotationCenterXScaled - size / 2;
  const y = rotationCenterYScaled - size / 2;

  return (
    <rect
        x={x}
        y={y}
        width={size}
        height={size}
        fill={ARCH_OUTLET_FILL}
        stroke={isSelected ? ARCH_SELECT_BLUE : baseStroke}
        strokeWidth={strokeWidth}
        style={commonProps.style}
        data-object-id={commonProps['data-object-id']}
    />
  );
};

export default React.memo(OutletVisual);

==== src\components\Configurator\canvas\SelectionExtras.jsx ====
import React from "react";
import {
  RESIZE_HANDLE_SIZE_PX,
  RESIZE_HANDLE_COLOR,
  INITIAL_PPM,
  DIMENSION_TEXT_COLOR,
  DIMENSION_TEXT_BG_COLOR,
} from "../configuratorConstants";
import { getResizeCursorForHandle } from "../configuratorUtils";

const SelectionExtras = ({
  obj,
  scale,
  canInteractWithHandles,
  onResizeHandleMouseDown,
}) => {
  const handles = [];
  const dimensionTexts = [];

  const uiScaleFactor = INITIAL_PPM / scale;

  const OBBHandlesDef = [
    { type: "tl", x: 0, y: 0 },
    { type: "t", x: obj.width / 2, y: 0 },
    { type: "tr", x: obj.width, y: 0 },
    { type: "l", x: 0, y: obj.height / 2 },
    { type: "r", x: obj.width, y: obj.height / 2 },
    { type: "bl", x: 0, y: obj.height },
    { type: "b", x: obj.width / 2, y: obj.height },
    { type: "br", x: obj.width, y: obj.height },
  ];

  const handleSizeBase = RESIZE_HANDLE_SIZE_PX; 
  const handleSizeSVG = Math.max(
    4 * uiScaleFactor,
    handleSizeBase * uiScaleFactor,
  );
  const handleStrokeWidthSVG = Math.max(
    0.2 * uiScaleFactor,
    0.5 * uiScaleFactor,
  );


  OBBHandlesDef.forEach((h) => {
    handles.push(
      <rect
        key={`handle-${h.type}`}
        data-resize-handle="true"
        x={h.x * scale - handleSizeSVG / 2}
        y={h.y * scale - handleSizeSVG / 2}
        width={handleSizeSVG}
        height={handleSizeSVG}
        fill={RESIZE_HANDLE_COLOR}
        stroke="white"
        strokeWidth={handleStrokeWidthSVG}
        style={{
          cursor: canInteractWithHandles
            ? getResizeCursorForHandle(h.type, obj.rotation || 0)
            : "default",
        }}
        onMouseDown={(e) => {
          if (canInteractWithHandles)
            onResizeHandleMouseDown(e, obj.id, h.type);
          else e.stopPropagation();
        }}
      />,
    );
  });
  

  const midPointXObjScaled = (obj.width / 2) * scale; 
  const midPointYObjScaled = (obj.height / 2) * scale;

  const textOffsetBase = 15; 
  const textOffsetSVG = textOffsetBase * uiScaleFactor; 

  const fontSizeBase = 10; 
  const fontSizeSVG = Math.max(6 * uiScaleFactor, fontSizeBase * uiScaleFactor); 

  const strokeBgWidthBase = 3; 
  const strokeBgWidthSVG = Math.max(
    1 * uiScaleFactor,
    strokeBgWidthBase * uiScaleFactor,
  );

  dimensionTexts.push(
    <text
      key="dim-width"
      x={midPointXObjScaled} 
      y={0 - textOffsetSVG} 
      fontSize={`${fontSizeSVG}px`}
      textAnchor="middle"
      fill={DIMENSION_TEXT_COLOR}
      style={{
        paintOrder: "stroke",
        stroke: DIMENSION_TEXT_BG_COLOR,
        strokeWidth: `${strokeBgWidthSVG}px`,
        strokeLinejoin: "round",
        pointerEvents: "none",
      }}
    >
      {obj.width.toFixed(2)} м
    </text>,
  );
  dimensionTexts.push(
    <text
      key="dim-height"
      x={0 - textOffsetSVG} 
      y={midPointYObjScaled} 
      fontSize={`${fontSizeSVG}px`}
      textAnchor="middle"
      dominantBaseline="middle"
      transform={`rotate(-90, ${0 - textOffsetSVG}, ${midPointYObjScaled})`} 
      fill={DIMENSION_TEXT_COLOR}
      style={{
        paintOrder: "stroke",
        stroke: DIMENSION_TEXT_BG_COLOR,
        strokeWidth: `${strokeBgWidthSVG}px`,
        strokeLinejoin: "round",
        pointerEvents: "none",
      }}
    >
      {obj.height.toFixed(2)} м
    </text>,
  );

  return (
    <>
      {handles}
      {dimensionTexts}
    </>
  );
};

export default React.memo(SelectionExtras);

==== src\components\Configurator\canvas\SnapGuides.jsx ====
import React from "react";
import { SNAP_LINE_COLOR, INITIAL_PPM } from "../configuratorConstants";

const SnapGuides = ({ activeSnapLines, viewTransform }) => {
  if (!activeSnapLines || activeSnapLines.length === 0) {
    return null;
  }

  const { scale } = viewTransform;

  return (
    <g id="snap-guides">
      {activeSnapLines.map((line, index) => {
        const scaledVal = line.val * scale;
        const scaledStart = line.start * scale;
        const scaledEnd = line.end * scale;

        const strokeWidth = Math.max(1, 1 / (scale / INITIAL_PPM));
        const dashArray = `${3 / (scale / INITIAL_PPM)},${2 / (scale / INITIAL_PPM)}`;

        if (line.type === "x") {
          return (
            <line
              key={`snap-x-${index}`}
              x1={scaledVal} 
              y1={scaledStart}
              x2={scaledVal}
              y2={scaledEnd}
              stroke={SNAP_LINE_COLOR}
              strokeWidth={strokeWidth}
              strokeDasharray={dashArray}
              pointerEvents="none" 
            />
          );
        } else {
          return (
            <line
              key={`snap-y-${index}`}
              x1={scaledStart}
              y1={scaledVal}
              x2={scaledEnd}
              y2={scaledVal}
              stroke={SNAP_LINE_COLOR}
              strokeWidth={strokeWidth}
              strokeDasharray={dashArray}
              pointerEvents="none"
            />
          );
        }
      })}
    </g>
  );
};

export default React.memo(SnapGuides);

==== src\components\Configurator\canvas\SvgCanvas.jsx ====
// src/components/Configurator/canvas/SvgCanvas.jsx
import React, { useState, useEffect, useCallback } from "react"; 
import Grid from "./Grid";
import ObjectRendererGroup from "./ObjectRendererGroup";
import SnapGuides from "./SnapGuides";
import MarqueeSelection from "./MarqueeSelection";
import PreviewLine from "./PreviewLine"; // Import PreviewLine

const SvgCanvas = ({
  svgRef,
  viewTransform,
  setViewTransform,
  objects,
  selectedObjectIds,
  lockedObjectIds,
  overlappingObjectIds,
  activeSnapLines,
  marqueeRect,
  modifierKeys,
  addingObjectType,
  isPanningWithSpace,
  draggingState,
  // resizingState, // Resizing is static
  handleMouseMove,
  handleMouseUp,
  handleMouseLeave,
  handleMouseDownOnCanvas,
  handleMouseDownOnObject,
  handleMouseDownOnResizeHandle,
  onAddObject,
  onAddCorridor, // Keep if corridor adding via old UI is still possible
  addingCorridorMode, // Keep if corridor adding via old UI is still possible
  onExpansionPlatformClick, 
  activeMode,
  drawingLineState, // New prop for preview line
}) => {
  const [svgDimensions, setSvgDimensions] = useState({ width: 0, height: 0 });

  useEffect(() => {
    const currentSvg = svgRef.current;
    if (!currentSvg) return;

    const resizeObserver = new ResizeObserver((entries) => {
      for (let entry of entries) {
        const { width, height } = entry.contentRect;
        setSvgDimensions({ width, height });
      }
    });

    resizeObserver.observe(currentSvg);

    const rect = currentSvg.getBoundingClientRect();
    if (rect.width > 0 && rect.height > 0) {
      setSvgDimensions({ width: rect.width, height: rect.height });
    }

    return () => {
      resizeObserver.unobserve(currentSvg);
    };
  }, [svgRef]);

  const localHandleMouseMove = useCallback(
    (e) => {
      if (isPanningWithSpace && draggingState?.isPanning) {
        const dxScreen = e.clientX - draggingState.startScreenX;
        const dyScreen = e.clientY - draggingState.startScreenY;
        setViewTransform((prev) => ({
          ...prev,
          x: draggingState.initialViewX + dxScreen,
          y: draggingState.initialViewY + dyScreen,
        }));
      } else {
        handleMouseMove(e);
      }
    },
    [isPanningWithSpace, draggingState, setViewTransform, handleMouseMove],
  );

  let cursorClass = "cursor-default";
  if (addingObjectType || (drawingLineState && drawingLineState.type) ) {
      cursorClass = "cursor-crosshair";
  } else if (isPanningWithSpace) {
      cursorClass = "cursor-grabbing";
  } else if (modifierKeys.spacebar) {
      cursorClass = "cursor-grab";
  }


  return (
    <svg
      ref={svgRef}
      width="100%"
      height="100%"
      onMouseMove={localHandleMouseMove} 
      onMouseUp={handleMouseUp}
      onMouseLeave={handleMouseLeave}
      onMouseDown={handleMouseDownOnCanvas}
      className={`block bg-white ${cursorClass}`}
    >
      {svgDimensions.width > 0 &&
        svgDimensions.height > 0 && (
          <Grid
            viewTransform={viewTransform}
            svgWidth={svgDimensions.width}
            svgHeight={svgDimensions.height}
          />
        )}
      <g transform={`translate(${viewTransform.x}, ${viewTransform.y})`}>
        <ObjectRendererGroup
          objects={objects}
          viewTransform={viewTransform}
          selectedObjectIds={selectedObjectIds}
          lockedObjectIds={lockedObjectIds}
          overlappingObjectIds={overlappingObjectIds}
          modifierKeys={modifierKeys}
          handleMouseDownOnObject={handleMouseDownOnObject}
          handleMouseDownOnResizeHandle={handleMouseDownOnResizeHandle} // Does nothing for static
          // draggingState={draggingState} // Not needed for static rendering of objects
          // resizingState={null} // Not needed for static rendering of objects
          onAddObject={onAddObject}
          // addingCorridorMode={addingCorridorMode} // Old way of adding corridors
          onAddCorridor={onAddCorridor} // Old way of adding corridors
          svgRef={svgRef}
          // onExpansionPlatformClick={onExpansionPlatformClick} // Disabled for static
          activeMode={activeMode}
        />
        <SnapGuides
          activeSnapLines={activeSnapLines} // Will be empty for static objects
          viewTransform={viewTransform}
        />
        <PreviewLine drawingLineState={drawingLineState} viewTransform={viewTransform} />
      </g>
      <MarqueeSelection marqueeRect={marqueeRect} svgRef={svgRef} /> 
    </svg>
  );
};

export default SvgCanvas; 

==== src\components\Configurator\canvas\WindowVisual.jsx ====
import React from "react";
import {
    ARCH_BLACK,
    ARCH_MID_GRAY,
    ARCH_STROKE_MEDIUM,
    ARCH_STROKE_THICK,
    ARCH_STROKE_THIN,
    ARCH_STROKE_VERY_THIN,
    ARCH_SELECT_BLUE,
    ARCH_WINDOW_FRAME_STROKE,
    ARCH_WINDOW_GLAZING_STROKE,
    INITIAL_PPM
} from "../configuratorConstants";

const WindowVisual = ({ obj, scale, commonProps, isSelected }) => {
  const widthScaled = obj.width * scale;
  const heightScaled = obj.height * scale;

  const baseFrameStrokeWidth = Math.max(0.2, ARCH_STROKE_THICK / (scale / INITIAL_PPM));
  const baseGlazingStrokeWidth = Math.max(0.1, ARCH_STROKE_THIN / (scale / INITIAL_PPM));
  const baseMullionStrokeWidth = Math.max(0.15, ARCH_STROKE_MEDIUM / (scale / INITIAL_PPM));

  const frameStrokeWidth = isSelected ? ARCH_STROKE_MEDIUM : baseFrameStrokeWidth;
  const glazingStrokeWidth = isSelected ? ARCH_STROKE_THIN : baseGlazingStrokeWidth;
  const mullionStrokeWidth = isSelected ? ARCH_STROKE_MEDIUM : baseMullionStrokeWidth;

  const numGlazingLines = 3;
  const glazingLines = [];
  const spacing = heightScaled / (numGlazingLines + 1);
  for(let i=1; i <= numGlazingLines; i++){
       glazingLines.push(
         <line key={`glaze${i}`} x1={0} y1={spacing * i} x2={widthScaled} y2={spacing * i} stroke={ARCH_WINDOW_GLAZING_STROKE} strokeWidth={glazingStrokeWidth} />
       );
  }

  return (
    <>
      <rect
        x="0"
        y="0"
        width={widthScaled}
        height={heightScaled}
        fill="none"
        stroke={isSelected ? ARCH_SELECT_BLUE : ARCH_WINDOW_FRAME_STROKE}
        strokeWidth={frameStrokeWidth}
        style={commonProps.style}
        data-object-id={commonProps['data-object-id']}
      />
      {glazingLines}
      <line
         x1={widthScaled / 2}
         y1={0}
         x2={widthScaled / 2}
         y2={heightScaled}
         stroke={isSelected ? ARCH_SELECT_BLUE : ARCH_WINDOW_FRAME_STROKE}
         strokeWidth={mullionStrokeWidth}
       />
    </>
  );
};

export default React.memo(WindowVisual);

==== src\components\Configurator\common\PropertyInput.jsx ====
import React from "react";
import PropTypes from "prop-types";

const PropertyInput = ({
  label,
  type = "number",
  value,
  onChange,
  step = 0.01,
  children,
  disabled,
  ...props
}) => (
  <div className="mb-2">
    <label className="block text-xs text-gray-600 mb-1">{label}</label>
    {children || (
      <input
        type={type}
        value={value}
        onChange={onChange}
        step={step}
        className={`w-full p-1 border border-gray-300 rounded text-sm focus:ring-1 focus:ring-blue-500 outline-none ${disabled ? "bg-gray-100 cursor-not-allowed" : ""}`}
        disabled={disabled}
        {...props}
      />
    )}
  </div>
);

PropertyInput.propTypes = {
  label: PropTypes.string.isRequired,
  type: PropTypes.string,
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
  onChange: PropTypes.func.isRequired,
  step: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  children: PropTypes.node,
  disabled: PropTypes.bool,
  min: PropTypes.string, 
  max: PropTypes.string,
  title: PropTypes.string,
};

export default PropertyInput;

==== src\components\Configurator\Configurator.jsx ====
// src/components/Configurator/Configurator.jsx
import React, { useState, useEffect, useRef, useCallback } from "react";
import PropTypes from "prop-types";
import { MODES, DEFAULT_MODE } from "./appConstants";
import { OBJECT_TYPES_TO_ADD, WALL_THICKNESS_M } from "./configuratorConstants"; 

import useConfiguratorState from "./hooks/useConfiguratorState";
import useObjectManagement from "./hooks/useObjectManagement";
import useViewTransform from "./hooks/useViewTransform";
import useModifierKeys from "./hooks/useModifierKeys";
import useMouseInteractions from "./hooks/useMouseInteractions";
import useKeyboardShortcuts from "./hooks/useKeyboardShortcuts";

import ConfiguratorToolbar from "./toolbar/ConfiguratorToolbar";
import SvgCanvas from "./canvas/SvgCanvas";
import PropertiesPanel from "./sidebar/PropertiesPanel";
import StatusBar from "./statusbar/StatusBar";

import ModularMode from "./modes/ModularMode";
import FramelessMode from "./modes/FramelessMode";
import FrameMode from "./modes/FrameMode";

import { getInitialObjects } from "./hooks/useObjectManagement";
import { toast } from "react-toastify";


const Configurator = ({
  activeMode: activeModeProp,
  setProjectInfoData: setProjectInfoDataProp,
  renderModeSpecificUI: renderModeSpecificUIProp,
}) => {
  const [activeModeInternal, setActiveModeInternal] = useState(
    activeModeProp !== undefined ? activeModeProp : DEFAULT_MODE
  );
  const setProjectInfoDataExt = setProjectInfoDataProp || (() => {});
  const renderModeSpecificUIExt = renderModeSpecificUIProp || (() => null);

  const svgRef = useRef(null);
  const mainContainerRef = useRef(null);

  const {
    objects,
    objectsRef,
    setObjects,
    selectedObjectIds,
    setSelectedObjectIds,
    lockedObjectIds,
    setLockedObjectIds,
    history,
    setHistory,
    handleUndo,
    handleRedo,
    primarySelectedObject,
    // overlappingObjectIds, // This was from useConfiguratorState
    // setOverlappingObjectIds, // This was from useConfiguratorState
  } = useConfiguratorState(setProjectInfoDataExt, activeModeInternal);

  // If overlaps are truly disabled, provide a default empty array
  const overlappingObjectIds = []; // Default to empty if not managed

  const modifierKeys = useModifierKeys(mainContainerRef, svgRef);

  const {
    addObject,
    updateObject,
    deleteObjectById,
    updateSelectedObjectProperty,
    addAndSelectObject,
    defaultObjectSizes,
    rotateModule180,
    mirrorModuleX,
    mirrorModuleY,
  } = useObjectManagement(
    setObjects,
    selectedObjectIds,
    lockedObjectIds,
    modifierKeys,
    objectsRef,
    activeModeInternal
  );

  const { viewTransform, setViewTransform, screenToWorld, screenToWorldRect } =
    useViewTransform(svgRef);

  const [addingObjectType, setAddingObjectType] = useState(null);
  const [addingCorridorMode, setAddingCorridorMode] = useState(false); 

  const mouseInteractions = useMouseInteractions({
    objectsRef,
    selectedObjectIds,
    setSelectedObjectIds,
    lockedObjectIds,
    setHistory,
    viewTransform,
    screenToWorld,
    screenToWorldRect,
    modifierKeys,
    addingObjectType,
    setAddingObjectType,
    addAndSelectObject, 
    mainContainerRef,
    svgRef,
    activeMode: activeModeInternal,
  });

  useKeyboardShortcuts({
    mainContainerRef,
    selectedObjectIds,
    setSelectedObjectIds,
    lockedObjectIds,
    setLockedObjectIds,
    objectsRef,
    setObjects, 
    handleUndo,
    handleRedo,
    addingObjectType,
    setAddingObjectType,
    marqueeRectActive: false, 
    resizingStateActive: false, 
  });

  useEffect(() => {
    mainContainerRef.current?.focus();
  }, []);

  useEffect(() => {
    if (activeModeProp !== undefined && activeModeProp !== activeModeInternal) {
        setActiveModeInternal(activeModeProp);
    }
  }, [activeModeProp, activeModeInternal]);


  const handleStartAddObject = useCallback(
    (type) => {
      setAddingObjectType(type);
      setSelectedObjectIds([]);
    },
    [setSelectedObjectIds],
  );

  const handleDeleteSelectedObjectInPanel = useCallback(() => {
    if (
      primarySelectedObject &&
      (!lockedObjectIds.includes(primarySelectedObject.id) ||
        modifierKeys.shift)
    ) {
      deleteObjectById(primarySelectedObject.id); 
      setSelectedObjectIds((ids) =>
        ids.filter((id) => id !== primarySelectedObject.id),
      );
    }
  }, [
    primarySelectedObject,
    lockedObjectIds,
    modifierKeys.shift,
    deleteObjectById,
    setSelectedObjectIds,
  ]);

  const handleAddCorridor = useCallback((corridorData) => {
    const blockSize = 1;
    const visualCorridorLineThickness = 0.01;

    const isVertical = corridorData.orientation === 'vertical';
    let finalX, finalY, corridorWidth, corridorHeight;

    if (isVertical) {
      corridorWidth = visualCorridorLineThickness;
      corridorHeight = blockSize;
      finalX = corridorData.x - visualCorridorLineThickness / 2;
      finalY = corridorData.y;
    } else {
      corridorWidth = blockSize;
      corridorHeight = visualCorridorLineThickness;
      finalX = corridorData.x;
      finalY = corridorData.y - visualCorridorLineThickness / 2;
    }

    addObject(
      'corridor',
      finalX,
      finalY,
      corridorWidth,
      corridorHeight,
      {
        orientation: corridorData.orientation,
        parentId: corridorData.parentId,
        logicalThickness: WALL_THICKNESS_M 
      }
    );
    setAddingCorridorMode(false);
  }, [addObject]);


  function getInitialObjectsForMode(mode) {
    if (mode === MODES.FRAMELESS) return getInitialObjects();
    if (mode === MODES.MODULAR) return []; 
    return [];
  }

  const handleModeChange = useCallback((newMode) => {
    if (newMode === activeModeInternal) return;
    if (objects.length > 0) {
      const confirmed = window.confirm(
        "При смене режима все несохраненные изменения будут потеряны. Продолжить?"
      );
      if (!confirmed) return;
    }
    setObjects(getInitialObjectsForMode(newMode));
    setSelectedObjectIds([]);
    setLockedObjectIds([]);
    setHistory({ undo: [], redo: [] });
    setAddingObjectType(null);
    setActiveModeInternal(newMode);
  }, [activeModeInternal, objects, setObjects, setSelectedObjectIds, setLockedObjectIds, setHistory]);

  const configuratorInterface = {
    addObject, 
    updateObject, 
    deleteObject: deleteObjectById, 
    getObjects: () => objectsRef.current,
    getSelectedObjectIds: () => selectedObjectIds,
    setSelectedObjectIds,
    screenToWorld,
    viewTransform,
    svgRef,
    activeMode: activeModeInternal,
    objects, 
  };

  const renderModeComponent = () => {
    switch (activeModeInternal) {
      case MODES.MODULAR:
        return <ModularMode {...configuratorInterface} />;
      case MODES.FRAMELESS:
        return <FramelessMode {...configuratorInterface} />;
      case MODES.FRAMED:
        return <FrameMode {...configuratorInterface} />;
      default:
        return null;
    }
  };

  return (
    <div
      ref={mainContainerRef}
      className="w-full h-full flex flex-col select-none outline-none"
      tabIndex={0}
    >
      <ConfiguratorToolbar
        activeModeName={activeModeInternal}
        addingObjectType={addingObjectType}
        onStartAddObject={handleStartAddObject}
        onModeChange={handleModeChange}
        selectedObjectIds={selectedObjectIds}
        primarySelectedObject={primarySelectedObject}
      />

      <div className="flex flex-grow overflow-hidden">
        <div className="flex-grow relative bg-gray-200">
          {addingCorridorMode && (
            <div className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-indigo-100 text-indigo-900 px-4 py-2 rounded shadow z-30">
              Кликните по линии внутри модуля для размещения коридора
              <button
                className="ml-4 text-indigo-700 underline"
                onClick={() => setAddingCorridorMode(false)}
              >
                Отмена
              </button>
            </div>
          )}
          <SvgCanvas
            svgRef={svgRef}
            viewTransform={viewTransform}
            setViewTransform={setViewTransform}
            objects={objects}
            selectedObjectIds={selectedObjectIds}
            lockedObjectIds={lockedObjectIds}
            overlappingObjectIds={overlappingObjectIds} // Ensure this is passed
            activeSnapLines={mouseInteractions.activeSnapLines} 
            marqueeRect={mouseInteractions.marqueeRect} 
            modifierKeys={modifierKeys}
            addingObjectType={addingObjectType}
            isPanningWithSpace={mouseInteractions.isPanningWithSpace}
            draggingState={mouseInteractions.draggingState} 
            handleMouseMove={mouseInteractions.handleMouseMove}
            handleMouseUp={mouseInteractions.handleMouseUp}
            handleMouseLeave={mouseInteractions.handleMouseLeave}
            handleMouseDownOnCanvas={mouseInteractions.handleMouseDownOnCanvas}
            handleMouseDownOnObject={mouseInteractions.handleMouseDownOnObject}
            handleMouseDownOnResizeHandle={
              mouseInteractions.handleMouseDownOnResizeHandle 
            }
            onAddObject={addObject}
            addingCorridorMode={addingCorridorMode}
            onAddCorridor={handleAddCorridor}
            activeMode={activeModeInternal}
          />
          {addingObjectType && (
            <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-yellow-300 text-black px-3 py-1.5 rounded shadow-lg text-xs z-10 pointer-events-none">
              Клик для добавления "
              {
                OBJECT_TYPES_TO_ADD.find((o) => o.type === addingObjectType)
                  ?.label
              }
              ". ESC для отмены.
            </div>
          )}
          {renderModeComponent()}
          {renderModeSpecificUIExt && (
            <div className="absolute top-2 left-2 p-0 z-20">
              {renderModeSpecificUIExt(configuratorInterface)}
            </div>
          )}
        </div>

        <PropertiesPanel
          primarySelectedObject={primarySelectedObject}
          selectedObjectIds={selectedObjectIds}
          lockedObjectIds={lockedObjectIds}
          modifierKeys={modifierKeys}
          updateSelectedObjectProperty={updateSelectedObjectProperty}
          deleteSelectedObject={handleDeleteSelectedObjectInPanel}
          activeMode={activeModeInternal}
          rotateModule180={rotateModule180} 
          mirrorModuleX={mirrorModuleX}     
          mirrorModuleY={mirrorModuleY}     
        />
      </div>

      <StatusBar
        selectedObjectIds={selectedObjectIds}
        primarySelectedObject={primarySelectedObject}
        lockedObjectIds={lockedObjectIds}
        history={history}
      />
    </div>
  );
};

Configurator.propTypes = {
  activeMode: PropTypes.oneOf(Object.values(MODES)),
  setProjectInfoData: PropTypes.func,
  renderModeSpecificUI: PropTypes.func,
};

export default Configurator;

==== src\components\Configurator\configuratorConstants.js ====
// src/components/Configurator/configuratorConstants.js
import {
  DEFAULT_PANEL_WIDTH_M as APP_DEFAULT_PANEL_WIDTH_M,
  WALL_THICKNESS_M as APP_WALL_THICKNESS_M, 
  DOOR_WIDTH_M as APP_DOOR_WIDTH_M,
  WINDOW_WIDTH_M as APP_WINDOW_WIDTH_M,
  DEFAULT_MODULE_WIDTH_M,
  DEFAULT_MODULE_HEIGHT_M,
  INTERNAL_ELEMENT_SNAP_GRID_SIZE,
} from "./appConstants";


const ARCH_BLACK = "#1A202C";
const ARCH_DARK_GRAY = "#4A5568";
const ARCH_MID_GRAY = "#718096";
const ARCH_LIGHT_GRAY = "#CBD5E0";
const ARCH_VERY_LIGHT_GRAY = "#E2E8F0";
const ARCH_WHITE = "#FFFFFF";
const ARCH_SELECT_BLUE = "rgba(0, 100, 255, 0.8)";
const ARCH_CORRIDOR_STROKE = ARCH_DARK_GRAY;
const ARCH_INTERNAL_WALL_FILL = ARCH_WHITE; // Or a slightly different shade
const ARCH_DOOR_LEAF_FILL = ARCH_WHITE;
const ARCH_DOOR_STROKE = ARCH_BLACK;
const ARCH_WINDOW_FRAME_STROKE = ARCH_BLACK;
const ARCH_WINDOW_GLAZING_STROKE = ARCH_MID_GRAY;
const ARCH_OUTLET_FILL = ARCH_WHITE;
const ARCH_OUTLET_STROKE = ARCH_BLACK;
const ARCH_HATCH_COLOR = ARCH_LIGHT_GRAY;
const ARCH_FURNITURE_FILL_LIGHT = ARCH_WHITE;
const ARCH_FURNITURE_FILL_MID = ARCH_VERY_LIGHT_GRAY;
const ARCH_FURNITURE_STROKE = ARCH_DARK_GRAY;

const ARCH_STROKE_THICK = 1.2;
const ARCH_STROKE_MEDIUM = 0.8;
const ARCH_STROKE_THIN = 0.5;
const ARCH_STROKE_VERY_THIN = 0.3;

export const PANEL_SIZE_M = APP_DEFAULT_PANEL_WIDTH_M;
export const INITIAL_PPM = 50;
export const GRID_LINE_COLOR = ARCH_VERY_LIGHT_GRAY;
export const GRID_BOLD_LINE_COLOR = ARCH_LIGHT_GRAY;
export const ORIGIN_POINT_COLOR = "transparent";
export const SNAP_THRESHOLD_WORLD = 0.05;
export const SNAP_LINE_COLOR = "rgba(0, 150, 255, 0.6)";
export const PASTE_OFFSET_M = 0.2;
export const MAX_HISTORY_SIZE = 50;
export const MARQUEE_FILL_COLOR = "rgba(0, 100, 255, 0.1)";
export const MARQUEE_STROKE_COLOR = "rgba(0, 100, 255, 0.5)";
export const MIN_DRAG_FOR_MARQUEE_PAN = 5;
export const RESIZE_HANDLE_SIZE_PX = 8;
export const RESIZE_HANDLE_COLOR = ARCH_SELECT_BLUE;
export const DIMENSION_TEXT_COLOR = ARCH_BLACK;
export const DIMENSION_TEXT_BG_COLOR = "rgba(255, 255, 255, 0.8)";
export const OVERLAP_HIGHLIGHT_COLOR = "rgba(255, 0, 0, 0.2)";
export const LOCKED_OBJECT_STROKE_COLOR = "orange";
export const DOOR_LEAF_VISUAL_THICKNESS_M = 0.04;
export const WALL_THICKNESS_M = APP_WALL_THICKNESS_M; 
export { INTERNAL_ELEMENT_SNAP_GRID_SIZE };


export const PREVIEW_LINE_COLOR = "rgba(255, 165, 0, 0.7)";
export const PREVIEW_LINE_STROKE_WIDTH = 2;


export const objectColors = {
  panel: ARCH_WHITE,
  window: ARCH_BLACK,
  door: ARCH_BLACK,
  outlet: ARCH_BLACK,
  wall: ARCH_BLACK, // For external walls or if internal uses same
  partition: ARCH_INTERNAL_WALL_FILL, // For internal walls if different
  default: ARCH_MID_GRAY,
  sofa: ARCH_WHITE,
  table: ARCH_WHITE,
  cabinet: ARCH_WHITE,
  toilet: ARCH_WHITE,
  bed: ARCH_WHITE,
  corridor: ARCH_CORRIDOR_STROKE,
  light_led: ARCH_BLACK,
  module: ARCH_WHITE,
  radiator: ARCH_LIGHT_GRAY,
  kitchen_unit: ARCH_MID_GRAY,
};

export const defaultObjectSizes = {
  panel: { width: PANEL_SIZE_M, height: PANEL_SIZE_M },
  window: { width: APP_WINDOW_WIDTH_M, height: APP_WALL_THICKNESS_M },
  door: { width: APP_DOOR_WIDTH_M, height: APP_WALL_THICKNESS_M },
  outlet: { width: 0.1, height: 0.1 },
  wall: { width: PANEL_SIZE_M, height: APP_WALL_THICKNESS_M }, // Default for external or generic wall
  partition: { width: PANEL_SIZE_M, height: APP_WALL_THICKNESS_M }, // Default for internal partition
  sofa: { width: 1.8, height: 0.8 },
  table: { width: 1.0, height: 0.5 },
  cabinet: { width: 0.8, height: 0.4 },
  toilet: { width: 0.4, height: 0.7 },
  bed: { width: 1.5, height: 2.0 },
  corridor: { width: 1.0, height: 0.01 }, // Corridors are thin lines
  light_led: {width: 1.2, height: 0.15},
  module: { width: DEFAULT_MODULE_WIDTH_M, height: DEFAULT_MODULE_HEIGHT_M },
  radiator: { width: 0.8, height: 0.1 }, 
  kitchen_unit: { width: 1.5, height: 0.6 },
};

export const OBJECT_TYPES_TO_ADD = [
  { type: "wall", label: "Стена (внеш.)" }, // Changed label for clarity
  { type: "window", label: "Окно" },
  { type: "door", label: "Дверь" },
  { type: "outlet", label: "Розетка" },
  { type: "light_led", label: "Свет LED"},
  { type: "sofa", label: "Диван" },
  { type: "table", label: "Стол" },
  { type: "cabinet", label: "Шкаф" },
  { type: "bed", label: "Кровать" },
  { type: "toilet", label: "Туалет" },
  { type: "radiator", label: "Радиатор"},
  { type: "kitchen_unit", label: "Кух. блок"},
];

export const INTERNAL_DRAWING_TYPES = {
    PARTITION: 'partition',
    CORRIDOR: 'corridor',
};

export {
    ARCH_BLACK,
    ARCH_DARK_GRAY,
    ARCH_MID_GRAY,
    ARCH_LIGHT_GRAY,
    ARCH_VERY_LIGHT_GRAY,
    ARCH_WHITE,
    ARCH_SELECT_BLUE,
    ARCH_STROKE_THICK,
    ARCH_STROKE_MEDIUM,
    ARCH_STROKE_THIN,
    ARCH_STROKE_VERY_THIN,
    ARCH_CORRIDOR_STROKE,
    ARCH_DOOR_LEAF_FILL,
    ARCH_DOOR_STROKE,
    ARCH_WINDOW_FRAME_STROKE,
    ARCH_WINDOW_GLAZING_STROKE,
    ARCH_FURNITURE_FILL_LIGHT,
    ARCH_FURNITURE_FILL_MID,
    ARCH_FURNITURE_STROKE,
    ARCH_OUTLET_FILL,
    ARCH_OUTLET_STROKE,
    ARCH_HATCH_COLOR,
    ARCH_INTERNAL_WALL_FILL,
};

==== src\components\Configurator\configuratorUtils.js ====
import { DOOR_LEAF_VISUAL_THICKNESS_M } from "./configuratorConstants";

export const rotatePoint = (point, angleRad, center) => {
  const s = Math.sin(angleRad);
  const c = Math.cos(angleRad);
  const px = point.x - center.x;
  const py = point.y - center.y;
  const xNew = px * c - py * s;
  const yNew = px * s + py * c;
  return { x: xNew + center.x, y: yNew + center.y };
};

export const getAABB = (obj) => {
  const { x, y, width, height, rotation = 0 } = obj;
  const angleRad = (rotation * Math.PI) / 180;
  const localCenterX = width / 2;
  const localCenterY = height / 2;
  const worldRotCenterX = x + localCenterX;
  const worldRotCenterY = y + localCenterY;
  const center = { x: worldRotCenterX, y: worldRotCenterY };
  const corners = [
    { x: x, y: y },
    { x: x + width, y: y },
    { x: x + width, y: y + height },
    { x: x, y: y + height },
  ];
  if (rotation === 0 || rotation % 360 === 0) {
    return {
      minX: x,
      minY: y,
      maxX: x + width,
      maxY: y + height,
      centerX: worldRotCenterX,
      centerY: worldRotCenterY,
    };
  }
  const rotatedCorners = corners.map((p) => rotatePoint(p, angleRad, center));
  const minX = Math.min(...rotatedCorners.map((p) => p.x));
  const minY = Math.min(...rotatedCorners.map((p) => p.y));
  const maxX = Math.max(...rotatedCorners.map((p) => p.x));
  const maxY = Math.max(...rotatedCorners.map((p) => p.y));
  return {
    minX,
    minY,
    maxX,
    maxY,
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2,
  };
};

export const checkAABBIntersection = (aabb1, aabb2) =>
  aabb1.minX < aabb2.maxX &&
  aabb1.maxX > aabb2.minX &&
  aabb1.minY < aabb2.maxY &&
  aabb1.maxY > aabb2.minY;

export const getResizeCursorForHandle = (handleType, rotationDeg) => {
  const angle = ((rotationDeg % 360) + 360) % 360;
  let cursor = "default";
  if (["tl", "br"].includes(handleType)) cursor = "nwse-resize";
  if (["tr", "bl"].includes(handleType)) cursor = "nesw-resize";
  if (["t", "b"].includes(handleType)) cursor = "ns-resize";
  if (["l", "r"].includes(handleType)) cursor = "ew-resize";
  const rotationSegment = Math.round(angle / 45) % 8;
  if (rotationSegment === 1 || rotationSegment === 2) {
    if (cursor === "ns-resize") cursor = "nesw-resize";
    else if (cursor === "ew-resize") cursor = "nwse-resize";
    else if (cursor === "nwse-resize") cursor = "ns-resize";
    else if (cursor === "nesw-resize") cursor = "ew-resize";
  } else if (rotationSegment === 3 || rotationSegment === 4) {
    if (cursor === "ns-resize") cursor = "ew-resize";
    else if (cursor === "ew-resize") cursor = "ns-resize";
    else if (cursor === "nwse-resize") cursor = "nesw-resize";
    else if (cursor === "nesw-resize") cursor = "nwse-resize";
  } else if (rotationSegment === 5 || rotationSegment === 6) {
    if (cursor === "ns-resize") cursor = "nesw-resize";
    else if (cursor === "ew-resize") cursor = "nwse-resize";
    else if (cursor === "nwse-resize") cursor = "ns-resize";
    else if (cursor === "nesw-resize") cursor = "ew-resize";
  } else if (rotationSegment === 7) {
    if (cursor === "ns-resize") cursor = "ew-resize";
    else if (cursor === "ew-resize") cursor = "ns-resize";
    else if (cursor === "nwse-resize") cursor = "nesw-resize";
    else if (cursor === "nesw-resize") cursor = "nwse-resize";
  }
  return cursor;
};


export const getDoorLeafCorners = (door, currentOpeningAngleDegrees) => {
    const {
        x: objX, y: objY, 
        width: frameWidth, 
        height: frameThickness, 
        rotation: objRotationDeg = 0, 
        hingeSide,
        openingDirection
    } = door;

    const leafVisualThickness = DOOR_LEAF_VISUAL_THICKNESS_M; 
    const doorLeafLength = frameWidth; 

    const objRotationRad = objRotationDeg * (Math.PI / 180);

    let hingeLocalX = (hingeSide === 'left') ? 0 : frameWidth;
    let hingeLocalY = frameThickness / 2; 

    const leafCornersRelativeToHingeClosed = [
        { x: 0,                               y: -leafVisualThickness / 2 },
        { x: (hingeSide === 'left' ? doorLeafLength : -doorLeafLength), y: -leafVisualThickness / 2 },
        { x: (hingeSide === 'left' ? doorLeafLength : -doorLeafLength), y:  leafVisualThickness / 2 },
        { x: 0,                               y:  leafVisualThickness / 2 },
    ];

    let swingAngleRad = 0;
    if (currentOpeningAngleDegrees !== 0) {
        let angle = currentOpeningAngleDegrees;
        if (openingDirection === 'outward') angle *= -1;
        swingAngleRad = (hingeSide === 'left' ? angle : -angle) * (Math.PI / 180);
    }

    const cornersAfterSwing = leafCornersRelativeToHingeClosed.map(p =>
        rotatePoint(p, swingAngleRad, { x: 0, y: 0 })
    );

    const cornersInFrameLocalSpace = cornersAfterSwing.map(p => ({
        x: p.x + hingeLocalX,
        y: p.y + hingeLocalY,
    }));

    const frameRotCenterX = frameWidth / 2;
    const frameRotCenterY = frameThickness / 2;
    const cornersAfterFrameRotation = cornersInFrameLocalSpace.map(p =>
        rotatePoint(p, objRotationRad, { x: frameRotCenterX, y: frameRotCenterY })
    );

    const worldCorners = cornersAfterFrameRotation.map(p => ({
        x: p.x + objX,
        y: p.y + objY,
    }));

    return worldCorners;
};

export const getAABBFromCorners = (corners) => {
    if (!corners || corners.length < 2) return { minX: 0, minY: 0, maxX: 0, maxY: 0, centerX:0, centerY:0 };
    const minX = Math.min(...corners.map(p => p.x));
    const minY = Math.min(...corners.map(p => p.y));
    const maxX = Math.max(...corners.map(p => p.x));
    const maxY = Math.max(...corners.map(p => p.y));
    return { minX, minY, maxX, maxY, centerX: (minX + maxX) / 2, centerY: (minY + maxY) / 2 };
};

export const isDoorLeafColliding = (doorObj, openingAngleDegrees, allOtherObjects) => {
    if (openingAngleDegrees === 0) return false; 

    const doorLeafWorldCorners = getDoorLeafCorners(doorObj, openingAngleDegrees);
    const doorLeafAABB = getAABBFromCorners(doorLeafWorldCorners);

    for (const otherObj of allOtherObjects) {
        if (otherObj.id === doorObj.id) continue; 
        
        if (doorObj.parentId && otherObj.id === doorObj.parentId) {
            continue; 
        }

        const otherAABB = getAABB(otherObj); 
        
        if (checkAABBIntersection(doorLeafAABB, otherAABB)) {
            if (otherObj.type === 'door' && otherObj.isOpen && otherObj.openingAngle > 0) {
                const otherDoorLeafCorners = getDoorLeafCorners(otherObj, otherObj.openingAngle);
                const otherDoorLeafAABB = getAABBFromCorners(otherDoorLeafCorners);
                if (checkAABBIntersection(doorLeafAABB, otherDoorLeafAABB)) {
                    return true; 
                }
                 return true; 
            } else {
                 return true; 
            }
        }
    }
    return false; 
};

==== src\components\Configurator\ElementRenderer.jsx ====
import React from 'react';
import PropTypes from 'prop-types'; 
import {
    RENDER_SCALE,
    DOOR_LEAF_THICKNESS_PX,
    DOOR_HANDLE_SIZE_PX,
    DOOR_HANDLE_OFFSET_FROM_EDGE_PX,
} from './constants'; 

const ElementRenderer = ({ element, wallThicknessPx, isSelected, onClick }) => {
    const {
        id,
        type,
        position, 
        rotation, 
        width: elementWidthMm, 
        isOpen,
        openingSide, 
        openingDirection, 
        moduleId, 
    } = element;

    if (!id || !type || !position || typeof position.x !== 'number' || typeof position.y !== 'number' || typeof rotation !== 'number' || typeof elementWidthMm !== 'number') {
        return null;
    }
    
    const elementTypeNormalized = type.toLowerCase();
    const elementWidthPx = elementWidthMm * RENDER_SCALE;

    if (elementWidthPx <= 0) {
        return null;
    }


    const groupTransform = `translate(${position.x.toFixed(3)}, ${position.y.toFixed(3)}) rotate(${rotation.toFixed(3)})`;

    const handleClick = (e) => {
        e.stopPropagation(); 
        if (onClick) {
            onClick(element, e); 
        }
    };

    const gProps = {
        'data-module-id': moduleId,
        'data-element-id': id,
        'data-interactive': 'true',
        style: { 
            cursor: onClick ? 'pointer' : 'default',
            outline: isSelected ? '1px dashed #007bff' : 'none', 
            outlineOffset: '2px', 
        },
        onClick: handleClick,
        transform: groupTransform,
    };


    if (elementTypeNormalized.includes('drzwi')) {
        const doorLeafWidthPx = elementWidthPx;
        const doorLeafThicknessPx = DOOR_LEAF_THICKNESS_PX;

        let swingAngleDeg = 0; 
        if (isOpen) {
            if (openingDirection === 'inward') {
                swingAngleDeg = (openingSide === 'left') ? 90 : -90;
            } else { 
                swingAngleDeg = (openingSide === 'left') ? -90 : 90;
            }
        }

        const leafPath = openingSide === 'left'
            ? `M 0 ${-doorLeafThicknessPx / 2} L ${doorLeafWidthPx} ${-doorLeafThicknessPx / 2} L ${doorLeafWidthPx} ${doorLeafThicknessPx / 2} L 0 ${doorLeafThicknessPx / 2} Z`
            : `M 0 ${-doorLeafThicknessPx / 2} L ${-doorLeafWidthPx} ${-doorLeafThicknessPx / 2} L ${-doorLeafWidthPx} ${doorLeafThicknessPx / 2} L 0 ${doorLeafThicknessPx / 2} Z`;
        
        const handleOffsetFromEdge = DOOR_HANDLE_OFFSET_FROM_EDGE_PX; 
        const handleRadius = DOOR_HANDLE_SIZE_PX / 2;
        const handleCenterX = openingSide === 'left'
            ? doorLeafWidthPx - handleOffsetFromEdge - handleRadius
            : -doorLeafWidthPx + handleOffsetFromEdge + handleRadius;
        const handleCenterY = 0; 

        let arcPathD = "";
        if (isOpen) {
            const radius = doorLeafWidthPx;
            const startX = 0; 
            const startY = 0;

            const endX_arc = radius * Math.cos(swingAngleDeg * Math.PI / 180);
            const endY_arc = radius * Math.sin(swingAngleDeg * Math.PI / 180);
            
            let sweepFlag;
            if (openingSide === 'left') {
                sweepFlag = (openingDirection === 'inward') ? 1 : 0; 
            } else { 
                sweepFlag = (openingDirection === 'inward') ? 0 : 1; 
            }

            const lineToX = (openingSide === 'left') ? doorLeafWidthPx : -doorLeafWidthPx;

            arcPathD = `M ${startX} ${startY} L ${lineToX} ${startY} A ${radius} ${radius} 0 0 ${sweepFlag} ${endX_arc} ${endY_arc}`;
        }

        return (
            <g {...gProps}>
                <g transform={`rotate(${swingAngleDeg})`}>
                    <path
                        d={leafPath}
                        fill={isSelected ? "rgba(75, 125, 230, 0.5)" : "rgba(160, 120, 80, 0.6)"} 
                        stroke={isSelected ? "#3B82F6" : "#6D513D"}
                        strokeWidth="0.5" 
                    />
                    <circle
                        cx={handleCenterX}
                        cy={handleCenterY}
                        r={handleRadius}
                        fill={isOpen ? "#A0A0A0" : "#808080"} 
                        stroke="#505050"
                        strokeWidth="0.2"
                    />
                </g>
                {isOpen && (
                    <path
                        d={arcPathD}
                        fill="none"
                        stroke={isSelected ? "#3B82F6" : "#A0A0A0"}
                        strokeWidth="0.3" 
                        strokeDasharray="1.5,1.5" 
                    />
                )}
            </g>
        );

    } else if (elementTypeNormalized.includes('okno')) {
        if (typeof wallThicknessPx !== 'number' || wallThicknessPx <= 0) {
            return ( 
                <g {...gProps}>
                    <text x="0" y="0" fontSize="3" fill="red">Invalid Wall</text>
                </g>
            );
        }
        const windowDrawWidthPx = elementWidthPx; 
        
        return (
            <g {...gProps}>
                <rect
                    x={-windowDrawWidthPx / 2}
                    y={-wallThicknessPx / 2}
                    width={windowDrawWidthPx}
                    height={wallThicknessPx}
                    fill={isSelected ? "rgba(135, 206, 250, 0.6)" : "rgba(173, 216, 230, 0.5)"} 
                    stroke={isSelected ? "#3B82F6" : "#708090"} 
                    strokeWidth="0.5" 
                />
                <line
                    x1="0" y1={-wallThicknessPx / 2}
                    x2="0" y2={wallThicknessPx / 2}
                    stroke={isSelected ? "#FFFFFF" : "#B0C4DE"} 
                    strokeWidth="0.3" 
                />
                <line
                    x1={-windowDrawWidthPx / 2} y1="0"
                    x2={windowDrawWidthPx / 2} y2="0"
                    stroke={isSelected ? "#FFFFFF" : "#B0C4DE"} 
                    strokeWidth="0.3" 
                />
            </g>
        );
    }
    return null; 
};

ElementRenderer.propTypes = {
    element: PropTypes.shape({
        id: PropTypes.string.isRequired,
        type: PropTypes.string.isRequired,
        position: PropTypes.shape({
            x: PropTypes.number.isRequired,
            y: PropTypes.number.isRequired,
        }).isRequired,
        rotation: PropTypes.number.isRequired,
        width: PropTypes.number.isRequired, 
        isOpen: PropTypes.bool,
        openingSide: PropTypes.oneOf(['left', 'right']),
        openingDirection: PropTypes.oneOf(['inward', 'outward']),
        moduleId: PropTypes.string,
    }).isRequired,
    wallThicknessPx: PropTypes.number, 
    isSelected: PropTypes.bool,
    onClick: PropTypes.func,
};

ElementRenderer.defaultProps = {
    isSelected: false,
    onClick: null,
    wallThicknessPx: 0, 
};

export default ElementRenderer;

==== src\components\Configurator\HelpPanel.jsx ====
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { FaQuestionCircle, FaTimes } from 'react-icons/fa';

const HelpPanel = () => {
    const [isOpen, setIsOpen] = useState(false);

    const helpContent = {
        modular: [
            {
                title: 'Створення модуля',
                content: 'Натисніть на кнопку "Додати модуль" або використовуйте комбінацію клавіш Ctrl + M'
            },
            {
                title: 'Переміщення модуля',
                content: 'Перетягніть модуль за його центр або використовуйте стрілки на клавіатурі'
            },
            {
                title: 'Зміна розміру',
                content: 'Перетягніть кутовий маркер модуля для зміни його розміру'
            },
            {
                title: 'Поворот модуля',
                content: 'Використовуйте кнопку повороту або комбінацію клавіш Ctrl + R'
            }
        ],
        frame: [
            {
                title: 'Створення каркасу',
                content: 'Виберіть тип каркасу та вкажіть його розміри'
            },
            {
                title: 'Додавання елементів',
                content: 'Перетягніть елементи з панелі інструментів на каркас'
            }
        ],
        frameless: [
            {
                title: 'Створення стін',
                content: 'Натисніть на кнопку "Додати стіну" та вкажіть її параметри'
            },
            {
                title: 'З\'єднання стін',
                content: 'Перетягніть кінець стіни до іншої стіни для створення з\'єднання'
            }
        ]
    };

    return (
        <>
            <button
                onClick={() => setIsOpen(true)}
                className="fixed bottom-4 left-4 p-3 bg-white rounded-full shadow-lg text-gray-600 hover:text-gray-900 transition-colors"
                title="Довідка"
            >
                <FaQuestionCircle className="w-6 h-6" />
            </button>

            <AnimatePresence>
                {isOpen && (
                    <motion.div
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
                    >
                        <motion.div
                            initial={{ scale: 0.9, opacity: 0 }}
                            animate={{ scale: 1, opacity: 1 }}
                            exit={{ scale: 0.9, opacity: 0 }}
                            className="bg-white rounded-lg p-6 max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto"
                        >
                            <div className="flex justify-between items-center mb-6">
                                <h2 className="text-2xl font-semibold text-gray-800">
                                    Довідка
                                </h2>
                                <button
                                    onClick={() => setIsOpen(false)}
                                    className="p-2 text-gray-500 hover:text-gray-700 transition-colors"
                                >
                                    <FaTimes className="w-5 h-5" />
                                </button>
                            </div>

                            <div className="space-y-6">
                                {Object.entries(helpContent).map(([mode, tips]) => (
                                    <div key={mode} className="space-y-4">
                                        <h3 className="text-lg font-medium text-gray-800 capitalize">
                                            {mode === 'modular' ? 'Модульний режим' :
                                             mode === 'frame' ? 'Каркасний режим' :
                                             'Безкаркасний режим'}
                                        </h3>
                                        <div className="space-y-3">
                                            {tips.map((tip, index) => (
                                                <div
                                                    key={index}
                                                    className="bg-gray-50 rounded-lg p-4"
                                                >
                                                    <h4 className="font-medium text-gray-800 mb-1">
                                                        {tip.title}
                                                    </h4>
                                                    <p className="text-gray-600">
                                                        {tip.content}
                                                    </p>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </motion.div>
                    </motion.div>
                )}
            </AnimatePresence>
        </>
    );
};

export default HelpPanel; 

==== src\components\Configurator\hooks\useConfiguratorState.js ====
// src/components/Configurator/hooks/useConfiguratorState.js
import { useState, useCallback, useRef, useEffect } from "react";
import { MAX_HISTORY_SIZE } from "../configuratorConstants";
import { getInitialObjects } from "./useObjectManagement";

const useConfiguratorState = (setProjectInfoDataProp, activeMode) => {
  const [objects, setObjectsState] = useState(() => {
    if (activeMode === 'modular') return [];
    if (activeMode === 'frameless') return getInitialObjects();
    return [];
  });
  const [selectedObjectIds, setSelectedObjectIds] = useState([]);
  const [lockedObjectIds, setLockedObjectIds] = useState([]);
  const [history, setHistory] = useState({ undo: [], redo: [] });
  // const [copiedObjectsData, setCopiedObjectsData] = useState(null); // Disabled for static
  const [overlappingObjectIds, setOverlappingObjectIds] = useState([]); // Keep for prop consistency

  const objectsRef = useRef(objects);
  useEffect(() => {
    objectsRef.current = objects;
  }, [objects]);

  const setProjectInfoData = setProjectInfoDataProp || (() => {});

  const setObjects = useCallback(
    (newObjectsOrCallback, saveToHistory = false) => {
      const objectsBeforeUpdate = objectsRef.current;
      setObjectsState((prevState) => {
        const newState =
          typeof newObjectsOrCallback === "function"
            ? newObjectsOrCallback(prevState)
            : newObjectsOrCallback;
        if (saveToHistory) {
          if (
            JSON.stringify(newState) !== JSON.stringify(objectsBeforeUpdate)
          ) {
            setHistory((prevHistory) => ({
              undo: [objectsBeforeUpdate, ...prevHistory.undo].slice(
                0,
                MAX_HISTORY_SIZE,
              ),
              redo: [],
            }));
          }
        }
        let totalArea = 0;
        newState.forEach((obj) => {
          if (
            obj &&
            typeof obj.width === "number" &&
            typeof obj.height === "number" &&
            (obj.type === "panel" ||
              obj.type === "wall" ||
              obj.type.match(/sofa|table|cabinet|toilet|bed|module/)) 
          ) {
            totalArea += obj.width * obj.height;
          }
        });
        setProjectInfoData((prev) => ({
          ...prev,
          area: totalArea,
          elements: [{ name: "Objects", count: newState.length }],
        }));
        return newState;
      });
    },
    [setProjectInfoData],
  );

  const handleUndo = useCallback(() => {
    setHistory((prevHistory) => {
      if (prevHistory.undo.length > 0) {
        const stateToRestore = prevHistory.undo[0];
        const remainingUndo = prevHistory.undo.slice(1);
        const currentStateForRedo = objectsRef.current; 
        setObjectsState(stateToRestore); 
        setSelectedObjectIds([]); 
        return {
          undo: remainingUndo,
          redo: [currentStateForRedo, ...prevHistory.redo].slice(
            0,
            MAX_HISTORY_SIZE,
          ),
        };
      }
      return prevHistory;
    });
  }, []);

  const handleRedo = useCallback(() => {
    setHistory((prevHistory) => {
      if (prevHistory.redo.length > 0) {
        const [stateToRestore, ...remainingRedo] = prevHistory.redo;
        const currentStateForUndo = objectsRef.current; 
        setObjectsState(stateToRestore); 
        setSelectedObjectIds([]); 
        return {
          undo: [currentStateForUndo, ...prevHistory.undo].slice(
            0,
            MAX_HISTORY_SIZE,
          ),
          redo: remainingRedo,
        };
      }
      return prevHistory;
    });
  }, []);

  const primarySelectedObject =
    selectedObjectIds.length === 1
      ? objects.find((obj) => obj.id === selectedObjectIds[0])
      : null;

  return {
    objects,
    objectsRef,
    setObjects,
    selectedObjectIds,
    setSelectedObjectIds,
    lockedObjectIds,
    setLockedObjectIds,
    history,
    setHistory, 
    handleUndo,
    handleRedo,
    primarySelectedObject,
    // copiedObjectsData, // Disabled for static
    // setCopiedObjectsData, // Disabled for static
    overlappingObjectIds, // Keep for prop consistency
    setOverlappingObjectIds, // Keep for prop consistency
  };
};

export default useConfiguratorState;

==== src\components\Configurator\hooks\useKeyboardShortcuts.js ====
// src/components/Configurator/hooks/useKeyboardShortcuts.js
import { useEffect, useCallback } from "react";
// import { PASTE_OFFSET_M } from "../configuratorConstants"; // Not needed for static
// import { createObject } from "./useObjectManagement"; // Not needed for paste

const useKeyboardShortcuts = ({
  mainContainerRef,
  selectedObjectIds,
  setSelectedObjectIds,
  lockedObjectIds,
  setLockedObjectIds,
  objectsRef, 
  setObjects, 
  handleUndo,
  handleRedo,
  // copiedObjectsData, // Disabled for static
  // setCopiedObjectsData, // Disabled for static
  addingObjectType, 
  setAddingObjectType,
  marqueeRectActive, // Should be always false for static
  resizingStateActive, // Should be always null for static
}) => {
  const deleteSelectedObjects = useCallback(() => {
    if (selectedObjectIds.length === 0) return;
    const deletableIds = selectedObjectIds.filter(
      (id) => !lockedObjectIds.includes(id),
    );
    if (deletableIds.length > 0) {
      setObjects(
        (prev) => prev.filter((obj) => !deletableIds.includes(obj.id) && (!obj.parentId || !deletableIds.includes(obj.parentId))),
        true,
      );
      setSelectedObjectIds((prev) =>
        prev.filter(
          (id) => !deletableIds.includes(id) || lockedObjectIds.includes(id),
        ),
      );
    }
  }, [selectedObjectIds, lockedObjectIds, setObjects, setSelectedObjectIds]);

  // const copySelectedObjects = useCallback(() => { /* ... */ }, []); // Disabled
  // const pasteCopiedObjects = useCallback(() => { /* ... */ }, []); // Disabled

  useEffect(() => {
    const mainEl = mainContainerRef.current;
    if (!mainEl) return;

    const handleKeyDown = (e) => {
      const isCtrlOrCmd = e.ctrlKey || e.metaKey;
      const activeEl = document.activeElement;
      const isInputFocused =
        activeEl && ["INPUT", "TEXTAREA", "SELECT"].includes(activeEl.tagName);

      if (isInputFocused) {
        if (
          isCtrlOrCmd &&
          ["z", "y"].includes(e.key.toLowerCase()) // Allow undo/redo in inputs if native
        )
          return;
        if (e.key === "Escape") {
          setAddingObjectType(null); 
          if (activeEl instanceof HTMLElement) activeEl.blur();
          return;
        }
        // Allow delete/backspace in inputs
        if (e.key === "Delete" || e.key === "Backspace") return;
      }

      if (isCtrlOrCmd && e.key.toLowerCase() === "z" && !e.shiftKey) {
        e.preventDefault();
        handleUndo();
      } else if (
        (isCtrlOrCmd && e.key.toLowerCase() === "y") ||
        (isCtrlOrCmd && e.shiftKey && e.key.toLowerCase() === "z")
      ) {
        e.preventDefault();
        handleRedo();
      } 
      // Copy and Paste shortcuts disabled for static objects
      // else if (
      //   isCtrlOrCmd &&
      //   e.key.toLowerCase() === "c" &&
      //   !isInputFocused
      // ) { /* ... */ }
      // else if (
      //   isCtrlOrCmd &&
      //   e.key.toLowerCase() === "v" &&
      //   !isInputFocused
      // ) { /* ... */ } 
      else if (
        (e.key === "Delete" || e.key === "Backspace") &&
        selectedObjectIds.length > 0 &&
        !isInputFocused
      ) {
        e.preventDefault();
        deleteSelectedObjects(); // Deletion can still be useful
      } else if (e.key === "Escape") {
        e.preventDefault();
        if (addingObjectType) {
            setAddingObjectType(null);
        } else if (selectedObjectIds.length > 0) {
            setSelectedObjectIds([]);
        } else {
            mainContainerRef.current?.focus(); 
        }
      } else if (e.key.toLowerCase() === "l" && !isInputFocused) {
        e.preventDefault();
        if (selectedObjectIds.length > 0) {
          setLockedObjectIds((prevLockedIds) => {
            const newLockedIds = new Set(prevLockedIds);
            selectedObjectIds.forEach((id) => {
              newLockedIds.has(id)
                ? newLockedIds.delete(id)
                : newLockedIds.add(id);
            });
            return Array.from(newLockedIds);
          });
        }
      }
    };
    mainEl.addEventListener("keydown", handleKeyDown);
    return () => {
      mainEl.removeEventListener("keydown", handleKeyDown);
    };
  }, [
    mainContainerRef,
    selectedObjectIds,
    setSelectedObjectIds,
    lockedObjectIds,
    setLockedObjectIds,
    handleUndo,
    handleRedo,
    // copySelectedObjects, // Disabled
    // pasteCopiedObjects, // Disabled
    deleteSelectedObjects,
    addingObjectType,
    setAddingObjectType,
    // marqueeRectActive, // Always false
    // resizingStateActive, // Always null
    objectsRef, // For deleteSelectedObjects
    setObjects, // For deleteSelectedObjects
  ]);
};

export default useKeyboardShortcuts;

==== src\components\Configurator\hooks\useModifierKeys.js ====
import { useState, useEffect, useCallback } from "react";

const useModifierKeys = (mainContainerRef, svgRef) => {
  const [modifierKeys, setModifierKeys] = useState({
    ctrl: false,
    alt: false,
    meta: false,
    shift: false,
    spacebar: false,
  });

  const handleKeyDown = useCallback(
    (e) => {
      setModifierKeys((prev) => ({
        ...prev,
        ctrl: e.ctrlKey,
        alt: e.altKey,
        meta: e.metaKey,
        shift: e.shiftKey,
        spacebar: e.code === "Space" ? true : prev.spacebar,
      }));

      if (
        e.code === "Space" &&
        mainContainerRef.current &&
        svgRef.current &&
        (document.activeElement === mainContainerRef.current ||
          svgRef.current.contains(document.activeElement))
      ) {
        e.preventDefault();
      }
    },
    [mainContainerRef, svgRef],
  );

  const handleKeyUp = useCallback((e) => {
    setModifierKeys((prev) => ({
      ...prev,
      ctrl: e.ctrlKey,
      alt: e.altKey,
      meta: e.metaKey,
      shift: e.shiftKey,
      spacebar: e.code === "Space" ? false : prev.spacebar,
    }));
  }, []);

  useEffect(() => {
    const mainEl = mainContainerRef.current;
    if (!mainEl) return;

    mainEl.addEventListener("keydown", handleKeyDown);
    mainEl.addEventListener("keyup", handleKeyUp);

    window.addEventListener("keyup", handleKeyUp);

    return () => {
      mainEl.removeEventListener("keydown", handleKeyDown);
      mainEl.removeEventListener("keyup", handleKeyUp);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [mainContainerRef, handleKeyDown, handleKeyUp]);

  return modifierKeys;
};

export default useModifierKeys;


==== src\components\Configurator\hooks\useMouseInteractions.js ====
// src/components/Configurator/hooks/useMouseInteractions.js
import { useState, useCallback, useRef } from "react";
import { getAABB, checkAABBIntersection } from "../configuratorUtils";
import {
  MIN_DRAG_FOR_MARQUEE_PAN,
  MAX_HISTORY_SIZE,
} from "../configuratorConstants";

const useMouseInteractions = ({
  objectsRef,
  // setObjects, // No longer needed for direct manipulation here
  // setObjectsState, // No longer needed for direct manipulation here
  selectedObjectIds,
  setSelectedObjectIds,
  lockedObjectIds, // Kept for selection logic if needed
  setHistory, // Kept for adding new objects
  viewTransform,
  screenToWorld,
  screenToWorldRect,
  modifierKeys,
  addingObjectType,
  setAddingObjectType,
  addAndSelectObject,
  mainContainerRef,
  svgRef,
  // setOverlappingObjectIdsProp, // Overlaps not relevant for static objects
  // activeMode, // Not directly used here anymore for static interactions
}) => {
  const [draggingState, setDraggingState] = useState(null); // Kept for panning
  const [resizingState, setResizingState] = useState(null); // Effectively disabled
  const [marqueeRect, setMarqueeRect] = useState({ active: false }); // Effectively disabled
  const [isPanningWithSpace, setIsPanningWithSpace] = useState(false);
  const [activeSnapLines, setActiveSnapLines] = useState([]); // Effectively disabled
  const mouseDownStartPosRef = useRef(null);

  const handleMouseDownOnObject = useCallback(
    (e, clickedObjectId) => {
      e.stopPropagation();
      if (addingObjectType) return;

      mainContainerRef.current?.focus();
      // Simplified selection logic without initiating drag
      const objectIsLocked = lockedObjectIds.includes(clickedObjectId);
      if (objectIsLocked && !modifierKeys.shift) {
        // If locked and not shift-clicking, only select if not already selected
        if (!selectedObjectIds.includes(clickedObjectId)) {
            setSelectedObjectIds([clickedObjectId]);
        }
        return;
      }


      const newSelectedIds = modifierKeys.shift
        ? selectedObjectIds.includes(clickedObjectId)
          ? selectedObjectIds.filter((id) => id !== clickedObjectId)
          : [...selectedObjectIds, clickedObjectId]
        : selectedObjectIds.includes(clickedObjectId) && selectedObjectIds.length === 1 && selectedObjectIds[0] === clickedObjectId
          ? selectedObjectIds // Keep selection if clicking the same single selected object
          : [clickedObjectId]; // Otherwise, select only the clicked one
      setSelectedObjectIds(newSelectedIds);
      setDraggingState(null); // Ensure no dragging state is set
      setResizingState(null); // Ensure no resizing state is set
    },
    [
      addingObjectType,
      lockedObjectIds,
      modifierKeys.shift,
      selectedObjectIds,
      setSelectedObjectIds,
      mainContainerRef,
    ],
  );

  const handleMouseDownOnResizeHandle = useCallback((e) => {
    e.stopPropagation();
    // Do nothing, resizing is disabled
  }, []);

  const handleMouseDownOnCanvas = useCallback(
    (e) => {
      mainContainerRef.current?.focus();
      if (e.button !== 0) return;

      if (addingObjectType) {
        const { x: worldX, y: worldY } = screenToWorld(e.clientX, e.clientY);
        // History is saved by addAndSelectObject
        const newId = addAndSelectObject(addingObjectType, worldX, worldY);
        setSelectedObjectIds([newId]);
        setAddingObjectType(null);
      } else if (modifierKeys.spacebar) {
        setIsPanningWithSpace(true);
        setDraggingState({
          isPanning: true,
          startScreenX: e.clientX,
          startScreenY: e.clientY,
          initialViewX: viewTransform.x,
          initialViewY: viewTransform.y,
        });
      } else {
        // Clear selection if not shift-clicking and not starting a pan/add
        if (!modifierKeys.shift) {
          setSelectedObjectIds([]);
        }
      }
      setMarqueeRect({ active: false }); // Ensure marquee is never active
      setActiveSnapLines([]);
    },
    [
      addingObjectType,
      setAddingObjectType,
      modifierKeys,
      screenToWorld,
      addAndSelectObject,
      setSelectedObjectIds,
      viewTransform.x,
      viewTransform.y,
      mainContainerRef,
      setHistory, // Ensure setHistory is available if addAndSelectObject uses it implicitly
    ],
  );

  const handleMouseMove = useCallback(
    (_e) => {
      // Panning is handled in SvgCanvas's localHandleMouseMove
      // No object dragging or resizing logic needed here
      if (isPanningWithSpace && draggingState?.isPanning) {
        // Panning logic itself is in SvgCanvas, this just maintains state
        return;
      }
    },
    [isPanningWithSpace, draggingState],
  );

  const handleMouseUp = useCallback(
    (_e) => {
      if (isPanningWithSpace) setIsPanningWithSpace(false);
      
      // No history saving for drag/resize as they are disabled
      // Marquee selection is also disabled

      setDraggingState(null);
      setResizingState(null);
      setMarqueeRect({ active: false });
      setActiveSnapLines([]);
      // setOverlappingObjectIdsProp([]); // No overlaps for static
      mouseDownStartPosRef.current = null;
    },
    [
      isPanningWithSpace,
      // setHistory, // Not needed here anymore
      // objectsRef, // Not needed here anymore
      // selectedObjectIds, // Not needed for marquee here
      // setSelectedObjectIds, // Only for marquee which is disabled
      // screenToWorldRect, // Only for marquee
      // lockedObjectIds, // Only for marquee
      // setOverlappingObjectIdsProp // Disabled
    ],
  );

  const handleMouseLeave = useCallback(() => {
    if (isPanningWithSpace) setIsPanningWithSpace(false);
    if (draggingState || resizingState) {
      handleMouseUp({});
    }
    // setActiveSnapLines([]); // Already reset in mouseUp
    // setOverlappingObjectIdsProp([]); // Already reset in mouseUp
    // mouseDownStartPosRef.current = null; // Already reset in mouseUp
  }, [isPanningWithSpace, draggingState, resizingState, handleMouseUp]);

  return {
    draggingState, // Still needed for panning state
    resizingState: null, // Always null
    marqueeRect: { active: false }, // Always inactive
    isPanningWithSpace,
    activeSnapLines: [], // Always empty
    handleMouseDownOnObject,
    handleMouseDownOnResizeHandle, // Will do nothing
    handleMouseDownOnCanvas,
    handleMouseMove,
    handleMouseUp,
    handleMouseLeave,
  };
};

export default useMouseInteractions;

==== src\components\Configurator\hooks\useObjectManagement.js ====
import { useCallback } from "react";
import { toast } from 'react-toastify'; 
import {
  WALL_THICKNESS_M,
  DOOR_WIDTH_M as APP_DOOR_WIDTH_M,
  WINDOW_WIDTH_M as APP_WINDOW_WIDTH_M,
  DEFAULT_MODULE_WIDTH_M,
  DEFAULT_MODULE_HEIGHT_M,
} from "../appConstants";
import { defaultObjectSizes } from "../configuratorConstants";
import {
    getAABB,
    checkAABBIntersection,
    getDoorLeafCorners,
    isDoorLeafColliding,
    rotatePoint,
} from "../configuratorUtils";

let objectIdCounter = 0;
export const getNextId = () => `obj-${objectIdCounter++}`;

export const createObject = (type, x, y, width, height, data = {}) => {
  const baseObj = {
    id: getNextId(),
    type,
    x,
    y,
    width,
    height,
    rotation: data.rotation || 0,
    label: data.label || "",
    ...data,
  };
  if (type === "door") {
    baseObj.isOpen = data.isOpen === undefined ? false : data.isOpen;
    baseObj.openingAngle =
      data.openingAngle === undefined ? 90 : data.openingAngle;
    baseObj.hingeSide = data.hingeSide || "left";
    baseObj.openingDirection = data.openingDirection || "inward";
  }
  if (type === "module") {
      baseObj.mirroredX = data.mirroredX || false;
      baseObj.mirroredY = data.mirroredY || false;
  }
  return baseObj;
};

export const getInitialObjects = () => {
  objectIdCounter = 0; 
  const initialObjects = [];
  const WT = WALL_THICKNESS_M;
  const houseWidthOuter = 6;
  const houseDepthOuter = 3.5;
  const gap = 0.1;

  initialObjects.push(
    createObject("wall", 0, 0, houseWidthOuter, WT, { label: "Верхняя стена" }),
  );
  initialObjects.push(
    createObject("wall", 0, houseDepthOuter - WT, houseWidthOuter, WT, {
      label: "Нижняя стена",
    }),
  );
  initialObjects.push(
    createObject("wall", 0, WT, WT, houseDepthOuter - 2 * WT, {
      label: "Левая стена",
    }),
  );
  initialObjects.push(
    createObject(
      "wall",
      houseWidthOuter - WT,
      WT,
      WT,
      houseDepthOuter - 2 * WT,
      { label: "Правая стена" },
    ),
  );

  const mainDoorWidth = APP_DOOR_WIDTH_M;
  initialObjects.push(
    createObject("door", 1.0, houseDepthOuter - WT, mainDoorWidth, WT, {
      hingeSide: "left",
      openingDirection: "inward",
      isOpen: false,
      openingAngle: 0,
      label: "Входная дверь",
    }),
  );

  const mainWindowWidth = APP_WINDOW_WIDTH_M;
  initialObjects.push(
    createObject(
      "window",
      houseWidthOuter / 2 - mainWindowWidth / 2,
      0,
      mainWindowWidth,
      WT,
      { label: "Окно гостиной" },
    ),
  );

  const sofaWidth = 1.8;
  const sofaDepth = 0.8;
  initialObjects.push(
    createObject("sofa", WT + gap, WT + gap, sofaWidth, sofaDepth, {
      label: "Диван",
    }),
  );
  const coffeeTableWidth = 1.0;
  const coffeeTableDepth = 0.5;
  initialObjects.push(
    createObject(
      "table",
      WT + gap + (sofaWidth - coffeeTableWidth) / 2,
      WT + gap + sofaDepth + 0.3,
      coffeeTableWidth,
      coffeeTableDepth,
      { label: "Кофейный столик" },
    ),
  );

  const bedWidth = 1.5;
  const bedDepth = 2.0;
  const bedX = houseWidthOuter - WT - gap - bedWidth;
  const bedY = WT + gap;
  initialObjects.push(
    createObject("bed", bedX, bedY, bedWidth, bedDepth, { label: "Кровать" }),
  );
  const wardrobeWidth = 0.8;
  const wardrobeDepth = 0.5;
  initialObjects.push(
    createObject(
      "cabinet",
      bedX - gap - wardrobeWidth,
      bedY,
      wardrobeWidth,
      wardrobeDepth,
      { label: "Шкаф" },
    ),
  );

  const bathroomWidthInner = 1.5;
  const bathroomDepthInner = 1.8;
  const bathroomOuterWallX =
    houseWidthOuter - WT - gap - bathroomWidthInner - WT;
  const bathroomOuterWallY = WT + gap;
  initialObjects.push(
    createObject(
      "wall",
      bathroomOuterWallX,
      bathroomOuterWallY,
      bathroomWidthInner + WT,
      WT,
      { label: "Стена ванной (верх)" },
    ),
  );
  initialObjects.push(
    createObject(
      "wall",
      bathroomOuterWallX,
      bathroomOuterWallY + WT,
      WT,
      bathroomDepthInner,
      { label: "Стена ванной (лево)" },
    ),
  );
  const bathroomBottomWallDoorOpening = 0.75;
  const bathroomBottomWallSegment1Length =
    (bathroomWidthInner + WT - bathroomBottomWallDoorOpening) / 2;
  initialObjects.push(
    createObject(
      "wall",
      bathroomOuterWallX,
      bathroomOuterWallY + WT + bathroomDepthInner,
      bathroomBottomWallSegment1Length,
      WT,
      { label: "Стена ванной (низ1)" },
    ),
  );
  initialObjects.push(
    createObject(
      "wall",
      bathroomOuterWallX +
        bathroomBottomWallSegment1Length +
        bathroomBottomWallDoorOpening,
      bathroomOuterWallY + WT + bathroomDepthInner,
      bathroomBottomWallSegment1Length,
      WT,
      { label: "Стена ванной (низ2)" },
    ),
  );
  const bathroomDoorWidth = 0.7;
  initialObjects.push(
    createObject(
      "door",
      bathroomOuterWallX + bathroomBottomWallSegment1Length,
      bathroomOuterWallY + WT + bathroomDepthInner,
      bathroomDoorWidth,
      WT,
      {
        hingeSide: "right",
        openingDirection: "inward",
        isOpen: false,
        openingAngle: 0,
        label: "Дверь в ванную",
      },
    ),
  );
  const toiletWidth = 0.4;
  const toiletDepth = 0.7;
  initialObjects.push(
    createObject(
      "toilet",
      bathroomOuterWallX + WT + gap,
      bathroomOuterWallY + WT + gap,
      toiletWidth,
      toiletDepth,
      { label: "Туалет" },
    ),
  );

  return initialObjects;
};


const useObjectManagement = (
  setObjects,
  selectedObjectIds,
  lockedObjectIds,
  modifierKeys,
  objectsRef,
  activeMode,
) => {
  const addObject = useCallback(
    (type, x, y, width, height, data, skipHistory = false) => {
      const newObject = createObject(type, x, y, width, height, data);
      setObjects((prev) => [...prev, newObject], !skipHistory);
      return newObject;
    },
    [setObjects],
  );

  const updateObject = useCallback(
    (id, updates, skipHistory = false) => {
      setObjects(
        (prev) =>
          prev.map((obj) => (obj.id === id ? { ...obj, ...updates } : obj)),
        !skipHistory,
      );
    },
    [setObjects],
  );
  
  const updateMultipleObjects = useCallback((updatesArray, saveToHistory = true) => {
    setObjects(prevObjects => {
        const updatedObjects = prevObjects.map(obj => {
            const updateForThisObject = updatesArray.find(u => u.id === obj.id);
            return updateForThisObject ? { ...obj, ...updateForThisObject.updates } : obj;
        });
        return updatedObjects;
    }, saveToHistory);
  }, [setObjects]);


  const deleteObjectById = useCallback(
    (id) => {
      setObjects((prev) =>
        prev.filter(
          (obj) => obj.id !== id && obj.parentId !== id
        ), true);
    },
    [setObjects],
  );

  const updateSelectedObjectProperty = useCallback(
    (property, value) => {
      if (selectedObjectIds.length !== 1) return;
      const targetId = selectedObjectIds[0];
      
      if (!objectsRef || !objectsRef.current) {
        return;
      }
      const currentObjects = objectsRef.current; 

      const objToUpdate = currentObjects.find(obj => obj.id === targetId);

      if (!objToUpdate) return;

      const objectIsLocked = lockedObjectIds.includes(targetId);
      if (objectIsLocked && !modifierKeys.shift) {
        toast.warn(`Объект ${objToUpdate.label || objToUpdate.id} заблокирован.`);
        return;
      }

      let parsedValue = value;
      if (typeof objToUpdate[property] === 'number' && property !== 'rotation') { 
          const numVal = parseFloat(value);
          if (isNaN(numVal)) {
              toast.error(`Неверный формат числа для ${property}: ${value}`);
              return;
          }
          parsedValue = numVal;
      } else if (typeof objToUpdate[property] === 'boolean') {
          parsedValue = typeof value === 'string' ? value.toLowerCase() === "true" : Boolean(value);
      }


      if (objToUpdate.type === "door" && (property === "isOpen" || property === "openingAngle")) {
        let newIsOpen = objToUpdate.isOpen;
        let newOpeningAngle = objToUpdate.openingAngle; 

        if (property === "isOpen") {
          newIsOpen = parsedValue;
          if (newIsOpen) { 
            newOpeningAngle = (objToUpdate.openingAngle > 0) ? objToUpdate.openingAngle : 90; 
          } else { 
            newOpeningAngle = 0;
          }
        } else { 
          const potentialAngle = parseFloat(parsedValue); 
          if (isNaN(potentialAngle)) {
              toast.error(`Неверный угол: ${value}`);
              return;
          }
          newOpeningAngle = potentialAngle;
          if (newOpeningAngle <= 0) {
            newIsOpen = false;
            newOpeningAngle = 0; 
          } else {
            newIsOpen = true;
          }
        }
        
        let finalAngle = newOpeningAngle;
        let finalIsOpen = newIsOpen;

        if (finalIsOpen && finalAngle > 0) {
          const MAX_DOOR_ANGLE = 170; 
          const MIN_DOOR_ANGLE_STEP = 1; 
          let targetAngle = Math.min(Math.max(finalAngle, 0), MAX_DOOR_ANGLE);
          
          let resolvedAngle = 0; 
          let canOpenAtAll = false;

          for (let angleCheck = targetAngle; angleCheck >= MIN_DOOR_ANGLE_STEP; angleCheck -= 1) { 
            if (!isDoorLeafColliding(objToUpdate, angleCheck, currentObjects)) {
              resolvedAngle = angleCheck;
              canOpenAtAll = true;
              break;
            }
          }
          
          if (canOpenAtAll) {
            finalAngle = resolvedAngle;
             if (targetAngle > finalAngle && property === "openingAngle") {
                 toast.info(`Дверь '${objToUpdate.label || targetId}' открыта до ${finalAngle.toFixed(0)}° из-за препятствия.`); 
             } else if (targetAngle > finalAngle && property === "isOpen") {
                 toast.info(`Дверь '${objToUpdate.label || targetId}' открыта до ${finalAngle.toFixed(0)}° из-за препятствия.`);
             }
          } else { 
            const msg = `Дверь '${objToUpdate.label || targetId}' не может открыться (${targetAngle.toFixed(0)}°) из-за столкновения.`;
            toast.warn(msg); 
            finalAngle = 0;
            finalIsOpen = false;
          }
        } else { 
            finalAngle = 0;
            finalIsOpen = false;
        }
        
        if (objToUpdate.isOpen !== finalIsOpen || objToUpdate.openingAngle !== finalAngle) {
            setObjects(
              (prev) =>
                prev.map((obj) =>
                  obj.id === targetId ? { ...obj, isOpen: finalIsOpen, openingAngle: finalAngle } : obj,
                ),
              true,
            );
        }
        return; 
      }

      if (objToUpdate[property] !== parsedValue) {
          setObjects(
            (prev) =>
              prev.map((obj) =>
                obj.id === targetId ? { ...obj, [property]: parsedValue } : obj,
              ),
            true,
          );
      }
    },
    [selectedObjectIds, objectsRef, lockedObjectIds, modifierKeys.shift, setObjects], 
  );

  const addAndSelectObject = useCallback(
    (type, worldX, worldY) => {
      const defaultSize = defaultObjectSizes[type] || { width: 1, height: 1 };
      const newObject = createObject(
        type,
        worldX - defaultSize.width / 2,
        worldY - defaultSize.height / 2,
        defaultSize.width,
        defaultSize.height,
      );
      setObjects((prev) => [...prev, newObject], true);
      return newObject.id;
    },
    [setObjects],
  );

  const rotateModule180 = useCallback((moduleId) => {
    const moduleToRotate = objectsRef.current.find(obj => obj.id === moduleId && obj.type === 'module');
    if (!moduleToRotate) return;

    const newRotation = (moduleToRotate.rotation + 180) % 360;
    const childUpdates = [];
    const moduleCenterX = moduleToRotate.x + moduleToRotate.width / 2;
    const moduleCenterY = moduleToRotate.y + moduleToRotate.height / 2;

    objectsRef.current.forEach(obj => {
        if (obj.parentId === moduleId) {
            const localX = obj.x - moduleToRotate.x;
            const localY = obj.y - moduleToRotate.y;
            
            const rotatedLocalPoint = rotatePoint({x: localX, y: localY}, Math.PI, {x: moduleToRotate.width/2, y: moduleToRotate.height/2});
            
            const newChildX = moduleToRotate.x + (moduleToRotate.width - (rotatedLocalPoint.x + obj.width));
            const newChildY = moduleToRotate.y + (moduleToRotate.height - (rotatedLocalPoint.y + obj.height));

            const newChildRotation = (obj.rotation + 180) % 360;
            
            let newSide = obj.side;
            if(obj.side === 'top') newSide = 'bottom';
            else if(obj.side === 'bottom') newSide = 'top';
            else if(obj.side === 'left') newSide = 'right';
            else if(obj.side === 'right') newSide = 'left';

            childUpdates.push({
                id: obj.id,
                updates: {
                    x: newChildX,
                    y: newChildY,
                    rotation: newChildRotation,
                    side: newSide,
                }
            });
        }
    });
    updateMultipleObjects([{id: moduleId, updates: { rotation: newRotation }}, ...childUpdates], true);

  }, [objectsRef, updateMultipleObjects]);

  const mirrorModule = useCallback((moduleId, axis) => {
    const moduleToMirror = objectsRef.current.find(obj => obj.id === moduleId && obj.type === 'module');
    if (!moduleToMirror) return;

    const childUpdates = [];
    let moduleMirroredX = moduleToMirror.mirroredX;
    let moduleMirroredY = moduleToMirror.mirroredY;

    objectsRef.current.forEach(child => {
        if (child.parentId === moduleId) {
            let newChildX = child.x;
            let newChildY = child.y;
            let newChildRotation = child.rotation;
            let newHingeSide = child.hingeSide;
            let newSide = child.side;

            const localX = child.x - moduleToMirror.x;
            const localY = child.y - moduleToMirror.y;

            if (axis === 'x') {
                newChildX = moduleToMirror.x + (moduleToMirror.width - localX - child.width);
                if (child.type === 'door') {
                    newHingeSide = child.hingeSide === 'left' ? 'right' : 'left';
                }
                newChildRotation = (360 - child.rotation) % 360; 
                if(child.side === 'left') newSide = 'right';
                else if(child.side === 'right') newSide = 'left';
                moduleMirroredX = !moduleToMirror.mirroredX;
            } else if (axis === 'y') {
                newChildY = moduleToMirror.y + (moduleToMirror.height - localY - child.height);
                newChildRotation = (180 - child.rotation + 360) % 360;
                if(child.side === 'top') newSide = 'bottom';
                else if(child.side === 'bottom') newSide = 'top';
                moduleMirroredY = !moduleToMirror.mirroredY;
            }
            
            const updates = { x: newChildX, y: newChildY, rotation: newChildRotation, side: newSide };
            if (child.type === 'door') updates.hingeSide = newHingeSide;
            childUpdates.push({ id: child.id, updates });
        }
    });
    updateMultipleObjects([{id: moduleId, updates: { mirroredX: moduleMirroredX, mirroredY: moduleMirroredY }}, ...childUpdates], true);

  }, [objectsRef, updateMultipleObjects]);


  return {
    createObject,
    getInitialObjects,
    addObject,
    updateObject,
    deleteObjectById,
    updateSelectedObjectProperty,
    addAndSelectObject,
    defaultObjectSizes,
    rotateModule180,
    mirrorModule: mirrorModule,
    mirrorModuleX: (moduleId) => mirrorModule(moduleId, 'x'),
    mirrorModuleY: (moduleId) => mirrorModule(moduleId, 'y'),
  };
};

export default useObjectManagement;


==== src\components\Configurator\hooks\useViewTransform.js ====
import { useState, useCallback, useEffect } from "react";
import { INITIAL_PPM } from "../configuratorConstants";

const useViewTransform = (svgRef) => {
  const [viewTransform, setViewTransform] = useState({
    x: 80,
    y: 60,
    scale: INITIAL_PPM * 0.6,
  });
  const [initialized, setInitialized] = useState(false);

  useEffect(() => {
    if (initialized) return;
    const svg = svgRef.current;
    if (svg) {
      const rect = svg.getBoundingClientRect();
      if (rect.width > 0 && rect.height > 0) {
        setViewTransform((prev) => ({
          ...prev,
          x: rect.width / 2,
          y: rect.height / 2,
        }));
        setInitialized(true);
      }
    }
  }, [svgRef, initialized]);

  const screenToWorld = useCallback(
    (screenX, screenY) => {
      if (!svgRef.current) return { x: 0, y: 0 };
      const svgRect = svgRef.current.getBoundingClientRect();
      return {
        x: (screenX - svgRect.left - viewTransform.x) / viewTransform.scale,
        y: (screenY - svgRect.top - viewTransform.y) / viewTransform.scale,
      };
    },
    [viewTransform, svgRef],
  );

  const screenToWorldRect = useCallback(
    (rect) => {
      const tl = screenToWorld(rect.startScreenX, rect.startScreenY);
      const br = screenToWorld(rect.currentScreenX, rect.currentScreenY);
      return {
        minX: Math.min(tl.x, br.x),
        minY: Math.min(tl.y, br.y),
        maxX: Math.max(tl.x, br.x),
        maxY: Math.max(tl.y, br.y),
      };
    },
    [screenToWorld],
  );

  useEffect(() => {
    const currentSvgElement = svgRef.current;
    if (!currentSvgElement) return;

    const wheelHandler = (e) => {
      e.preventDefault();
      const scaleAmount = 1.1;
      const newScaleFactor = e.deltaY > 0 ? 1 / scaleAmount : scaleAmount;

      const svgRect = currentSvgElement.getBoundingClientRect();
      const mouseX = e.clientX - svgRect.left;
      const mouseY = e.clientY - svgRect.top;

      setViewTransform((prevTransform) => {
        const worldBeforeZoomX =
          (mouseX - prevTransform.x) / prevTransform.scale;
        const worldBeforeZoomY =
          (mouseY - prevTransform.y) / prevTransform.scale;
        const newScale = prevTransform.scale * newScaleFactor;
        const newViewX = mouseX - worldBeforeZoomX * newScale;
        const newViewY = mouseY - worldBeforeZoomY * newScale;
        return { x: newViewX, y: newViewY, scale: newScale };
      });
    };

    currentSvgElement.addEventListener("wheel", wheelHandler, {
      passive: false,
    });
    return () => {
      currentSvgElement.removeEventListener("wheel", wheelHandler);
    };
  }, [svgRef]);

  return {
    viewTransform,
    setViewTransform,
    screenToWorld,
    screenToWorldRect,
  };
};

export default useViewTransform;

==== src\components\Configurator\modes\FramelessMode.jsx ====
// src/components/Configurator/modes/FramelessMode.jsx
import React from "react";
import PropTypes from 'prop-types';
import { FaCube, FaPlusSquare } from "react-icons/fa";
import { toast } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import { DEFAULT_PANEL_WIDTH_M, DEFAULT_MODULE_WIDTH_M, DEFAULT_MODULE_HEIGHT_M, WALL_THICKNESS_M } from '../appConstants';


const FramelessMode = ({ 
  addObject, 
  getObjects,
  screenToWorld,
  viewTransform 
}) => {
  const handleAddModule = () => {
    if (!addObject) {
      toast.error("Add object function not available.");
      return;
    }

    const existingObjects = getObjects ? getObjects() : [];
    let newX = 1; 
    let newY = 1; 

    if (existingObjects.length > 0) {
      const lastObject = existingObjects[existingObjects.length - 1];
      newX = lastObject.x + lastObject.width + 1; 
      newY = lastObject.y;
    }

    const moduleObj = addObject(
      "panel", 
      newX,
      newY,
      DEFAULT_MODULE_WIDTH_M,
      DEFAULT_MODULE_HEIGHT_M,
      { name: "Standard Module" },
    );
    if (moduleObj) {
      toast.success(`Модуль ${moduleObj.id} добавлен!`);
    }
  };

  const handleAddInternalWall = () => {
    if (!addObject) {
      toast.error("Add object function not available.");
      return;
    }

    const { x: worldMouseX, y: worldMouseY } = screenToWorld
      ? screenToWorld(window.innerWidth / 2, window.innerHeight / 2)
      : { x: 2, y: 2 };

    const wallObj = addObject(
      "wall", 
      worldMouseX - DEFAULT_PANEL_WIDTH_M / 2, 
      worldMouseY - WALL_THICKNESS_M / 2,
      DEFAULT_PANEL_WIDTH_M, 
      WALL_THICKNESS_M, 
      { name: "Internal Wall" },
    );
    if (wallObj) {
      toast.success(`Внутренняя стена ${wallObj.id} добавлена!`);
    }
  };

  return (
    <div className="bg-gray-100 p-2 rounded shadow-md">
      <h3 className="text-sm font-semibold mb-2 text-gray-700">
        Инструменты строительства
      </h3>
      <div className="flex flex-col space-y-2">
        <button
          onClick={handleAddModule}
          className="flex items-center justify-center px-3 py-1.5 bg-blue-500 text-white text-xs rounded hover:bg-blue-600 transition-colors"
          title={`Добавить стандартный модуль (${DEFAULT_MODULE_WIDTH_M}x${DEFAULT_MODULE_HEIGHT_M}м)`}
        >
          <FaCube className="mr-2" /> Добавить Модуль
        </button>
        <button
          onClick={handleAddInternalWall}
          className="flex items-center justify-center px-3 py-1.5 bg-green-500 text-white text-xs rounded hover:bg-green-600 transition-colors"
          title="Добавить внутреннюю стену"
        >
          <FaPlusSquare className="mr-2" /> Добавить Стену
        </button>
      </div>
    </div>
  );
};

FramelessMode.propTypes = {
  addObject: PropTypes.func.isRequired,
  getObjects: PropTypes.func.isRequired,
  screenToWorld: PropTypes.func,
  viewTransform: PropTypes.object,
};

export default FramelessMode;

==== src\components\Configurator\modes\FrameMode.jsx ====
import React from "react";
import PropTypes from 'prop-types';

const FrameMode = ({ addObject, getObjects }) => {
  return null;
};

FrameMode.propTypes = {
  addObject: PropTypes.func.isRequired,
  getObjects: PropTypes.func.isRequired,
};

export default FrameMode;

==== src\components\Configurator\modes\ModularMode.jsx ====
// src/components/Configurator/modes/ModularMode.jsx
import React, { useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import { FaFilePdf } from "react-icons/fa";
import { DEFAULT_MODULE_WIDTH_M, DEFAULT_MODULE_HEIGHT_M, WALL_THICKNESS_M, DOOR_WIDTH_M } from '../appConstants';
import { defaultObjectSizes } from '../configuratorConstants';
import { rotatePoint } from '../configuratorUtils';


const PlatformVisual = ({ width = DEFAULT_MODULE_WIDTH_M, height = DEFAULT_MODULE_HEIGHT_M, label = "Выберите и добавьте новый контейнер" }) => {
  const scale = 50;
  const w = width * scale;
  const h = height * scale;
  const pad = 8;
  return (
    <svg width={w} height={h} viewBox={`0 0 ${w} ${h}`} style={{ width: "100%", height: "auto", maxHeight: "150px" }}>
      <rect x={0} y={0} width={w} height={h} fill="#fff" stroke="#888" strokeWidth={2} />
      <pattern id="hatch-platform" width="8" height="8" patternTransform="rotate(45)" patternUnits="userSpaceOnUse">
        <line x1="0" y1="0" x2="0" y2="8" stroke="#bbb" strokeWidth="1" />
      </pattern>
      <rect x={pad} y={pad} width={w - 2 * pad} height={h - 2 * pad} fill="url(#hatch-platform)" opacity="0.12" />
      <text x={w / 2} y={h / 2} textAnchor="middle" fill="#444" fontSize={scale * 0.18} fontWeight="bold" dy={-scale * 0.1}>
        {label}
      </text>
    </svg>
  );
};

const ModuleThumb = ({ width = 60, height = DEFAULT_MODULE_HEIGHT_M }) => { 
  const thumbHeight = height * (60 / DEFAULT_MODULE_WIDTH_M) * 0.8; 
  const viewBoxHeight = thumbHeight / 0.8 * (DEFAULT_MODULE_HEIGHT_M / DEFAULT_MODULE_WIDTH_M);
  return (
    <svg width={width} height={thumbHeight} viewBox={`0 0 60 ${viewBoxHeight}`} fill="none">
        <rect x="1" y="1" width="58" height={viewBoxHeight - 2} rx="3" fill="#f3f4f6" stroke="#333" strokeWidth="2" />
        <rect x="6" y="6" width="15" height="8" fill="#ddd" stroke="#aaa" strokeWidth="1" />
        <rect x="40" y={viewBoxHeight - 14} width="10" height="6" fill="#ddd" stroke="#aaa" strokeWidth="1" />
        <rect x="25" y={viewBoxHeight / 2 - 4} width="10" height="8" fill="#eee" stroke="#bbb" strokeWidth="1" />
    </svg>
  );
};


const MODULE_TEMPLATES = [
  {
    code: 'DEFAULT',
    name: 'Стандартный модуль',
    type: 'module',
    width: DEFAULT_MODULE_WIDTH_M,
    height: DEFAULT_MODULE_HEIGHT_M,
    config: {
        label: `Модуль ${DEFAULT_MODULE_WIDTH_M}x${DEFAULT_MODULE_HEIGHT_M}`,
        baseElements: [
            { type: 'door', xRel: (DEFAULT_MODULE_WIDTH_M - DOOR_WIDTH_M) / 2, yRel: DEFAULT_MODULE_HEIGHT_M - WALL_THICKNESS_M, width: DOOR_WIDTH_M, height: WALL_THICKNESS_M, rotation: 0, side: 'bottom', segmentIndex: Math.floor(((DEFAULT_MODULE_WIDTH_M - DOOR_WIDTH_M) / 2) / 1.15), label: "Дверь главная" },
            { type: 'light_led', xRel: (DEFAULT_MODULE_WIDTH_M - 1.2) / 2, yRel: (DEFAULT_MODULE_HEIGHT_M - 0.15) / 2, width: 1.2, height: 0.15, label: "Свет центр" },
            { type: 'outlet', xRel: WALL_THICKNESS_M, yRel: DEFAULT_MODULE_HEIGHT_M / 2 - 0.05, width: 0.1, height: 0.1, rotation: 0, side: 'left', segmentIndex: Math.floor((DEFAULT_MODULE_HEIGHT_M / 2 - 0.05)/1.15), label: "Розетка лево" },
        ]
    },
    thumb: <ModuleThumb width={60} height={DEFAULT_MODULE_HEIGHT_M} />,
  }
];

function worldToScreen(x, y, viewTransform, svgRef) {
  if (!svgRef?.current) return { screenX: 0, screenY: 0 };
  return {
    screenX: x * viewTransform.scale + viewTransform.x,
    screenY: y * viewTransform.scale + viewTransform.y,
  };
}

const ModularMode = ({
  addObject,
  getObjects,
  screenToWorld,
  viewTransform,
  svgRef,
  objects, 
}) => {
  const [showTemplates, setShowTemplates] = useState(false);
  const hasModule = getObjects().some(obj => obj.type === 'module');

  const gridSize = 1;
  const gridCenterX = Math.round(0 / gridSize) * gridSize; 
  const gridCenterY = Math.round(0 / gridSize) * gridSize;
  
  const areaWidth = MODULE_TEMPLATES[0].width;
  const areaHeight = MODULE_TEMPLATES[0].height;
  const areaX = gridCenterX - areaWidth / 2;
  const areaY = gridCenterY - areaHeight / 2;

  const topLeft = worldToScreen(areaX, areaY, viewTransform, svgRef);
  const bottomRight = worldToScreen(areaX + areaWidth, areaY + areaHeight, viewTransform, svgRef);
  const overlayStyle = {
    position: 'absolute',
    left: `${topLeft.screenX}px`,
    top: `${topLeft.screenY}px`,
    width: `${Math.max(100, bottomRight.screenX - topLeft.screenX)}px`,
    height: `${Math.max(50 * (areaHeight/areaWidth) , bottomRight.screenY - topLeft.screenY)}px`,
    pointerEvents: 'auto',
    zIndex: 20,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
  };
  
  useEffect(() => {
    if (!hasModule && objects.length === 0) { 
        setShowTemplates(true);
    } else {
        setShowTemplates(false);
    }
  }, [hasModule, objects]);


  const handleAreaClick = () => {
    if (!hasModule) {
        setShowTemplates(true);
    }
  };

  const handleSelectTemplate = (template) => {
    let moduleRotation = 0;
    if (objects.filter(obj => obj.type === 'module').length === 0) {
        moduleRotation = 0; 
    }

    const newModule = addObject(
      template.type,
      areaX,
      areaY,
      template.width,
      template.height,
      { rotation: moduleRotation, ...template.config, label: template.config.label || template.name },
      true 
    );

    if (newModule && template.config.baseElements) {
        template.config.baseElements.forEach(el => {
            const elSize = defaultObjectSizes[el.type] || {width: el.width, height: el.height};
            let childX = newModule.x + el.xRel;
            let childY = newModule.y + el.yRel;
            let childWidth = elSize.width;
            let childHeight = elSize.height;
            let childRotation = el.rotation || 0; 

            if (moduleRotation !== 0) {
                const angleRad = moduleRotation * (Math.PI / 180);
                const parentCenter = { x: newModule.width / 2, y: newModule.height / 2 };
                
                const rotatedChildCenterRel = rotatePoint(
                    { x: el.xRel + elSize.width/2 - parentCenter.x, y: el.yRel + elSize.height/2 - parentCenter.y },
                    angleRad,
                    {x: 0, y: 0} 
                );

                childX = newModule.x + parentCenter.x + rotatedChildCenterRel.x - elSize.width/2;
                childY = newModule.y + parentCenter.y + rotatedChildCenterRel.y - elSize.height/2;
                childRotation = (childRotation + moduleRotation) % 360;

                if ((moduleRotation === 90 || moduleRotation === 270) && 
                    (el.type === 'door' || el.type === 'window' || el.type === 'outlet' || el.type === 'radiator' || el.type === 'kitchen_unit')) {
                    [childWidth, childHeight] = [childHeight, childWidth];
                }
            }
             
            addObject(
                el.type,
                childX,
                childY,
                childWidth,
                childHeight,
                { 
                    ...el, 
                    rotation: childRotation, 
                    parentId: newModule.id,
                    label: el.label || el.type
                },
                true 
            );
        });
        
    }
    setShowTemplates(false);
  };


  return (
    <>
      {!hasModule && !showTemplates && (
        <div style={overlayStyle} onClick={handleAreaClick}>
          <PlatformVisual width={areaWidth} height={areaHeight} />
        </div>
      )}
      {showTemplates && (
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white border rounded shadow-lg p-0 z-30 min-w-[340px] max-w-[95vw]">
          <div className="flex flex-col divide-y divide-gray-200">
            {MODULE_TEMPLATES.map((tpl) => (
              <button
                key={tpl.code}
                className="flex items-center w-full px-0 py-0 hover:bg-blue-50 transition group focus:outline-none"
                onClick={() => handleSelectTemplate(tpl)}
              >
                <div className="flex-1 bg-gray-900 text-white p-4 text-left min-w-[120px] max-w-[160px] h-full flex flex-col justify-center">
                  <div className="font-bold text-lg leading-tight">{tpl.code}</div>
                  <div className="text-xs opacity-80 mt-1">{tpl.name}</div>
                </div>
                <div className="flex items-center justify-center p-2 bg-white min-w-[80px]">
                  {tpl.thumb}
                </div>
                <div className="flex flex-col items-center justify-center px-2">
                  <FaFilePdf className="text-gray-400 group-hover:text-blue-400 mb-1" title="PDF" />
                  <span className="text-[10px] text-gray-400">PDF</span>
                </div>
              </button>
            ))}
          </div>
          <button
            className="block w-full py-2 text-gray-500 hover:text-gray-700 text-xs underline border-t border-gray-200 bg-white"
            onClick={() => setShowTemplates(false)}
          >
            Отмена
          </button>
        </div>
      )}
    </>
  );
};

ModularMode.propTypes = {
  addObject: PropTypes.func.isRequired,
  getObjects: PropTypes.func.isRequired,
  screenToWorld: PropTypes.func,
  viewTransform: PropTypes.object,
  svgRef: PropTypes.object,
  objects: PropTypes.array,
};

export default ModularMode;

==== src\components\Configurator\ProjectInfo.jsx ====
import React from 'react';
import { motion } from 'framer-motion';

const ProjectInfo = ({ area = 0, cost = 0, elements = [] }) => {
    return (
        <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            className="fixed bottom-4 right-4 bg-white rounded-lg shadow-lg p-4 w-80"
        >
            <h3 className="text-lg font-semibold text-gray-800 mb-4">
                Інформація про проект
            </h3>
            
            <div className="space-y-3">
                <div className="flex justify-between items-center">
                    <span className="text-gray-600">Загальна площа:</span>
                    <span className="font-medium text-gray-800">{area.toFixed(2)} м²</span>
                </div>
                
                <div className="flex justify-between items-center">
                    <span className="text-gray-600">Орієнтовна вартість:</span>
                    <span className="font-medium text-gray-800">{cost.toLocaleString('uk-UA')} грн</span>
                </div>
                
                {elements.length > 0 && (
                    <div className="pt-3 border-t border-gray-200">
                        <h4 className="text-sm font-medium text-gray-600 mb-2">
                            Елементи проекту:
                        </h4>
                        <div className="space-y-2">
                            {elements.map((element, index) => (
                                <div key={index} className="flex justify-between items-center text-sm">
                                    <span className="text-gray-600">{element.name}</span>
                                    <span className="text-gray-800">{element.count} шт.</span>
                                </div>
                            ))}
                        </div>
                    </div>
                )}
            </div>
        </motion.div>
    );
};

export default ProjectInfo; 

==== src\components\Configurator\sidebar\PropertiesPanel.jsx ====
// src/components/Configurator/sidebar/PropertiesPanel.jsx
import React from "react";
import PropertyInput from "../common/PropertyInput";

const PropertiesPanel = ({
  primarySelectedObject,
  selectedObjectIds,
  lockedObjectIds,
  modifierKeys,
  updateSelectedObjectProperty,
  deleteSelectedObject,
  activeMode,
  rotateModule180,
  mirrorModuleX,
  mirrorModuleY,
}) => {
  if (!primarySelectedObject && selectedObjectIds.length === 0) {
    return (
      <div className="w-64 bg-gray-50 border-l border-gray-300 p-3 overflow-y-auto flex-shrink-0">
        <h2 className="text-md font-semibold mb-3 border-b pb-2">Свойства</h2>
        <p className="text-sm text-gray-500">Ничего не выбрано.</p>
      </div>
    );
  }

  if (selectedObjectIds.length > 1) {
    return (
      <div className="w-64 bg-gray-50 border-l border-gray-300 p-3 overflow-y-auto flex-shrink-0">
        <h2 className="text-md font-semibold mb-3 border-b pb-2">Свойства</h2>
        <p className="text-sm text-gray-500">
          Выбрано несколько объектов ({selectedObjectIds.length} шт).
          {selectedObjectIds.some((id) => lockedObjectIds.includes(id)) && (
            <span className="ml-1 text-xs text-orange-500">
              (есть заблокированные)
            </span>
          )}
        </p>
      </div>
    );
  }

  const isLockedAndCantEdit =
    lockedObjectIds.includes(primarySelectedObject.id) && !modifierKeys.shift;

  const objType = primarySelectedObject.type;
  const isModule = objType === 'module';
  const isCorridor = objType === 'corridor';
  // For static objects, most dimension/position properties are disabled
  const isStaticLike = true; 


  return (
    <div className="w-64 bg-gray-50 border-l border-gray-300 p-3 overflow-y-auto flex-shrink-0">
      <h2 className="text-md font-semibold mb-3 border-b pb-2">Свойства</h2>
      {primarySelectedObject && (
        <div>
          <p className="text-xs text-gray-500 mb-1">
            ID: {primarySelectedObject.id}{" "}
            {primarySelectedObject.label
              ? `(${primarySelectedObject.label})`
              : ""}
          </p>
          <p className="text-sm font-medium mb-2 capitalize">
            Тип: {objType}
            {lockedObjectIds.includes(primarySelectedObject.id) && (
              <span className="ml-2 text-orange-500 text-xs font-normal">
                (Locked)
              </span>
            )}
          </p>

          <PropertyInput
              label="X (м):"
              value={primarySelectedObject.x.toFixed(3)}
              onChange={(e) => updateSelectedObjectProperty("x", e.target.value)}
              disabled={isLockedAndCantEdit || isStaticLike}
            />
            <PropertyInput
              label="Y (м):"
              value={primarySelectedObject.y.toFixed(3)}
              onChange={(e) => updateSelectedObjectProperty("y", e.target.value)}
              disabled={isLockedAndCantEdit || isStaticLike}
            />

          <PropertyInput
              label={
                objType === "door" || objType === "window" ? "Длина (м):"
                : isCorridor && primarySelectedObject.width > primarySelectedObject.height ? "Длина (м):"
                : isCorridor && primarySelectedObject.height > primarySelectedObject.width ? "Высота (м):"
                : "Ширина (м):"
              }
              value={primarySelectedObject.width.toFixed(3)}
              min="0.01"
              onChange={(e) => updateSelectedObjectProperty("width", e.target.value)}
              disabled={isLockedAndCantEdit || isStaticLike}
            />
          <PropertyInput
              label={
                objType === "door" || objType === "window" || objType === "wall" || isCorridor ? "Толщина (м):"
                : "Высота (м):"
              }
              value={primarySelectedObject.height.toFixed(3)}
              min="0.01"
              onChange={(e) => updateSelectedObjectProperty("height", e.target.value)}
              disabled={isLockedAndCantEdit || isStaticLike}
            />

          <PropertyInput
              label="Вращение (°):"
              type="number"
              value={primarySelectedObject.rotation || 0}
              step="1"
              min="-360"
              max="360"
              onChange={(e) => updateSelectedObjectProperty("rotation", e.target.value)}
              disabled={isLockedAndCantEdit || isStaticLike}
          />
          
          {isModule && activeMode === 'modular' && (
            <div className="mt-2 space-y-1">
                <button
                    onClick={() => rotateModule180(primarySelectedObject.id)}
                    className={`w-full p-1 border border-gray-300 rounded text-xs bg-white hover:bg-gray-100 ${isLockedAndCantEdit || isStaticLike ? "cursor-not-allowed opacity-50" : ""}`}
                    disabled={isLockedAndCantEdit || isStaticLike}
                >
                    Повернуть на 180°
                </button>
                <button
                    onClick={() => mirrorModuleX(primarySelectedObject.id)}
                    className={`w-full p-1 border border-gray-300 rounded text-xs bg-white hover:bg-gray-100 ${isLockedAndCantEdit || isStaticLike ? "cursor-not-allowed opacity-50" : ""}`}
                    disabled={isLockedAndCantEdit || isStaticLike}
                >
                    Отзеркалить по X
                </button>
                <button
                    onClick={() => mirrorModuleY(primarySelectedObject.id)}
                    className={`w-full p-1 border border-gray-300 rounded text-xs bg-white hover:bg-gray-100 ${isLockedAndCantEdit || isStaticLike ? "cursor-not-allowed opacity-50" : ""}`}
                    disabled={isLockedAndCantEdit || isStaticLike}
                >
                    Отзеркалить по Y
                </button>
            </div>
          )}


          {objType === "door" && (
            <>
              <PropertyInput label="Открыта:">
                <button
                  onClick={() => updateSelectedObjectProperty("isOpen", !primarySelectedObject.isOpen)}
                  className={`w-full p-1 border border-gray-300 rounded text-sm bg-white hover:bg-gray-100 focus:outline-none focus:ring-1 focus:ring-blue-500 ${isLockedAndCantEdit ? "cursor-not-allowed opacity-50" : ""}`}
                  disabled={isLockedAndCantEdit}
                >
                  {primarySelectedObject.isOpen ? "Да (Закрыть)" : "Нет (Открыть)"}
                </button>
              </PropertyInput>
              <PropertyInput
                label="Угол откр. (°):"
                type="number"
                value={primarySelectedObject.openingAngle || 0}
                step="1"
                min="0"
                max="170"
                onChange={(e) => updateSelectedObjectProperty("openingAngle", e.target.value)}
                disabled={isLockedAndCantEdit || !primarySelectedObject.isOpen}
                title={!primarySelectedObject.isOpen ? "Сначала откройте дверь" : ""}
              />
              <PropertyInput label="Петли:">
                <select
                  value={primarySelectedObject.hingeSide || "left"}
                  onChange={(e) => updateSelectedObjectProperty("hingeSide", e.target.value)}
                  className={`w-full p-1 border border-gray-300 rounded text-sm ${isLockedAndCantEdit ? "bg-gray-100 cursor-not-allowed" : "bg-white focus:ring-1 focus:ring-blue-500 outline-none"}`}
                  disabled={isLockedAndCantEdit}
                >
                  <option value="left">Слева</option>
                  <option value="right">Справа</option>
                </select>
              </PropertyInput>
              <PropertyInput label="Направление откр.:">
                <select
                  value={primarySelectedObject.openingDirection || "inward"}
                  onChange={(e) => updateSelectedObjectProperty("openingDirection", e.target.value)}
                  className={`w-full p-1 border border-gray-300 rounded text-sm ${isLockedAndCantEdit ? "bg-gray-100 cursor-not-allowed" : "bg-white focus:ring-1 focus:ring-blue-500 outline-none"}`}
                  disabled={isLockedAndCantEdit}
                >
                  <option value="inward">Внутрь</option>
                  <option value="outward">Наружу</option>
                </select>
              </PropertyInput>
            </>
          )}
          {/* Удаление пока оставим, т.к. добавление есть */}
          <button
            onClick={deleteSelectedObject}
            className={`mt-4 w-full text-white text-sm py-1.5 rounded ${isLockedAndCantEdit ? "bg-red-300 cursor-not-allowed" : "bg-red-500 hover:bg-red-600"}`}
            disabled={isLockedAndCantEdit && primarySelectedObject}
          >
            Удалить {objType === 'module' ? 'модуль' : objType === 'corridor' ? 'коридор' : 'выбранный'}
          </button>
        </div>
      )}
    </div>
  );
};

export default PropertiesPanel;

==== src\components\Configurator\statusbar\StatusBar.jsx ====
import React from "react";

const StatusBar = ({
  selectedObjectIds = [],
  primarySelectedObject,
  lockedObjectIds = [],
  history = { undo: [], redo: [] },
}) => {
  return (
    <div className="p-1 bg-gray-100 border-t text-xs text-gray-700 flex justify-between">
      <span>
        {selectedObjectIds.length === 1 && primarySelectedObject
          ? `Выбран: ${primarySelectedObject.type} ${primarySelectedObject.label ? `(${primarySelectedObject.label})` : `(ID: ${primarySelectedObject.id})`}${lockedObjectIds.includes(primarySelectedObject.id) ? " [Locked]" : ""}`
          : selectedObjectIds.length > 1
            ? `${selectedObjectIds.length} объектов выбрано`
            : "Ничего не выбрано"}
      </span>
      <span>
        Undo: {history?.undo?.length || 0}, Redo: {history?.redo?.length || 0}
      </span>
    </div>
  );
};

export default StatusBar;

==== src\components\Configurator\toolbar\ConfiguratorToolbar.jsx ====
import React from "react";
import { OBJECT_TYPES_TO_ADD } from "../configuratorConstants";
import { MODES } from "../appConstants";
import { FaPlusCircle } from "react-icons/fa";

const ConfiguratorToolbar = ({
  activeModeName,
  addingObjectType,
  onStartAddObject,
  onModeChange,
  selectedObjectIds,
  primarySelectedObject,
  onDuplicateAndConnectModule,
}) => {
  const canDuplicateModule = activeModeName === MODES.MODULAR &&
                             selectedObjectIds &&
                             selectedObjectIds.length === 1 &&
                             primarySelectedObject &&
                             primarySelectedObject.type === 'module';

  return (
    <div className="p-2 bg-gray-800 text-white border-b border-gray-700 flex justify-between items-center flex-shrink-0">
      <div className="flex items-center space-x-4">
        <div>
          <h1 className="text-lg font-semibold">
            Конфигуратор
          </h1>
          <p className="text-xs text-gray-400">
            Space+Drag:Pan. Drag:Marquee. Shift+Click:Multi-select.
            Ctrl/Cmd+C/V/Z/Y. Alt:Grid Snap. Ctrl:Object Snap. Del/Esc.
            L:Lock/Unlock (Shift+Click locked item to select).
          </p>
        </div>
        <div className="flex space-x-2">
          <button
            onClick={() => onModeChange(MODES.MODULAR)}
            className={`px-3 py-1.5 rounded ${
              activeModeName === MODES.MODULAR
                ? "bg-blue-700 ring-2 ring-blue-400"
                : "bg-blue-500 hover:bg-blue-600"
            }`}
          >
            Модульный
          </button>
          <button
            onClick={() => onModeChange(MODES.FRAMELESS)}
            className={`px-3 py-1.5 rounded ${
              activeModeName === MODES.FRAMELESS
                ? "bg-blue-700 ring-2 ring-blue-400"
                : "bg-blue-500 hover:bg-blue-600"
            }`}
          >
            Безкаркасный
          </button>
          <button
            onClick={() => onModeChange(MODES.FRAMED)}
            className={`px-3 py-1.5 rounded ${
              activeModeName === MODES.FRAMED
                ? "bg-blue-700 ring-2 ring-blue-400"
                : "bg-blue-500 hover:bg-blue-600"
            }`}
          >
            Каркасный
          </button>
        </div>
        {activeModeName === MODES.MODULAR && (
          <button
            onClick={() => {
              if (canDuplicateModule && onDuplicateAndConnectModule) {
                onDuplicateAndConnectModule(primarySelectedObject.id, 'right');
              }
            }}
            title="Дублировать и соединить модуль"
            disabled={!canDuplicateModule}
            className={`px-2 py-1.5 text-xs sm:px-3 sm:py-1.5 sm:text-sm rounded whitespace-nowrap transition-colors flex items-center
                        ${canDuplicateModule
                            ? "bg-green-500 hover:bg-green-600"
                            : "bg-gray-500 cursor-not-allowed"}`}
          >
            <FaPlusCircle className="mr-1" /> Модуль+
          </button>
        )}
      </div>
      <div className="flex space-x-1 overflow-x-auto pb-1">
        {OBJECT_TYPES_TO_ADD.map((item) => (
          <button
            key={item.type}
            onClick={() => onStartAddObject(item.type)}
            title={`Добавить ${item.label}`}
            className={`px-2 py-1 text-xs sm:px-3 sm:py-1.5 sm:text-sm rounded whitespace-nowrap hover:bg-blue-600 transition-colors ${
              addingObjectType === item.type
                ? "bg-blue-700 ring-2 ring-blue-400"
                : "bg-blue-500"
            }`}
          >
            {item.label}
          </button>
        ))}
      </div>
    </div>
  );
};

export default ConfiguratorToolbar;

==== src\index.css ====
/* src/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Add any global styles below */
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
} 

==== src\index.js ====
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css'; // Assuming you have global styles here
import App from './App';
import reportWebVitals from './reportWebVitals'; // Optional: for performance monitoring

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
    <App />

);



==== src\reportWebVitals.js ====
// src/reportWebVitals.js
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals; 

==== tailwind.config.js ====
// ========================================================================
// FILE: tailwind.config.js
// ========================================================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./public/index.html",
    "./src/**/*.{js,jsx,ts,tsx}", // Сканируем все JS/JSX/TS/TSX файлы в src
  ],
  theme: {
    extend: {
      // Основная палитра
      colors: {
        "dark-bg": "#121212", // Еще темнее фон для контраста
        "card-bg": "#1E1E1E", // Фон карточек и элементов UI
        "primary-blue": "#007BFF", // Основной акцентный синий
        "gradient-blue": "#00C4FF", // Вторичный синий для градиентов
        "hover-blue": "#0056b3", // Синий для hover эффектов
        // Расширение стандартных цветов Tailwind
        gray: {
          900: "#111827", // Используется для фона, если dark-bg не задан
          800: "#1F2937", // Темно-серый для элементов UI
          700: "#374151", // Серый для границ, фона инпутов
          600: "#4B5563", // Серый для текста, границ
          500: "#6B7280", // Серый для второстепенного текста, иконок
          400: "#9CA3AF", // Светло-серый для текста
          300: "#D1D5DB", // Еще светлее
          200: "#E5E7EB", // Почти белый
          100: "#F3F4F6", // Очень светлый
        },
        // Можно добавить другие акцентные цвета
        // 'accent-green': '#10B981',
        // 'accent-red': '#EF4444',
        // 'accent-yellow': '#F59E0B',
      },
      // Шрифты
      fontFamily: {
        sans: [
          "Inter",
          "system-ui",
          "-apple-system",
          "BlinkMacSystemFont",
          '"Segoe UI"',
          "Roboto",
          '"Helvetica Neue"',
          "Arial",
          '"Noto Sans"',
          "sans-serif",
          '"Apple Color Emoji"',
          '"Segoe UI Emoji"',
          '"Segoe UI Symbol"',
          '"Noto Color Emoji"',
        ],
        // Можно добавить моноширинный шрифт
        mono: [
          "ui-monospace",
          "SFMono-Regular",
          "Menlo",
          "Monaco",
          "Consolas",
          '"Liberation Mono"',
          '"Courier New"',
          "monospace",
        ],
      },
      // Анимации
      animation: {
        // spin уже есть по умолчанию в Tailwind v3+
        "fade-in": "fadeIn 0.5s ease-out forwards",
        "slide-up": "slideUp 0.5s ease-out forwards",
      },
      keyframes: {
        fadeIn: {
          "0%": { opacity: "0" },
          "100%": { opacity: "1" },
        },
        slideUp: {
          "0%": { opacity: "0", transform: "translateY(10px)" },
          "100%": { opacity: "1", transform: "translateY(0)" },
        },
      },
      // Тени
      boxShadow: {
        md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
        lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
        xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
        "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
        "inner-md": "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
        "blue-glow-sm":
          "0 1px 3px 0 rgba(0, 123, 255, 0.1), 0 1px 2px -1px rgba(0, 123, 255, 0.1)",
        "blue-glow-md":
          "0 4px 6px -1px rgba(0, 123, 255, 0.1), 0 2px 4px -2px rgba(0, 123, 255, 0.1)",
        "blue-glow-lg":
          "0 10px 15px -3px rgba(0, 123, 255, 0.1), 0 4px 6px -4px rgba(0, 123, 255, 0.1)",
      },
    },
  },
  plugins: [
    // Официальные плагины Tailwind
    require("@tailwindcss/forms"), // Стили для элементов форм по умолчанию
    require("@tailwindcss/typography"), // Стили для прозы (например, из Markdown)
    require("@tailwindcss/aspect-ratio"), // Для соотношения сторон
    require("@tailwindcss/line-clamp"), // Для обрезки текста по количеству строк
  ],
  // variants в Tailwind v3+ используются реже, предпочтительнее модификаторы (hover:, focus:, group-hover:)
  // Но если нужны специфичные варианты:
  variants: {
    extend: {
      // Пример:
      backgroundColor: ["active"],
      opacity: ["disabled"],
      cursor: ["disabled"],
    },
  },
};

